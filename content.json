{"meta":{"title":"旋律演奏猿","subtitle":null,"description":"演奏程序猿的生活旋律","author":"Aaron Hu","url":"https://melodyplayer.github.io","root":"/"},"pages":[{"title":"404 Not Found","date":"2019-07-19T13:27:30.956Z","updated":"2019-07-19T11:17:18.382Z","comments":true,"path":"404.html","permalink":"https://melodyplayer.github.io/404.html","excerpt":"","text":"404 Not Found **很抱歉，您访问的页面不存在** 可能是输入地址有误或该地址已被删除"},{"title":"关于","date":"2019-07-19T13:33:52.990Z","updated":"2019-07-19T11:14:35.256Z","comments":true,"path":"about/index.html","permalink":"https://melodyplayer.github.io/about/index.html","excerpt":"","text":""},{"title":"所有分类","date":"2019-07-19T13:38:22.344Z","updated":"2019-07-19T13:38:22.341Z","comments":true,"path":"blog/categories/index.html","permalink":"https://melodyplayer.github.io/blog/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"大型网站技术架构","slug":"大型网站技术架构","date":"2019-11-17T13:32:29.000Z","updated":"2019-11-17T19:29:02.450Z","comments":true,"path":"blog/2019/1117:大型网站技术架构/","link":"","permalink":"https://melodyplayer.github.io/blog/2019/1117:大型网站技术架构/","excerpt":"不逼自己一把，可能连本书都没时间看。。 终于把李智慧大佬的《大型网站技术架构——核心原理与案例分析》看完了，顺便梳理了全书脉络。本书出版于2013年，正是web系统辉煌的顶峰，虽然缺少移动互联网系统的相关介绍，但是系统架构的主题思想仍然是沿用的，即使是5G时代为可能出现的物联网信息大爆炸而设计的服务器系统。所以放眼现在，该书也是系统架构设计入门不可多得的“武功秘籍”。 文末会列出一些对该书的思考，欢迎大家在评论区一起探讨优秀的系统架构设计。","text":"不逼自己一把，可能连本书都没时间看。。 终于把李智慧大佬的《大型网站技术架构——核心原理与案例分析》看完了，顺便梳理了全书脉络。本书出版于2013年，正是web系统辉煌的顶峰，虽然缺少移动互联网系统的相关介绍，但是系统架构的主题思想仍然是沿用的，即使是5G时代为可能出现的物联网信息大爆炸而设计的服务器系统。所以放眼现在，该书也是系统架构设计入门不可多得的“武功秘籍”。 文末会列出一些对该书的思考，欢迎大家在评论区一起探讨优秀的系统架构设计。 大型网站架构演化发展历程 大型网站架构模式 大型网站核心架构要素 思考 大型网站发展历程补充后期淘宝系统架构发展历史：分布式系统之后，应用自研的OceanBase数据库，使用云计算、混合云，服务容器化等技术。 虽然文中没有提及微服务这个名词，事实上思想已经存在。 分布式中间件的应用在该书出版后的短短6年，各项技术如雨后春笋出现在大众视野，其中很多分布式中间件已经发展到非常成熟的地步，应用十分广泛。 分布式缓存：现阶段主流应用层缓存为redis，尤其是redis-cluster模式，在memcached的互不通信的基础上，增加了主从功能，从而实现数据分片和备份。 分布式消息中间件：ActiveMQ没落，RocketMQ和Kafka盛行，RabbitMQ仍有一席之地。 前端缓存补充一下移动互联网时代的前端缓存，举个典型的优化案例，网易云音乐的评论系统，用户在评论后点击确定立即看到了自己的评论，其实是缓存在手机app上的信息，而真正的信息此时可能刚刚进入消息队列，并没有持久化到数据库中。 线程池参数定义此处需要更正，现阶段的线程池个数设置遵循以下规则： 计算密集型任务，N=CPU数量+1 IO密集型任务，N=CPU数量 * CPU利用率 * （1 + 线程等待时间/线程CPU时间）","categories":[],"tags":[{"name":"other","slug":"other","permalink":"https://melodyplayer.github.io/blog/tags/other/"}]},{"title":"正则表达式进阶用法与真实调优案例","slug":"正则表达式进阶用法与真实调优案例","date":"2019-10-17T09:55:38.000Z","updated":"2019-11-02T18:00:42.482Z","comments":true,"path":"blog/2019/1017:正则表达式进阶用法与真实调优案例/","link":"","permalink":"https://melodyplayer.github.io/blog/2019/1017:正则表达式进阶用法与真实调优案例/","excerpt":"正则表达式并不陌生，但当面对复杂的正则表达式：长度长，特殊符号多，多分组的情况下，解析速度会怎样？","text":"正则表达式并不陌生，但当面对复杂的正则表达式：长度长，特殊符号多，多分组的情况下，解析速度会怎样？ 正则表达式基础为节省版面直击要害，基础内容本文不作赘述，请点击以下链接查看： 表达式全集 史上最全常用正则表达式大全 真实案例：超级慢的正则表达式常用的正则表达式一般几秒内解析完毕，那么见过3分钟都没解析出来的正则表达式吗？请往下看： 解析目标过滤请求中不合法的 uri（不包含参数），如包含特殊符号- = + % ?、多个斜杠//、中文等。 代码实现正则表达式：&quot;^(/?[A-Za-z0-9\\\\-]+/?[A-Za-z0-9\\\\-]+)+/?&quot; 编写 java 代码： 12345678910111213// 所有方法设置成静态的，方便 main 调用private static final Pattern URI_PATTERN = Pattern.compile(\"^(/?[A-Za-z0-9\\\\-]+/?[A-Za-z0-9\\\\-]+)+/?)\";public static boolean validateUri(String uri) &#123; Matcher m = URI_PATTERN.matcher(uri); return m.matches();&#125;public static void validate() &#123; System.out.println(\"开始。。。。。。\"); System.out.println(validateUri(\"/hotel/getUseraaaaaaaasdfasdfasdfasdfasdf+\")); System.out.println(\"结束。。。。。。\");&#125; 执行 validate 方法。 测试结果6C32G mac pro 跑了3分钟没跑完。。没耐心继续等待，直接中断。 最简单的解决方案简化正则表达式为：^/?([-A-Za-z0-9]/?)+$ 但是我们需要知道为什么？如果就想在原来的基础上做修改，该怎么办？ 原因探索：回溯匹配猜测：考虑字符太长，以及特殊符号的问题测试1：把 uri 中间的 aaaaaasdfsdf 等去掉后，只保留简单的 /hotel/getUser+，很明显速度提上来了。 测试2：把 uri 中的 + 号提前，变成 /hotel/getUser+aaaaaaaasdfasdfasdfasdfasdf，速度也很快。 初步结论：非匹配字符的位置会影响正则表达式的执行效率为此需要知道正则表达式的执行规则：回溯。 比如要匹配的字符串是 helloworld,hihaojava 正则表达式是 h(ello|ihao)java 匹配过程： 从字符串第一个字符 h 开始匹配，可以命中。 接下来的匹配正则有2个分支 ello 和 ihao 。在 e 处打标记，先从左边的 ello 开始匹配，可以匹配字符串，但是到了 world 的 w 时，与正则中的 j 不一致，该分支匹配结束。接着回溯到刚刚的标记处，开始第二个分支 ihao，无法匹配，接下来正则会从 h 开始匹配字符串。 从字符串的第二个字符 e 继续匹配，直到正则的第一个字符 h 匹配到字符串的 , 之后匹配成功。 接着正则的2个分支执行匹配，最终只有 ihao匹配成功，最终匹配到的字符串是 hihaojava。 看完了正则的匹配过程，就知道为什么前面代码中的正则匹配效率会那么低下了。每个字母都要匹配到最后的+才发现匹配失败，回溯后继续查找，如果忽略其他，只考虑字符串 getUseraaaaaaaasdfasdfasdfasdfasdf+ 和正则 [-A-Za-z0-9] 的影响，时间复杂度就已经为 n^2，类似于以下模拟代码： 12345678910111213141516171819// 模拟代码，真实情况远比这个复杂，这里仅为了方便理解public static boolean execute(String s) &#123; String reg = \"-ABCDEFGHIJKMLNOPQRSTUVWSYZabcdefghijkmlnopqrstuvwsyz0123456789\"; int i = 0, count = 0; int length = s.length(); for (; i &lt; length; i++) &#123; for (int j = 0; j &lt; length; j++) &#123; count ++; String idx = s.substring(j, j + 1); if (!reg.contains(idx)) &#123; System.out.println(\"匹配失败！特殊字符：\" + idx); break; &#125; System.out.println(\"匹配字符：\" + idx); &#125; &#125; System.out.println(\"一共匹配了 \" + count + \"次！字符串长度为 \" + length); return i != length;&#125; 解决方法：采用进阶匹配模式正则模式：贪婪、勉强、侵占假定字符串为：aahelloworldhello 贪婪模式（.*he）：将正则分为两个模式 p1 .* 以及 p2 wo 。 第一轮匹配：p1读入所有字符串，那么p2就没什么都没匹配到。 第二轮匹配：字符串被分割为 aahelloworldhell 和 o，p1匹配子串1成功，p2匹配子串2失败。 直到字符串分割为 aahelloworld 和 hello时，两个正则模式都匹配成功。匹配到的子串为aahelloworldhe，停止匹配，返回结果。 勉强模式（.*?he）：最小匹配方式。此时的正则模式为 .*? 和 wo。 第一次匹配：p1由于是0或任意次，被忽略，用字符串整体去匹配 p2，当然失败。 第二次匹配：p1读入第一个字符 a，匹配成功，剩余的 ahelloworldhello 由 p2匹配，失败。 直到字符串分割为 aa 和 helloworldhello，两个正则模式都匹配成功。匹配子串 aahe，返回结果。 继续匹配，直到字符串分隔为 lloworld 和 hello，匹配子串 lloworldhe，返回结果。 侵占模式（.*+he）：也叫占用模式。匹配开始时读入所有字符串和 p1匹配成功，但没有剩余字符串去和 p2匹配，因此返回匹配失败。 说明：贪婪模式和占有模式相比，贪婪模式会在只有部分匹配成功的条件下，依次从多到少减少匹配成功部分模式的匹配数量，将字符留给模式其他部分去匹配。而占用模式则是占有所有能匹配成功部分，绝不留给其他部分使用。 代码演示1234567891011121314151617181920212223public static final Pattern PATTERN_GREEDY = Pattern.compile(\".*he\");public static final Pattern PATTERN_FORCED = Pattern.compile(\".*?he\");public static final Pattern PATTERN_OCCUPIED = Pattern.compile(\".*+he\");public static void execute() &#123; String s = \"aahelloworldhello\"; Matcher greedy = PATTERN_GREEDY.matcher(s); while (greedy.find()) &#123; System.out.println(\"贪婪模式：匹配到子串 \" + greedy.group()); System.out.println(\"贪婪模式：查找匹配到的子串在原始串中的索引位置 \" + greedy.start()); System.out.println(\"贪婪模式：查找匹配到的子串最后一个字符串在原串中的位置 \" + greedy.end()); &#125; Matcher forced = PATTERN_FORCED.matcher(s); while (forced.find()) &#123; System.out.println(\"勉强模式：匹配到子串 \" + forced.group()); System.out.println(\"勉强模式：查找匹配到的子串在原始串中的索引位置 \" + forced.start()); System.out.println(\"勉强模式：查找匹配到的子串最后一个字符串在原串中的位置 \" + forced.end()); &#125; Matcher occupied = PATTERN_OCCUPIED.matcher(s); System.out.println(\"侵占模式：匹配原串任意位置返回的结果： \" + occupied.find());&#125; 返回的结果： 123456789101112贪婪模式：匹配到子串 aahelloworldhe贪婪模式：查找匹配到的子串在原始串中的索引位置 0贪婪模式：查找匹配到的子串最后一个字符串在原串中的位置 14 勉强模式：匹配到子串 aahe勉强模式：查找匹配到的子串在原始串中的索引位置 0勉强模式：查找匹配到的子串最后一个字符串在原串中的位置 4勉强模式：匹配到子串 lloworldhe勉强模式：查找匹配到的子串在原始串中的索引位置 4勉强模式：查找匹配到的子串最后一个字符串在原串中的位置 14 侵占模式：匹配原串任意位置返回的结果： false 在这个基础上，之前的难题迎刃而解。对于判断 uri 是否合法的问题，不需要正则做回溯操作，整体不合法则返回匹配失败即可，因此选用侵占模式，需要将之前的正则表达式改进一下。 原始正则表达式：&quot;^(/?[A-Za-z0-9\\\\-]+/?[A-Za-z0-9\\\\-]+)+/?&quot; 改进后的正则表达式：&quot;^(/?[A-Za-z0-9\\\\-]++/?[A-Za-z0-9\\\\-]++)+/?&quot; 测试后发现速度变为了 ms 级，只增加 + 号，效果显而易见。 正则高级用法补充除了贪婪勉强侵占模式以外，补充一些其他的高级用法。 获取匹配 Capturing系统在幕后将所有的子模式匹配结果保存起来，供我们查找或替换。 后向引用：使用 \\数字 代表前面某个子模式的匹配内容，使用 $数字 代表变量。 例如：匹配合法的 html 标记。 正则：&lt;h([1-6])&gt;.*?&lt;/h\\1&gt; 文本：&lt;h1&gt; text1&lt;/h1&gt; &lt;h2&gt;text23&lt;/h3&gt; 其中 &lt;h1&gt;text1&lt;/h1&gt; 被成功匹配。\\1代表前面的子模式([1-6])的匹配结果1。 常见应用：匹配重复单词 (\\w+) \\1，匹配合法的 html 标记。 非获取匹配 Non-Capturing在子模式内部前面添加 ?:。表示这个子模式的匹配内容不会被保存，不能用于后向引用中。 例如：Windows 95 and Windows 98 are the successor. Then Windows 2000 and Windows Xp appeared. Windows Vista is the Latest version of the family. 正则：Windows (?:[\\w]+\\b) 匹配：Windows 95 and Windows 98 are the successor. Then Windows 2000 and Windows Xp appeared. Windows Vista is the Latest version of the family. 结果：只匹配内容，但并未保存子匹配的结果 正向肯定预查：在子模式内部前面加 ?=，子模式仅仅作为条件限制，并不作为匹配结果输出，匹配子模式前面的内容。 正则：Windows (?=[\\d]+\\b) 匹配：Windows 95 and Windows 98 are the successor. Then Windows 2000 and Windows Xp appeared. Windows Vista is the Latest version of the family. 正向否定预查：在子模式内部前面加 ?!。 正则：Windows (?![\\d]+\\b) 匹配：Windows 95 and Windows 98 are the successor. Then Windows 2000 and Windows Xp appeared. Windows Vista is the Latest version of the family. 反向肯定预查：在子模式内部前面加 ?&lt;=，匹配子模式后面的结果作为匹配结果。 例如：CNY:100.2 USD:222.1 USD:301.3 HKD:122.1 CNY:114.4 正则：(?&lt;=CNY:)\\d+\\.\\d 匹配：CNY:100.2 USD:222.1 USD:301.3 HKD:122.1 CNY:114.4 反向否定预查：在子模式内部前面加 ?&lt;! 正则：(?&lt;!CNY:)\\b\\d+\\.\\d 匹配：CNY:100.2 USD:222.1 USD:301.3 HKD:122.1 CNY:114.4 代码演示 获取匹配 12String s = \"abc def aaa bbb\".replaceAll(\"(\\\\w+)\\\\s(\\\\w+)\", \"$2 $1\");// 结果是 def abc bbb aaa 非获取匹配 12345678910111213141516171819202122232425262728293031323334353637383940public static final Pattern PATTERN = Pattern.compile(\"Windows (?:[\\\\w]+\\\\b)\");public static final Pattern PATTERN_POSITIVE_YES = Pattern.compile(\"Windows (?=[\\\\d]+\\\\b)\");public static final Pattern PATTERN_POSITIVE_NO = Pattern.compile(\"Windows (?![\\\\d]+\\\\b)\");public static final Pattern PATTERN_NEGATIVE_YES = Pattern.compile(\"(?&lt;=CNY:)\\\\d+\\\\.\\\\d+\");public static final Pattern PATTERN_NEGATIVE_NO = Pattern.compile(\"(?&lt;!CNY:)\\\\b\\\\d+\\\\.\\\\d+\");public static final String STR1 = \"Windows 95 and Windows 98 are the successor. Then Windows 2000 and Windows Xp appeared. Windows Vista is the Latest version of the family.\";public static final String STR2 = \"CNY:100.25 USD:222.16 USD:301.3 HKD:122.1 CNY:114.4\";public static void execute() &#123; Matcher noCapturing = PATTERN.matcher(STR1); System.out.println(\"\\n非获取匹配结果：---------\"); while (noCapturing.find()) &#123; System.out.print(noCapturing.group() + \"\\t\"); &#125; Matcher positiveYes = PATTERN_POSITIVE_YES.matcher(STR1); System.out.println(\"\\n正向肯定预查结果：---------\"); while (positiveYes.find()) &#123; System.out.print(positiveYes.group() + \"\\t\"); &#125; Matcher positiveNo = PATTERN_POSITIVE_NO.matcher(STR1); System.out.println(\"\\n正向否定预查结果：---------\"); while (positiveNo.find()) &#123; System.out.print(positiveNo.group() + \"\\t\"); &#125; Matcher negativeYes = PATTERN_NEGATIVE_YES.matcher(STR2); System.out.println(\"\\n负向肯定预查结果：---------\"); while (negativeYes.find()) &#123; System.out.print(negativeYes.group() + \"\\t\"); &#125; Matcher negativeNo = PATTERN_NEGATIVE_NO.matcher(STR2); System.out.println(\"\\n负向否定预查结果：---------\"); while (negativeNo.find()) &#123; System.out.print(negativeNo.group() + \"\\t\"); &#125;&#125; 运行结果： 12345678910非获取匹配结果：---------Windows 95 Windows 98 Windows 2000 Windows Xp Windows Vista正向肯定预查结果：---------Windows Windows Windows正向否定预查结果：---------Windows Windows负向肯定预查结果：---------100.25 114.4负向否定预查结果：---------222.16 301.3 122.1","categories":[],"tags":[{"name":"general","slug":"general","permalink":"https://melodyplayer.github.io/blog/tags/general/"}]},{"title":"mac单机部署mysql多实例","slug":"mac单机部署mysql多实例","date":"2019-10-03T19:04:45.000Z","updated":"2019-11-02T11:34:43.907Z","comments":true,"path":"blog/2019/1004:mac单机部署mysql多实例/","link":"","permalink":"https://melodyplayer.github.io/blog/2019/1004:mac单机部署mysql多实例/","excerpt":"单机部署mysql多实例，需要用到 mysql 自带的 mysqld_multi 命令，在目录 support_files 下有 mysqld_multi.server 命令封装。","text":"单机部署mysql多实例，需要用到 mysql 自带的 mysqld_multi 命令，在目录 support_files 下有 mysqld_multi.server 命令封装。 mysql 版本：5.7.27单机多实例配置手动创建 my.cnf 文件mac 使用 dmg 文件直接安装，不会自动生成 my.cnf 文件，需要手动创建。 12345678910111213[mysqld_multi]mysqld = /usr/local/mysql/bin/mysqld_safemysqladmin = /usr/local/mysql/bin/mysqladminuser = rootpassword = root[mysqld1]socket = /tmp/mysql.sock1port = 3311pid-file = /usr/local/var/mysql/data/data1/hostname.pid1datadir = /usr/local/var/mysql/data/data1language = /usr/local/mysql/share/englishuser = root 执行 mysqld_multi.server start这时会在控制台显示出生成的密码，记住待会儿会进行修改。 修改密码1mysqladmin -u root -P 3312 -p -S /tmp/mysql.sock2 password 连接 mysql1mysql -u root -p -P 3312 -S /tmp/mysql.sock2 关闭mysql123./mysqld_multi.server stop #关闭所有./mysqld_multi.server stop 1 #关闭单个./mysqld_multi.server stop 1-2 #关闭某个范围的实例 单机多实例主从配置必读：MySQL的主从复制介绍及配置 具体执行顺序按照链接中的顺序操作即可。这里只谈在操作中采的坑以及核心要点。 不要在命令行直接输入密码，例如：mysql -u root -p &#39;root&#39; -P 3312 -S /tmp/mysql.sock2 解决方法：去掉-p后的 ‘root’。mysql -u root -p -P 3312 -S /tmp/mysql.sock2 从库Slave_IO_Running: Connecting 问题 12Slave_IO_Running: ConnectingSlave_SQL_Running: Yes 解决方法：这个问题多半是未连接到主库专门用来复制的用户，检查用户名，用户权限等。 主库备份问题 关键在于了解参数的意义，可以指定某个数据库进行备份，也可以-A全部备份。 1mysqldump -u root -p -S /tmp/mysql/mysql.sock1 -A &gt; mysql_bak.2019-10-06.sql","categories":[],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://melodyplayer.github.io/blog/tags/mysql/"}]},{"title":"线程池invokeAll方法详解","slug":"线程池invokeAll方法详解","date":"2019-08-10T13:23:50.000Z","updated":"2019-08-10T16:56:08.594Z","comments":true,"path":"blog/2019/0810:线程池invokeAll方法详解/","link":"","permalink":"https://melodyplayer.github.io/blog/2019/0810:线程池invokeAll方法详解/","excerpt":"线上真实案例，多次调用线程池 ThreadPoolExecutor 的 invokeAll() 方法进行数据统计时任务被拒绝，故事从此开始。 本文重在讲述问题的产生、抽象、寻找解决方法的过程，并结合源码对原因进行抽丝剥茧般的分析。bug 千千万万，唯有合理的逻辑推理思维才能让这些 bug 显露原形。","text":"线上真实案例，多次调用线程池 ThreadPoolExecutor 的 invokeAll() 方法进行数据统计时任务被拒绝，故事从此开始。 本文重在讲述问题的产生、抽象、寻找解决方法的过程，并结合源码对原因进行抽丝剥茧般的分析。bug 千千万万，唯有合理的逻辑推理思维才能让这些 bug 显露原形。 问题起源与抽象先来看一段简单的代码，定义一个核心线程数5、有界队列5的线程池，然后创建10个任务丢进去执行2次。 按照以前对线程池执行逻辑的理解，创建的10个线程，会先交给核心线程去执行，5个核心线程满了之后，存放到队列中，刚好存储剩下的5个，按理说10个任务都会正常执行完毕。本次只测试固定大小的线程池。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class InvokeAllTest &#123; private static ThreadPoolExecutor executor = new ThreadPoolExecutor(5, 5, 60 * 1000, TimeUnit.SECONDS, new ArrayBlockingQueue&lt;&gt;(5), new MyThreadFactory()); public static void main(String[] args) &#123; List&lt;Callable&lt;Void&gt;&gt; tasks = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 10; i++) &#123; tasks.add(new InvokeAllThread()); &#125; System.out.println(\"第一次任务执行前的executor： \" + executor); try &#123; executor.invokeAll(tasks); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(\"第一次任务执行完毕后的executor： \" + executor); System.out.println(\"==============第一次任务执行完毕，开始第二次任务============\"); try &#123; Thread.sleep(1000); executor.invokeAll(tasks); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(\"第二次任务执行完毕后的executor：\" + executor); &#125; // 任务执行线程。通过打印线程名称，观察提交的任务被哪个线程执行 static class InvokeAllThread implements Callable&lt;Void&gt; &#123; @Override public Void call() throws Exception &#123; System.out.println(Thread.currentThread().getName()); return null; &#125; &#125; // 给工作线程自定义名字，方便观察提交的任务被哪个线程执行 static class MyThreadFactory implements ThreadFactory &#123; private AtomicInteger threadNum = new AtomicInteger(1); @Override public Thread newThread(Runnable r) &#123; Thread thread = new Thread(r, String.valueOf(threadNum.getAndIncrement())); if (thread.getPriority() != Thread.NORM_PRIORITY) &#123; thread.setPriority(Thread.NORM_PRIORITY); &#125; return thread; &#125; &#125; 运行程序后发现，第一次调用 invokeAll 正常执行，第二次调用报错。多次执行结果相同。 123456789101112131415161718192021222324第一次任务执行前的executorjava.util.concurrent.ThreadPoolExecutor@30f39991[Running, pool size = 0, active threads = 0, queued tasks = 0, completed tasks = 0]1234453233第一次任务执行完毕后的executorjava.util.concurrent.ThreadPoolExecutor@30f39991[Running, pool size = 5, active threads = 0, queued tasks = 0, completed tasks = 10]==============第一次任务执行完毕，开始第二次任务============24521Exception in thread \"main\" java.util.concurrent.RejectedExecutionException: Task java.util.concurrent.FutureTask@3a71f4dd rejected from java.util.concurrent.ThreadPoolExecutor@30f39991[Running, pool size = 5, active threads = 2, queued tasks = 0, completed tasks = 13] at java.util.concurrent.ThreadPoolExecutor$AbortPolicy.rejectedExecution(ThreadPoolExecutor.java:2063) at java.util.concurrent.ThreadPoolExecutor.reject(ThreadPoolExecutor.java:830) at java.util.concurrent.ThreadPoolExecutor.execute(ThreadPoolExecutor.java:1379) at java.util.concurrent.AbstractExecutorService.invokeAll(AbstractExecutorService.java:238) at com.aaron.hp.thread.pool.InvokeAllTest.main(InvokeAllTest.java:36) 问题排查与猜测既然程序出现异常，就该调用 debug 模式进行排查，并遵循”大胆猜测，小心求证”的态度，去解决这个问题。 猜测一：invokeAll 在异步执行后会不会同步等待线程执行完毕获取最终结果由于 invokeAll 封装的太好，之前只知道最后会同步等待才能获取返回值。那么现在就需要去证实这个概念。 进入 invokeAll 方法后，发现调用了f.get()，那么毫无疑问，这个猜测可以排除掉了。 其实从执行过程的输出内容也可以看出，两次调用 invokeAll 的执行顺序和界限(打印语句) 非常明显。 1234567891011121314151617181920212223242526272829303132public &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks) throws InterruptedException &#123; if (tasks == null) throw new NullPointerException(); ArrayList&lt;Future&lt;T&gt;&gt; futures = new ArrayList&lt;Future&lt;T&gt;&gt;(tasks.size()); boolean done = false; try &#123; for (Callable&lt;T&gt; t : tasks) &#123; RunnableFuture&lt;T&gt; f = newTaskFor(t); futures.add(f); // 任务被添加后的具体执行 execute(f); &#125; for (int i = 0, size = futures.size(); i &lt; size; i++) &#123; Future&lt;T&gt; f = futures.get(i); if (!f.isDone()) &#123; try &#123; // 此处同步等待 f.get(); &#125; catch (CancellationException ignore) &#123; &#125; catch (ExecutionException ignore) &#123; &#125; &#125; &#125; done = true; return futures; &#125; finally &#123; if (!done) for (int i = 0, size = futures.size(); i &lt; size; i++) futures.get(i).cancel(true); &#125;&#125; 猜测二：队列里面可能存在第一次调用 invokeAll 执行了但没有删掉的任务，所以才会导致第二次放入队列失败由于未阅读源码，猜测只有当创建的任务执行完毕并且销毁之后，才会从队列中真正移除。 那么就需要查看入队列和出队列的时机。查看 invokeAll 方法中的 execute(f) 方法。 查看 ThreadPoolExecutor 类下的 execute 方法源码： 12345678910111213141516171819202122public void execute(Runnable command) &#123; if (command == null) throw new NullPointerException(); int c = ctl.get(); // 判断工作线程数是否小于核心线程数，如果是则创建 Worker 工作线并返回 if (workerCountOf(c) &lt; corePoolSize) &#123; if (addWorker(command, true)) return; c = ctl.get(); &#125; // 判断主线程是否在运行，并判断是否入队列成功 if (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123; int recheck = ctl.get(); if (! isRunning(recheck) &amp;&amp; remove(command)) reject(command); else if (workerCountOf(recheck) == 0) addWorker(null, false); &#125; // 否则重新创建 Worker 线程，创建失败则抛出拒绝策略 else if (!addWorker(command, false)) reject(command);&#125; 此时就会发现入队列的操作在workQueue.offer(command)处完成，而我们提交的任务是由一个叫 Worker 类的实例来执行，addWorker(command, true)创建 Worker 实例。 那么我们就分别进去这两个方法来看下源码： 矮油黑人问号脸。。没想到这个 ThreadPoolExecutor 类的 addWorker 这么长，给核心代码写个注释重点关注，扫一眼然后去看 offer 方法(英文注释是源码中自带的)。前面都是校验，创建核心线程处为new Worker(firstTask)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869private boolean addWorker(Runnable firstTask, boolean core) &#123; retry: for (;;) &#123; int c = ctl.get(); int rs = runStateOf(c); // Check if queue empty only if necessary. if (rs &gt;= SHUTDOWN &amp;&amp; ! (rs == SHUTDOWN &amp;&amp; firstTask == null &amp;&amp; ! workQueue.isEmpty())) return false; for (;;) &#123; int wc = workerCountOf(c); if (wc &gt;= CAPACITY || wc &gt;= (core ? corePoolSize : maximumPoolSize)) return false; if (compareAndIncrementWorkerCount(c)) break retry; c = ctl.get(); // Re-read ctl if (runStateOf(c) != rs) continue retry; // else CAS failed due to workerCount change; retry inner loop &#125; &#125; boolean workerStarted = false; boolean workerAdded = false; Worker w = null; try &#123; // 上面一堆都是校验，此处才是 Worker 被创建的地方，注意被传入的 firstTask w = new Worker(firstTask); // 此处发现 Worker 里面居然还有个 therad 线程，不过想想也是，没有线程怎么异步执行呢。点进 Worker 的构造方法看一眼就会发现，这个线程就是由我们自定义的 threadFactory 来创建的，所以核心线程名称就是我们之前设定好的名字。this.thread = getThreadFactory().newThread(this); final Thread t = w.thread; if (t != null) &#123; final ReentrantLock mainLock = this.mainLock; mainLock.lock(); try &#123; // Recheck while holding lock. // Back out on ThreadFactory failure or if // shut down before lock acquired. int rs = runStateOf(ctl.get()); if (rs &lt; SHUTDOWN || (rs == SHUTDOWN &amp;&amp; firstTask == null)) &#123; if (t.isAlive()) // precheck that t is startable throw new IllegalThreadStateException(); workers.add(w); int s = workers.size(); if (s &gt; largestPoolSize) largestPoolSize = s; workerAdded = true; &#125; &#125; finally &#123; mainLock.unlock(); &#125; if (workerAdded) &#123; // worker 实例成功创建后，让它启动起来 t.start(); workerStarted = true; &#125; &#125; &#125; finally &#123; if (! workerStarted) addWorkerFailed(w); &#125; return workerStarted;&#125; 接着是 ArrayBlockingQueue 类的 offer 方法，在 enqueue(e)处进入队列： 12345678910111213141516public boolean offer(E e) &#123; checkNotNull(e); final ReentrantLock lock = this.lock; lock.lock(); try &#123; if (count == items.length) return false; else &#123; // 进入队列 enqueue(e); return true; &#125; &#125; finally &#123; lock.unlock(); &#125;&#125; 此时我们先来调试一波，看看入队列时这些方法的执行情况，在三个 if 处分别设置断点，在 addWorker 和 offer 方法靠前的未知打断点，确定是否会进入。 第一次调用 invokeAll：addWorker 进入5次，offer 方法进入5次。 第二次调用 invokeAll：addWorker 进入0次，offer 方法进入10次（可能是5-10次）。 那么发现了新的问题：程序居然没报错！正常执行完成！这不科学！ 带着疑惑，重新 debug，居然还没报错！难道之前的异常是偶然吗？ 以最快速度连按 F9 debug了几次，有时候报错。。 重新运行 run 了几次，次次报错。。 怀疑人生了。。 此时墨菲定律在我头脑中回响，”偶然事件存在必然的因素”。那么大胆猜测，这个原因极有可能是队列消费速度较慢导致的，去查看消费部分的源码。由于 worker 也是一个线程，那么肯定有类似的 run 方法： 查看 ThreadPoolExecutor 类 的 Worker 这个内部类，找到 run() 方法： 123public void run() &#123; runWorker(this);&#125; 而 run 方法调用的是 ThreadPoolExecutor 类里的 runWorker(this)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748final void runWorker(Worker w) &#123; Thread wt = Thread.currentThread(); // 此处注意，将 worker 里存入的 firstTask 取出来，交给下面的 while 去执行 Runnable task = w.firstTask; // 将 worker 里的 firstTask 属性置空 w.firstTask = null; w.unlock(); // allow interrupts boolean completedAbruptly = true; try &#123; // 如果 task 不为空，即取出的 firstTask 不为空，则执行；否则调用 getTask() 方法获取 task 再执行 while (task != null || (task = getTask()) != null) &#123; w.lock(); // If pool is stopping, ensure thread is interrupted; // if not, ensure thread is not interrupted. This // requires a recheck in second case to deal with // shutdownNow race while clearing interrupt if ((runStateAtLeast(ctl.get(), STOP) || (Thread.interrupted() &amp;&amp; runStateAtLeast(ctl.get(), STOP))) &amp;&amp; !wt.isInterrupted()) wt.interrupt(); try &#123; // 此处为空实现，可自定义 beforeExecute(wt, task); Throwable thrown = null; try &#123; // 调用 task 的 run 方法执行任务 task.run(); &#125; catch (RuntimeException x) &#123; thrown = x; throw x; &#125; catch (Error x) &#123; thrown = x; throw x; &#125; catch (Throwable x) &#123; thrown = x; throw new Error(x); &#125; finally &#123; afterExecute(task, thrown); &#125; &#125; finally &#123; task = null; w.completedTasks++; w.unlock(); &#125; &#125; completedAbruptly = false; &#125; finally &#123; processWorkerExit(w, completedAbruptly); &#125;&#125; 查看 ThreadPoolExecutor 类下的 getTask() 方法： 1234567891011121314151617181920212223242526272829303132333435363738private Runnable getTask() &#123; boolean timedOut = false; // Did the last poll() time out? for (;;) &#123; int c = ctl.get(); int rs = runStateOf(c); // Check if queue empty only if necessary. if (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123; decrementWorkerCount(); return null; &#125; int wc = workerCountOf(c); // Are workers subject to culling? boolean timed = allowCoreThreadTimeOut || wc &gt; corePoolSize; if ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut)) &amp;&amp; (wc &gt; 1 || workQueue.isEmpty())) &#123; if (compareAndDecrementWorkerCount(c)) return null; continue; &#125; try &#123; // 此处为出队列操作，poll 和 take 的区别在于，poll 会等待指定时间，而 take 是阻塞的，会一直等待 Runnable r = timed ? workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) : workQueue.take(); if (r != null) return r; timedOut = true; &#125; catch (InterruptedException retry) &#123; timedOut = false; &#125; &#125;&#125; 看到这里，猜测二也就不攻自破，出队列后任务才会被执行，所以某个任务出队列后，执行成功与否与队列再无瓜葛。(注意这个说法只针对默认代码，如果自定义了拒绝策略是可以将被 interrupt 的线程重新塞回队列里的) 两次猜测失败后的总结 队列是异步消费的，但入队是同步进行的，如果队列的容量不足以承载要存入队列的任务数，就会被拒绝。(虽然是 ArrayBlockQueue 的特性，但这是通过 debug 以及 run 后观察到的) 第一次 addWorker 方法执行了5次，offer 执行了5次；第二次则是 0 次，10 次。刚才忽略了这个细节，那么需要重新找到相应的源码阅读。 任务从队列中移除与任务是否执行完毕无关，先移除，后执行。 我们创建的任务，是由 worker 核心线程去调用任务的 run 方法来同步执行的，而不是调用任务实例的 start 去异步执行，这也就是为什么 invokeAll 可以获取到返回值的原因所在。 备注：这里有点绕，任务实例指的是我们最开始在 for 循环中创建的10个tasks new InvokeAllThread()，为什么继承了 Callable 明明改写的是 call()方法，但却有 run()方法可以被调用呢？这是因为在 invokeAll()方法执行execute()方法前，通过RunnableFuture&lt;T&gt; f = newTaskFor(t);进行了包装。 复查源码，真相大白查看 ThreadPoolExecutor 类下的 execute() 方法，创建 worker 前的判断如下： 1if (workerCountOf(c) &lt; corePoolSize) &#123; ...&#125; 第一次调用 invokeAll 时，线程池中的核心线程 worker 数为0，小于 corePoolSize，所以前5次会创建 worker 核心线程并返回，此时随着 worker 的创建，我们创建的10个任务中的5个也会随着 worker 的创建作为 firstTask 属性被传进去。后5个任务则被放入 queue 中。 第二次调用 invokeAll 时，线程池中的核心数已经是5，所以10个任务都会被放入 queue 中异步消费，但是我们的 queue 的容量为5。如果消费速度快于入队速度(debug)，那么10个任务会正常执行。但是入队速度太快的话(run)，前5个肯定可以入队，后面的5个几乎都会被拒绝。 问题解决方案 对于固定大小的线程池，我们要按照实际情况设置 queue 和 worker 的数量。根据任务类型（IO/CPU）以及机器配置（CPU 核数等）设置 worker 核心线程数；而根据我们的任务多少来设定 queue 的大小，而不是 queue + worker 的总数。 重写拒绝策略，将被丢弃的任务重新 put 回队列中去，put 是阻塞的。 参考ThreadPoolExecutor源码分析及阻塞提交任务方法 Thread的中断机制(interrupt)","categories":[],"tags":[{"name":"java","slug":"java","permalink":"https://melodyplayer.github.io/blog/tags/java/"}]},{"title":"搭建博客要点","slug":"搭建博客要点","date":"2019-07-19T07:23:43.000Z","updated":"2019-07-20T06:25:12.055Z","comments":true,"path":"blog/2019/0719:搭建博客要点/","link":"","permalink":"https://melodyplayer.github.io/blog/2019/0719:搭建博客要点/","excerpt":"跟同事一次普通的聊天，谈论到个人博客后，他帮我创建了 github 的博客雏形，从此一发不可收拾。。 一周时间，每天整到半夜2点多，终于搭建完毕。给大家分享下搭建博客核心要点。","text":"跟同事一次普通的聊天，谈论到个人博客后，他帮我创建了 github 的博客雏形，从此一发不可收拾。。 一周时间，每天整到半夜2点多，终于搭建完毕。给大家分享下搭建博客核心要点。 流程参考： https://www.cnblogs.com/liuxianan/p/build-blog-website-by-hexo-github.html https://blog.csdn.net/KNIGH_YUN/article/details/79774344 github 账户创建的仓库名要采用 username.github.io 的形式，才能达到最简洁的 melodyplayer.github.io，不然网站后缀会加斜杠仓库名 “/repoName”，例如：melodyplayer.github.io/melody，增加访问复杂度。 域名绑定 记录类型 A 把域名转发到某个 ipv4 地址上。对于 github 来说可以采用这种方式，ping 一下 github 生成的默认域名拿到 ip 输入到记录值里即可，再在相应的仓库里创建 CNAME 文件。 主机记录填 www 或者不填时， 向github 里的 CNAME文件写入 www.melodyplay.cn 。 主机记录填二级域名例如 blog 时，则向github 里的 CNAME 文件写入 blog.melodyplay.cn 。 记录类型 CNAME 可以把请求转发到另外一个域名上，此时的记录值输入 melodyplayer.github.io 即可。 主题相关主题列表：https://hexo.io/themes/ 我的选择：https://xaoxuu.com/wiki/material-x/ 修改字体：https://www.zhangxinxu.com/wordpress/2017/03/css3-font-face-src-local/ hexo 命令必读：hexo 文档 12345hexo clean #清除public目录，该目录由 hexo g 生成hexo g #生成public目录，如果在source里创建非md文件，会按原样拷贝到public中，例如CNAME的创建hexo s #本地启动hexo服务hexo d #部署到远程仓库hexo new \"x\" #新建文件 hexo 配置本地调试相应的属性时，hexo 会自动编译less、ejd 等文件，可以实时看到结果。 如果要上传到多个平台的仓库下，配置形式： 12345deploy: type: git repository: github: https://github.com/melodyplayer/melodyplayer.github.io.git,master gitee: https://gitee.com/melodyplayer/melodyplayer.git,master gitee 博客使用 gitee 也可以搭建博客，创建方式类似 github 。 仓库名要与用户名一致，才能达到最简洁的 melodyplayer.gitee.io 形式。 gitee 的 ip 好像不是固定的，因此不能在域名解析时直接配置 ip，原来的 CNAME 文件也不会生效。需要通过第三方转发平台如米发做转发，然后再配置域名解析为 CNAME 的方式，但是速度惊人。。的慢。。 具体配置方式参考：https://www.jianshu.com/p/b9466c7e339b 选择图床图床选择也纠结了很久，最终选用了 github 单独仓库做图床，使用 picgo 上传图片。 picgo 可以在上传图片前修改文件名，在文件名前加目录/，变相实现图片归档。 github每个仓库容量1G。 gitee总容量5G，但是不支持图床。 其他图床：img.vim-cn.com、https://sm.ms/ 使用流程：https://xaoxuu.com/projects/vim-cn.sh/ 评论系统评论系统有很多： 参考：https://xaoxuu.com/wiki/material-x/third-party-services/index.html#%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F valine：需要拿身份证实名验证，果断放弃。不在意的朋友可以用下，应该是比较专业的。 gittalk：https://www.voidking.com/2018/07/26/deve-hexo-gitalk-comment-plugin/ gittalk可能无法创建 issue 的问题：https://github.com/viosey/hexo-theme-material/issues/622 对于我采用的主题来说，需要在 scripts 中对 id 进行 md5。 12345678910&lt;% if (enableGitalk) &#123; %&gt; &lt;script src=&quot;https://cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; var gitalk = new Gitalk(&#123; clientID: &quot;&lt;%- config.gitalk.clientID %&gt;&quot;, ...... id: md5(location.pathname), // Ensure uniqueness and length less than 50 ...... &lt;/script&gt;&lt;% &#125; %&gt; 牛人博客推荐的几个美观易读的牛人博客（临时记录在这里，后期维护到移步大佬）： xaouu：我的主题采用的他的，非常感谢。 码酱：java基础 闪烁之狐：java基础，博客排版华丽 匠心零度 程序猿 DD 纯洁的微笑 芋道源码","categories":[],"tags":[{"name":"other","slug":"other","permalink":"https://melodyplayer.github.io/blog/tags/other/"}]},{"title":"旋律演奏猿","slug":"旋律演奏猿","date":"2019-07-16T03:22:26.000Z","updated":"2019-10-17T09:47:48.735Z","comments":true,"path":"blog/2019/0716:旋律演奏猿/","link":"","permalink":"https://melodyplayer.github.io/blog/2019/0716:旋律演奏猿/","excerpt":"开始自己的第一个博客，主要记录和分享在工作和学习中用到的一些技术，也会写一些兴趣爱好的文章，分享一些好听的音乐、精彩的电影等等。集工作学习与休闲一体，秉承简单、开放、匠心的精神，演奏程序猿的生活旋律。","text":"开始自己的第一个博客，主要记录和分享在工作和学习中用到的一些技术，也会写一些兴趣爱好的文章，分享一些好听的音乐、精彩的电影等等。集工作学习与休闲一体，秉承简单、开放、匠心的精神，演奏程序猿的生活旋律。","categories":[],"tags":[{"name":"description","slug":"description","permalink":"https://melodyplayer.github.io/blog/tags/description/"}]}]}