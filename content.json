{"meta":{"title":"旋律演奏猿","subtitle":null,"description":"演奏程序猿的生活旋律","author":"Aaron Hu","url":"https://melodyplayer.github.io","root":"/"},"pages":[{"title":"404 Not Found","date":"2019-07-19T13:27:30.956Z","updated":"2019-07-19T11:17:18.382Z","comments":true,"path":"404.html","permalink":"https://melodyplayer.github.io/404.html","excerpt":"","text":"404 Not Found **很抱歉，您访问的页面不存在** 可能是输入地址有误或该地址已被删除"},{"title":"关于","date":"2019-07-19T13:33:52.990Z","updated":"2019-07-19T11:14:35.256Z","comments":true,"path":"about/index.html","permalink":"https://melodyplayer.github.io/about/index.html","excerpt":"","text":""},{"title":"所有分类","date":"2019-07-19T13:38:22.344Z","updated":"2019-07-19T13:38:22.341Z","comments":true,"path":"blog/categories/index.html","permalink":"https://melodyplayer.github.io/blog/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"《设计模式之禅》——行为型（下）","slug":"《设计模式之禅》——行为型（下）","date":"2019-12-22T07:23:43.000Z","updated":"2020-02-29T17:22:24.049Z","comments":true,"path":"blog/2019/1222:《设计模式之禅》——行为型（下）/","link":"","permalink":"https://melodyplayer.github.io/blog/2019/1222:《设计模式之禅》——行为型（下）/","excerpt":"11种行为型模式（下）：观察者、备忘录、访问者、状态、解释器","text":"11种行为型模式（下）：观察者、备忘录、访问者、状态、解释器 观察者模式 Observer也叫发布订阅模式 Publish/Subscribe。定义对象间一对多依赖关系，依赖对象可以得到通知并自动更新。包含一下几个角色： Subject 被观察者：一般是抽象类或实现类，能动态增删观察者，并完成管理观察者并通知观察者的职责。 Observer 观察者：观察者接收消息后进行处理。 ConcreteSubject 具体的被观察者：定义个性化业务逻辑，同事定义对哪些事件进行通知。 ConcreteObserver 具体的观察者：定义个性化处理逻辑。 类图 使用场景 关联行为场景。注意关联行为可拆分，而不是 “组合” 关系。 事件多级触发场景。 跨系统的消息交换场景，如消息队列的处理机制。 实践中的应用： 文件系统：比如在一个目录下新建一个文件，这个动作会同时通知目录管理器增加该目录，并通知磁盘管理器减少 1kb 的空间，也就是说 “文件” 时一个被观察者，“目录管理器” 和 “磁盘管理器” 则是观察者。 猫鼠游戏：夜里猫叫一声，家里的老鼠逃跑，同时也吵醒了熟睡的主人。 ATM 取钱：多次输错密码会被吞卡，此时触发的动作有：1. 摄像头连续快拍；2. 通知监控系统发生吞卡； 3. 初始化 ATM 机屏幕，返回最初状态。通常 1、2 通过观察者模式来完成，3 异常完成。 广播收音机：电台广播，可用多个收音机来收听。 优点 观察者和被观察者之间是抽象耦合。非常容易扩展观察者和被观察者。 建立一套触发机制。根据单一职责原则，需要把每个单一职责类串联起来的时候。比如打猎打死了一只母鹿，母鹿三个幼崽饿死，尸体被两只秃鹰争抢，分配不均内斗，胜利的秃鹰生存下来并扩大了地盘。这就是一个触发机制，形成了一个触发链。 缺点 需要考虑开发效率和运行效率问题。一个被观察者、多个观察者，开发和调试会比较复杂。而且 java 中消息的通知默认是顺序执行，一个观察者卡壳，会影响整体的执行效率。此时一般采用异步的方式。 多级触发时更需要注意效率问题。 注意事项 广播链问题 多级触发逻辑复杂，可维护性差。对于观察者来说还可能具有多重身份，既是观察者也是被观察者。经验建议在一个观察者模式中最多出现一个对象既是观察者又是被观察者，也就是消息最多转发一次（传递2次）。 异步处理问题 被观察者发生动作，观察者需要做出回应，如果观察者比较多，处理时间长，需要用异步处理，此时就要考虑线程安全和队列的问题。可参考 Message Queue。 扩展 java 世界中的观察者模式 Java 中提供可扩展的父类 java.util.Observable，作为被观察者的父类。接口 java.util.Observer，作为观察者的父类。而子类只需实现自己的逻辑方法。 项目中真实的观察者模式，改造后包含以下3个方面： 观察者和被观察者之间的消息沟通 被观察者状态改变会触发观察者的一个行为，同时会传递一个消息给观察者。实际中的做法是：观察者中的 update 方法接受两个参数，一个是被观察者，一个是DTO数据传输对象，这个是纯洁的 javabean，由被观察者生成，由观察者消费。 远程传输一般以 xml、json 等格式传递。 观察者响应方式 一个观察者多个被观察者的情况下，需要考虑性能问题。如果观察者来不及响应，被观察者的执行时间是不是也会被拉长？问题就在于观察者如何快速响应，有如下两个办法。 办法一：采用多线程技术，不论被观察者启动线程还是观察者启动线程，都可以明显地提高系统性能。这是异步架构。 办法二：采用缓存技术，保证足够的资源快速响应。代价是开发难度大，而且压测要足够充分。这是同步架构。 被观察者尽量自己做主 被观察者的状态改变不一定非要通知观察者。设计时要灵活考虑，避免加重观察者的逻辑处理。一般会对被观察者的业务逻辑 doSomething 方法重载，如增加一个 doSomething(boolean isNotifyObs) 方法，决定是否通知观察者，而不是在消息到达观察者时才判断是否要消费。 订阅发布模型 EJB3 中有3个类型的Bean：Session Bean、EntityBean 和 MessageDriven Bean （消息驱动 Bean），消息的发布者（Provider）发布一个消息 MDB，通过 EJB 容器（一般是 Message Queue 消息队列）通知订阅者做出回应。 代码演示以电脑为例，包含显示器、风扇、系统、键盘等组件。电源接通时，通知各个组件进行工作，各个组件也会监听键盘、鼠标进行响应。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263// 观察者class ScreenImpl implements Observer &#123; public void show() &#123; System.out.println(\"屏幕开始显示！\"); &#125; public void close() &#123; System.out.println(\"屏幕关闭！\"); &#125; @Override public void update(Observable o, Object arg) &#123; String command = String.valueOf(arg); if (command.equalsIgnoreCase(\"start\")) &#123; show(); &#125; else if (command.equalsIgnoreCase(\"shutdown\")) &#123; close(); &#125; else &#123; System.out.println(\"屏幕保持不变！\"); &#125; &#125;&#125;class SystemImpl implements Observer &#123; public void work() &#123; System.out.println(\"系统开始工作！\"); &#125; public void shutdown() &#123; System.out.println(\"系统关闭！\"); &#125; @Override public void update(Observable o, Object arg) &#123; String command = String.valueOf(arg); if (command.equalsIgnoreCase(\"start\")) &#123; work(); &#125; else if (command.equalsIgnoreCase(\"shutdown\")) &#123; shutdown(); &#125; else &#123; System.out.println(\"系统不认识这个命令！\"); &#125; &#125;&#125;// 被观察者interface Keyboard &#123; void press(String command);&#125;class KeyboardImpl extends Observable implements Keyboard &#123; public KeyboardImpl() &#123; super.addObserver(new ScreenImpl()); super.addObserver(new SystemImpl()); &#125; @Override public void press(String command) &#123; System.out.println(\"按下一个命令:\" + command); super.setChanged(); super.notifyObservers(command); &#125;&#125;// 高层模块class Client &#123; public static void main(String[] args) &#123; Keyboard keyboard = new KeyboardImpl(); keyboard.press(\"start\"); keyboard.press(\"xxxxx\"); keyboard.press(\"shutdown\"); &#125;&#125; 备忘录模式 Memento提供一种程序数据的备份方法。包含以下角色： Originator 发起人：记录当前时刻的内部状态，负责定义哪些属于备份范围的状态，负责创建和恢复备忘录数据。 Memento 备忘录：存储 Originator 对象的内部状态，在需要的时候提供发起人需要的内部状态。 Caretaker 备忘录管理员：管理、保存、提供备忘录。 类图 使用场景 需要保存和恢复数据的相关状态场景。 提供一个可回滚 rollback 的操作，比如 word 中的 CTRL+Z 组合键，浏览器中的后退按钮，文件管理器上的 backspace 键等。 需要监控的副本场景。例如要监控一个对象的属性，但监控不应该作为系统的主业务来调用，它只是边缘应用，即使出现监控不准、错误报警也影响不大，因此一般的做法是备份一个主线程中的对象，然后由分析程序来分析。 数据库连接如 JDBC 驱动的事务管理就是用的备忘录模式。 注意事项 备忘录的生命周期 备忘录创建出来就要在 “最近” 的代码中使用，要主动管理它的生命周期，建立就要使用，不需要就要立刻删除其引用，等待 gc 回收。 备忘录的性能 不要在频繁建立备份的场景中使用备忘录模式（比如一个 for 循环中），原因有二：1. 控制不了备忘录建立的对象数量；2. 打对象的建立比较消耗资源，需考虑系统性能。 扩展 clone 方式的备忘录（代码演示） 适用于较简单的场景，要避免与其他的对象产生严重的耦合关系。 该方式把状态保留在了发起人内部，更方便。原因在于 java 的诞生比提出设计模式略晚。 多状态的备忘录模式（代码演示） 对象不可能只有一个状态，一个 javabean 存在多个属性。对象全状态备份方案有多种处理方式，比如使用 clone、数据技术 DTO 回写临时表、使用 BeanUtils 类等。 多备份的备忘录（代码演示） 实现多备份的检查点 Check Point 设计思路：修改备忘录的容器为 map 类型。注意内存一出问题，设计时要严格限定备忘录的创建，增加 map 的上限。 设置备份无法修改，保证备份数据纯洁（代码演示） 使用内部类，设置为 private 。采用双接口设计：一个是业务的正常接口（宽接口），必要的业务逻辑；另一个是空接口（窄接口），什么方法都没有，目的是提供给子系统外的模块访问，比如容器对象，没有提供任何操纵数据的方法，相对比较安全。 代码演示 标准备忘录 1234567891011121314151617181920212223242526272829303132333435363738// 发起人@Dataclass Originator &#123; // 内部状态 private String state = \"初始状态\"; // 创建备忘录 public Memento createMemento() &#123; return new Memento(this.state); &#125; // 恢复备忘录 public void restoreMemento(Memento memento) &#123; this.setState(memento.getState()); &#125;&#125;// 备忘录@Data@AllArgsConstructorclass Memento &#123; // 发起人的内部状态 private String state = \"\";&#125;// 备忘录管理员@Dataclass Caretaker &#123; private Memento memento;&#125;class Client1 &#123; public static void main(String[] args) &#123; Originator originator = new Originator(); Caretaker caretaker = new Caretaker(); // 创建备忘录 caretaker.setMemento(originator.createMemento()); originator.setState(\"改变了状态\"); System.out.println(\"当前发起人的状态是：\" + originator.getState()); // 恢复备忘录 originator.restoreMemento(caretaker.getMemento()); System.out.println(\"恢复后发起人的状态是：\" + originator.getState()); &#125;&#125; clone 方式备忘录 123456789101112131415161718192021222324252627282930313233@Dataclass Originator2 implements Cloneable &#123; private Originator2 backup; private String state = \"初始状态\"; public void createMemento() throws CloneNotSupportedException &#123; backup = this.clone(); &#125; public void restoreMemento(Originator2 originator2) throws NoSuchFieldException &#123; if (backup != null) &#123; this.setState(backup.getState()); &#125; else &#123; throw new RuntimeException(\"备份为null\"); &#125; &#125; @Override protected Originator2 clone() throws CloneNotSupportedException &#123; return (Originator2) super.clone(); &#125;&#125;class Client2 &#123; public static void main(String[] args) throws CloneNotSupportedException &#123; Originator2 originator2 = new Originator2(); originator2.createMemento(); originator2.setState(\"修改了状态\"); System.out.println(\"修改后的状态： \" + originator2.getState()); originator2.setState(originator2.getBackup().getState()); System.out.println(\"恢复后的状态： \" + originator2.getState()); &#125;&#125; 多状态备忘录 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586@Dataclass Originator3 &#123; private String state1 = \"初始状态111\"; private String state2 = \"初始状态222\"; private String state3 = \"初始状态333\"; public Memento3 createMemento() &#123; return new Memento3(BeanUtils.backupProp(this)); &#125; public void restoreMemento(Memento3 memento3) &#123; BeanUtils.restoreProp(this, memento3.getStateMap()); &#125; @Override public String toString() &#123; final StringBuilder sb = new StringBuilder(\"Originator3&#123;\"); sb.append(\"state1='\").append(state1).append('\\''); sb.append(\", state2='\").append(state2).append('\\''); sb.append(\", state3='\").append(state3).append('\\''); sb.append('&#125;'); return sb.toString(); &#125;&#125;@Data@AllArgsConstructorclass Memento3 &#123; private Map&lt;String, Object&gt; stateMap;&#125;// 工具类class BeanUtils &#123; public static Map&lt;String, Object&gt; backupProp(Object source) &#123; Map&lt;String, Object&gt; stateMap = new HashMap&lt;&gt;(); try &#123; // 获得 bean 信息 BeanInfo beanInfo = Introspector.getBeanInfo(source.getClass()); // 属性信息 PropertyDescriptor[] descriptors = beanInfo.getPropertyDescriptors(); // 遍历所有属性 for (PropertyDescriptor descriptor : descriptors) &#123; // 属性名 String fieldName = descriptor.getName(); // getter方法 Method getter = descriptor.getReadMethod(); // 属性值 Object fieldValue = getter.invoke(source); if (!\"class\".equalsIgnoreCase(fieldName)) &#123; stateMap.put(fieldName, fieldValue); &#125; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return stateMap; &#125; public static void restoreProp(Object target, Map&lt;String, Object&gt; propMap) &#123; try &#123; BeanInfo beanInfo = Introspector.getBeanInfo(target.getClass()); PropertyDescriptor[] descriptors = beanInfo.getPropertyDescriptors(); for (PropertyDescriptor descriptor : descriptors) &#123; String fieldName = descriptor.getName(); if (propMap.containsKey(fieldName)) &#123; Method setter = descriptor.getWriteMethod(); setter.invoke(target, propMap.get(fieldName)); &#125; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125;class Client3 &#123; public static void main(String[] args) &#123; Originator3 originator3 = new Originator3(); Memento3 memento3 = originator3.createMemento(); originator3.setState1(\"变了1\"); originator3.setState2(\"变了2\"); originator3.setState3(\"变了3\"); System.out.println(originator3.toString()); originator3.restoreMemento(memento3); System.out.println(originator3.toString()); &#125;&#125; 多备份备忘录 123456789101112131415161718192021222324252627282930313233343536373839404142@Dataclass Originator4 &#123; private String state = \"初始状态\"; public Memento4 createMemento() &#123; return new Memento4(this.state); &#125; public void restoreMemento(Memento4 memento4) &#123; this.state = memento4.getState(); &#125;&#125;@Data@AllArgsConstructorclass Memento4 &#123; private String state;&#125;class Caretaker4 &#123; // 容纳多版本备忘录的容器 private Map&lt;String, Memento4&gt; memMap = new HashMap&lt;&gt;(); public Memento4 getMemento(String key) &#123; return this.memMap.get(key); &#125; public void setMemento(String key, Memento4 memento4) &#123; this.memMap.put(key, memento4); &#125;&#125;class Client &#123; public static void main(String[] args) &#123; Originator4 originator4 = new Originator4(); Caretaker4 caretaker4 = new Caretaker4(); Memento4 memento4 = originator4.createMemento(); memento4.setState(\"100状态\"); caretaker4.setMemento(\"100\", memento4); caretaker4.setMemento(\"200\", originator4.createMemento()); originator4.setState(\"发起人拥有了新状态\"); System.out.println(\"此时发起人的状态：\" + originator4.getState()); originator4.restoreMemento(caretaker4.getMemento(\"100\")); System.out.println(\"恢复100后的状态:\" + originator4.getState()); &#125;&#125; 双接口设计备忘录，防修改 123456789101112131415161718192021222324252627282930313233343536373839404142@Dataclass Originator5 &#123; private String state = \"初始状态\"; public IMemento createMemento() &#123; return new Memento5(this.state); &#125; public void restoreMemento(IMemento memento) &#123; this.setState(memento.getState()); &#125; @Data @AllArgsConstructor private class Memento5 implements IMemento &#123; private String state; &#125;&#125;// 窄接口，提供外部访问interface IMemento &#123; String getState();&#125;@Dataclass Caretaker5 &#123; private IMemento iMemento;&#125;class Client5 &#123; public static void main(String[] args) &#123; Originator5 originator5 = new Originator5(); IMemento memento = originator5.createMemento(); Caretaker5 caretaker5 = new Caretaker5(); caretaker5.setIMemento(memento); originator5.setState(\"修改了状态\"); System.out.println(\"当前 originator 的状态：\" + originator5.getState()); originator5.restoreMemento(caretaker5.getIMemento()); System.out.println(\"执行恢复后的状态：\" + originator5.getState()); &#125;&#125; 访问者模式 Visitor将多种对象的操作交给访问者处理，避免对象和处理各自变化产生的耦合，在单一职责原则基础上实现良好的扩展性。主要包含以下角色： Visitor 抽象访问者：抽象类或者接口，声明访问者可以访问哪些元素，具体到程序中就是 visit 方法的参数定义哪些对象可以被访问。 ConcreteVisitor 具体访问者：访问者访问一个类后具体要做的事。 Element 抽象元素：接口或者抽象类，声明接受哪一类访问者访问，程序中通过 accept 方法参数定义。 ConcreteElement 具体元素：实现 accept 方法，通常是 visitor.visit(this)，已称为固定写法。 ObjectStructure 结构对象：元素产生者，一般容纳在多个不同类、不同接口的容器，如 List、Set、Map 等，在项目中，一般很少抽象出这个角色。 类图 使用场景 一个对象结果包含很多类对象，它们有不同的接口，需要对这些对象实施一些依赖于其具体类的操作，迭代器模式已经不能胜任的情况。 需要对一个对象结果中的对象进行多种不相关操作，同时想避免这些操作 “污染” 这些对象的类的情况。 总结来说就是，业务规则要求遍历多个不同的对象。 迭代器模式只能访问同类或同接口的数据（当然用 instance of 可以访问所有数据），而访问者模式时对迭代器模式的扩充可以遍历不同的对象，针对不同的访问对象执行不同的操作。 访问者模式还可以用来充当拦截器（Interceptor）角色。 特别适用于大规模重构项目，集中规整。在一个阶段需求已经非常清晰，原系统功能点也已经明确，通过访问者模式可以很容易把一些功能进行梳理，达到最终目的——功能集中化，如一个统一的报表运算、UI展现等。还可以与其他模式混编建立一套自己的过滤器或者拦截器。（参考混编模式） 优点 符合单一职责原则 具体元素角色 Employee（抽象类的两个子类）负责数据的加载，而 Visitor 类负责报表展现，两个不同的职责明确分离，各自变化。 优秀的扩展性 职责分离，方便继续增加对数据的操作。直接在 Visitor 中增加一个方法，传递数据后进行处理即可。 灵活性非常高 比如统计所有员工的工资，员工、部门经理、总经理都有各自的系数，通过遍历循环相加不是个好办法。这时可以采用访问者模式，将数据交给访问者计算。 缺点 具体元素对访问者公布细节，违背迪米特法则 访问者要访问一个类就必然要这个类公布需要的方法和数据，这就是说访问者关注了其他类的内部细节。 具体元素变更比较困难 具体元素角色的增加、删除、修改都比较难。比如要想增删一个成员变量，Visitor 就得做修改。 违背依赖倒置原则 访问者依赖的是具体元素，而不是抽象元素。在面向对象的编程中，抛弃对接口的依赖，直接依赖实现类，扩展会比较难。 扩展 统计功能（代码演示） 金融类企业常用汇总和报表功能，比如统计工资总额，不建议采用数据库存储过程，采用访问者模式，在 IVisitor 中增加 getTotalSalary 方法，实现类实现即可。 多个访问者（代码演示） 比如展示表、汇总表，同一堆数据两种处理方式，从程序上看，一个类就有2个不同的访问者。 双分派（代码演示） 一个演员可以扮演很多角色，系统要适应这种变化，也就是根据演员、角色两个对象类型，完成不同操作任务，这时就需要使用访问者模式。 通过调用者实际类型+方法参数中的类型才能确定方法版本时，这种分派称作多分派。只依据调用者和方法参数，叫做单分派。 双分派 double dispatch 意味着得到执行的操作由请求种类和两个接收者类型决定，属于多分派的一个特例。java 是一个支持双分派的单分派语言。 延伸阅读：java方法调用之单分派与多分派 java 静态、动态绑定依据重载 overload 和覆写 overide 实现。重载在编译器决定调用哪个方法，它根据表面类型决定方法调用，这是静态绑定；而执行该方法是由实际类型决定的，这是动态绑定。 定义语言分派时一般指语言动态运行时的分派方式，java 在动态运行时就是根据调用者最终类型来区分要方法调用的方法的，所以说 java 是单分派语言。然而 java 在编译时是根据调用者本身类型和方法参数共同确定调用方法的，所以是静态多分派。 代码演示 统计功能 以制作公司员工以及管理报表、计算工资总额为例。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103interface IVisitor1 &#123; void visit(CommonEmployee commonEmployee); void visit(Manager manager); int getTotalSalary();&#125;class Visitor1 implements IVisitor1 &#123; private int commonEmplayTotalSalary = 0; private int managerTotalSalary = 0; private final static int COMMONEMPLOYEE_COEFICIENT = 2; private final static int MANAGER_COEFICIENT = 5; @Override public int getTotalSalary() &#123; return commonEmplayTotalSalary + managerTotalSalary; &#125; private int getCommonEmployeeTotalSalary(int salary) &#123; return commonEmplayTotalSalary + salary * COMMONEMPLOYEE_COEFICIENT; &#125; private int getManagerTotalSalary(int salary) &#123; return managerTotalSalary + salary * MANAGER_COEFICIENT; &#125; @Override public void visit(CommonEmployee commonEmployee) &#123; System.out.println(getCommonEmployeeInfo(commonEmployee)); this.commonEmplayTotalSalary = getCommonEmployeeTotalSalary(commonEmployee.getSalary()); &#125; @Override public void visit(Manager manager) &#123; System.out.println(getManagerInfo(manager)); this.managerTotalSalary = getManagerTotalSalary(manager.getSalary()); &#125; private String getCommonEmployeeInfo(CommonEmployee commonEmployee) &#123; return getBasicInfo(commonEmployee) + \"job=\" + commonEmployee.getJob(); &#125; private String getManagerInfo(Manager manager) &#123; return getBasicInfo(manager) + \"performance=\" + manager.getPerformance(); &#125; private String getBasicInfo(Employee employee) &#123; return new StringJoiner(\"\\t\", \"\", \"\\t\\t\") .add(\"name=\" + employee.getName()) .add(\"salary=\" + employee.getSalary()) .toString(); &#125;&#125;@Dataabstract class Employee &#123; private String name; private int salary; public abstract void accept(IVisitor1 visitor);&#125;@Dataclass CommonEmployee extends Employee &#123; private String job; @Override public void accept(IVisitor1 visitor) &#123; visitor.visit(this); &#125;&#125;@Dataclass Manager extends Employee &#123; private String performance; @Override public void accept(IVisitor1 visitor) &#123; visitor.visit(this); &#125;&#125;class Client1 &#123; public static void main(String[] args) &#123; Visitor1 visitor = new Visitor1(); for (Employee employee : mockEmployee()) &#123; employee.accept(visitor); &#125; System.out.println(\"\\n工资总额：\" + visitor.getTotalSalary()); &#125; private static List&lt;Employee&gt; mockEmployee() &#123; List&lt;Employee&gt; employeeList = new ArrayList&lt;&gt;(); CommonEmployee zhangsan = new CommonEmployee(); zhangsan.setName(\"张三\"); zhangsan.setSalary(1800); zhangsan.setJob(\"程序猿\"); CommonEmployee lisi = new CommonEmployee(); lisi.setName(\"李四\"); lisi.setSalary(2000); lisi.setJob(\"产品汪\"); Manager manager = new Manager(); manager.setName(\"主管\"); manager.setSalary(5000); manager.setPerformance(\"马马虎虎\"); employeeList.add(zhangsan); employeeList.add(lisi); employeeList.add(manager); return employeeList; &#125;&#125; 多个访问者 上述例子中，把展示表、汇总表分拆为两个 visitor 接口。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131interface IVisitor2 &#123; void visit(CommonEmployee2 commonEmployee2); void visit(Manager2 manager2);&#125;// 元素类，决定哪些访问者可以访问@Dataabstract class Employee2 &#123; private String name; private int salary; public abstract void accept(IVisitor2 iVisitor2);&#125;@Dataclass CommonEmployee2 extends Employee2 &#123; private String job; @Override public void accept(IVisitor2 iVisitor2) &#123; iVisitor2.visit(this); &#125;&#125;@Dataclass Manager2 extends Employee2 &#123; private String performance; @Override public void accept(IVisitor2 iVisitor2) &#123; iVisitor2.visit(this); &#125;&#125;// 展示表访问者interface IShowVisitor2 extends IVisitor2 &#123; void report();&#125;// 工资统计表访问者interface IStatisticsVisitor2 extends IVisitor2 &#123; void statisticsSalary();&#125;class ShowVisitor2 implements IShowVisitor2 &#123; private Map&lt;String, String&gt; infoMap = new HashMap&lt;&gt;(); @Override public void visit(CommonEmployee2 commonEmployee2) &#123; infoMap.put(commonEmployee2.getName(), getCommonEmployeeInfo(commonEmployee2)); &#125; @Override public void visit(Manager2 manager2) &#123; infoMap.put(manager2.getName(), getManagerInfo(manager2)); &#125; @Override public void report() &#123; for (Map.Entry&lt;String, String&gt; entry : infoMap.entrySet()) &#123; System.out.println(entry.getValue()); &#125; &#125; private String getCommonEmployeeInfo(CommonEmployee2 commonEmployee2) &#123; return getBasicInfo(commonEmployee2) + \"job=\" + commonEmployee2.getJob(); &#125; private String getManagerInfo(Manager2 manager2) &#123; return getBasicInfo(manager2) + \"performance=\" + manager2.getPerformance(); &#125; private String getBasicInfo(Employee2 employee2) &#123; return new StringJoiner(\"\\t\", \"\", \"\\t\\t\") .add(\"name=\" + employee2.getName()) .add(\"salary=\" + employee2.getSalary()) .toString(); &#125;&#125;class StatisticsVisitor2 implements IStatisticsVisitor2 &#123; private int commonEmplayTotalSalary = 0; private int managerTotalSalary = 0; private final static int COMMONEMPLOYEE_COEFICIENT = 2; private final static int MANAGER_COEFICIENT = 5; @Override public void visit(CommonEmployee2 commonEmployee2) &#123; this.commonEmplayTotalSalary += commonEmployee2.getSalary() * COMMONEMPLOYEE_COEFICIENT; &#125; @Override public void visit(Manager2 manager2) &#123; this.managerTotalSalary += manager2.getSalary() * MANAGER_COEFICIENT; &#125; @Override public void statisticsSalary() &#123; System.out.println(\"工资总额：\" + (this.commonEmplayTotalSalary + this.managerTotalSalary)); &#125;&#125;class Client2 &#123; public static void main(String[] args) &#123; IShowVisitor2 showVisitor2 = new ShowVisitor2(); IStatisticsVisitor2 statisticsVisitor2 = new StatisticsVisitor2(); for (Employee2 employee : mockEmployee()) &#123; employee.accept(showVisitor2); employee.accept(statisticsVisitor2); &#125; showVisitor2.report(); statisticsVisitor2.statisticsSalary(); &#125; private static List&lt;Employee2&gt; mockEmployee() &#123; List&lt;Employee2&gt; employeeList = new ArrayList&lt;&gt;(); CommonEmployee2 zhangsan = new CommonEmployee2(); zhangsan.setName(\"张三\"); zhangsan.setSalary(1800); zhangsan.setJob(\"程序猿\"); CommonEmployee2 lisi = new CommonEmployee2(); lisi.setName(\"李四\"); lisi.setSalary(2000); lisi.setJob(\"产品汪\"); Manager2 manager = new Manager2(); manager.setName(\"主管\"); manager.setSalary(5000); manager.setPerformance(\"绩效很高\"); employeeList.add(zhangsan); employeeList.add(lisi); employeeList.add(manager); return employeeList; &#125;&#125; 双分派 以演员演电影为例，一个演员可以演多个角色，系统要根据演员、角色两个类型共同决定完成什么任务。通过访问者模式解决演员、角色变化的问题，由请求种类和两个接收者类型决定怎么执行，实现双分派。 12345678910111213141516171819202122232425262728293031interface Role &#123;&#125;class KungFuRole implements Role &#123;&#125;class ComedyRole implements Role &#123;&#125;abstract class AbstractActor &#123; public void act(Role role) &#123; System.out.println(\"演员可以扮演任何角色\"); &#125; // 重载 public void act(KungFuRole kungFuRole) &#123; System.out.println(\"演员可以演功夫角色\"); &#125;&#125;class Actor1 extends AbstractActor &#123; // 重写 @Override public void act(KungFuRole kungFuRole) &#123; System.out.println(\"这个类的演员都会功夫，拍打片非常合适！\"); &#125;&#125;class Actor2 extends AbstractActor &#123; @Override public void act(KungFuRole kungFuRole) &#123; System.out.println(\"这个类型的演员不太擅长演功夫角色，需要指导\"); &#125;&#125;class Client4 &#123; public static void main(String[] args) &#123; Role role = new KungFuRole(); AbstractActor actor = new Actor2(); // 执行一下两个方法就会发现，重载在编译期就决定了要调用哪个方法，虽然 actor.act(role) 用的子类构造。 // 根据 role 的表面类型调用 act(Role role) 方法，这是静态绑定。而 Actor 的执行方法 act 则是由实际类型决定的，这是动态绑定。 actor.act(role); actor.act(new KungFuRole()); &#125;&#125; 修改后： 12345678910111213141516171819202122232425262728293031323334353637interface RoleTwo &#123; void accept(AbstractActorTwo actor);&#125;class KungFuRoleTwo implements RoleTwo &#123; @Override public void accept(AbstractActorTwo actor) &#123; actor.act(this); &#125;&#125;class ComedyRoleTwo implements RoleTwo &#123; @Override public void accept(AbstractActorTwo actor) &#123; actor.act(this); &#125;&#125;abstract class AbstractActorTwo &#123; public void act(RoleTwo role) &#123; System.out.println(\"演员可以扮演任何角色\"); &#125; public void act(KungFuRoleTwo kungFuRole) &#123; System.out.println(\"演员可以演功夫角色\"); &#125;&#125;class ActorTwo1 extends AbstractActorTwo &#123; @Override public void act(KungFuRoleTwo kungFuRole) &#123; System.out.println(\"这个类的演员都会功夫，拍打片非常合适！\"); &#125;&#125;class ActorTwo2 extends AbstractActorTwo &#123; @Override public void act(KungFuRoleTwo kungFuRole) &#123; System.out.println(\"这个类型的演员不太擅长演功夫角色，需要指导\"); &#125;&#125;class ClientTwo &#123; public static void main(String[] args) &#123; RoleTwo roleTwo = new KungFuRoleTwo(); AbstractActorTwo actorTwo = new ActorTwo2(); roleTwo.accept(actorTwo); roleTwo.accept(new ActorTwo2()); &#125;&#125; 状态模式 State核心是封装，状态变更引起行为变更，从外部看起来就像这个对象对应的类发生了改变，包含三个角色： State 抽象状态角色：接口或抽象类，负责对象状态定义，并且封装环境角色以实现状态切换。 ConcreteState 具体状态角色：每一个具体状态必须完成2个职责，本状态的行为管理和趋向状态处理，通俗而言就是本状态下要做的事以及本状态如何过度到其他状态。 Context 环境角色：定义客户需要的接口，并负责具体状态切换。 类图 使用场景 行为随状态改变而改变的场景 这是状态模式的根本出发点，例如权限设计，人员的状态不同即使执行相同的行为结果也可能不同。 条件、分支判断语句的替代者 避免使用 switch、if 的地方可以考虑，通过扩展子类实现条件的判断处理。 优点 结构清晰 避免过多 switch..case… 或 if…else… 语句的使用，避免程序复杂性，提升可维护性。 遵循开闭原则和单一职责原则 每一个状态都是一个子类，想增加或修改状态只需要增加或修改子类即可。 封装性非常好 状态变换放到类内部实现，外部的调用不需要知道类内如何实现状态和行为的变换。 缺点 子类可能会膨胀 可在数据库中建立一个状态表，然后根据状态执行相应的操作。 注意事项 行为受状态约束时可使用状态模式，对象的状态最好不要超过5个。 扩展 状态模式+建造者模式 状态自由切换种类太多，可使用建造者模式把已有的几种状态按照一定顺序进行封装。 状态机 State Machine Context 类的升级版，工作流开发中常用。 代码演示123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354abstract class State &#123; @Setter protected Context context; abstract void handleState1(); abstract void handleState2();&#125;class ConcreteState1 extends State &#123; @Override void handleState1() &#123; System.out.println(\"当前状态：\" + super.context.getCurrentState() + \"，开始执行状态1的动作\"); &#125; @Override void handleState2() &#123; super.context.setCurrentState(Context.STATE2); super.context.handleState2(); &#125;&#125;class ConcreteState2 extends State &#123; @Override void handleState1() &#123; super.context.setCurrentState(Context.STATE1); super.context.handleState1(); &#125; @Override void handleState2() &#123; System.out.println(\"当前状态：\" + super.context.getCurrentState()+ \"，开始执行状态2的动作\"); &#125;&#125;class Context &#123; public final static State STATE1 = new ConcreteState1(); public final static State STATE2 = new ConcreteState2(); @Getter private State currentState; public void setCurrentState(State currentState) &#123; this.currentState = currentState; this.currentState.setContext(this); &#125; public void handleState1() &#123; this.currentState.handleState1(); &#125; public void handleState2() &#123; this.currentState.handleState2(); &#125;&#125;class Client &#123; public static void main(String[] args) &#123; Context context = new Context(); context.setCurrentState(Context.STATE1); context.handleState2(); context.handleState1(); &#125;&#125; 解释器模式 Interpreter按照规定语法进行解析的模式。这个模式主要理解概念和理念，实际应用较少。以公式 a+b+c-d 为例，先介绍几个基本概念： 运算元素：也叫做终结符号。指 a、b、c 等符号，需要具体赋值的对象。这些元素除了需要赋值外，不需要做任何处理，所有运算元素都对应一个具体的业务参数，是语法中最小的单元逻辑，不可再拆分。 运算符号：也叫非终结符号。指 +、- 等符号，需要编写算法进行处理，每个运算符号对咬对应处理单元，否则公式无法运行。 两类元素的共同点是都要被解析，不同点是所有的运算元素具有相同的功能，可以用一个类表示，而运算符号则需要分别进行解释，例如加法需要加法解析器，减法需要减法解析器。 解析器模式包含以下4个角色： AbstractExpression 抽象解释器：具体的解释任务由各实现类完成，具体解释器分别由 TerminalExpression 和 NonterminalExpression 完成。 TerminalExpression 终结符表达式：实现与文法中的元素相关联的解释操作，通常一个解释器模式中只有一个终结符表达式，但有多个实例，对应不同的终结符。 NonterminalExpression 非终结符表达式：文法中的每条规则对应于一个非终结表达式，根据逻辑的复杂程度而增加，原则上每个文法规则都对应一个非终结符表达式。 Context 环境角色：例如用 HashMap 代替。 类图 使用场景 重复发生的问题 例如多个应用服务器每天产生大量日志，需要对日志文件进行分析处理，各服务器的日志格式不同但数据要素相同，按照解释器的说法就是终结符表达式都是相同的，但是非终结符表达式则需要制定。 一个简单语法需要解释的场景 对于非终结表达式，文法规则越多，复杂度越高，而且类间还要进行递归调用，需要极大耐心和信心去排查问题。因此解释器一般用来解析比较标准的字符集，例如 SQL 语法分析，不过该部分逐渐被专用工具代替。 某些特定的商业环境 现在模型运算的例子很多，目前很多商业机构已经能够提供出大量的数据进行分析。 优点 扩展性良好 解释器是一个简单语法分析工具，修改语法规则只要修改相应的非终结符表达式就可以了，若扩展语法，则只需要增加非终结符类就可以。 缺点 会引起类膨胀 每个语法都要产生一个非终结符表达式，语法规则比较复杂时，可能产生大量的类文件，为维护带来非常多得麻烦。 采用递归调用方法 每个非终结符表达式只关心与自己有关的表达式，每个表达式需要知道最终的结果，必须一层层剥茧，不论面向过程还是面向对象的语言，递归都是在必要条件下使用的，导致调试非常复杂。想想看，如果要排查一个语法错误，还需要一个个断点调试下去，知道最小的语法单元。 效率问题 使用了大量的循环和递归。在用于解析复杂、冗长的语法时，效率是难以忍受的。 注意事项 尽量不要在重要的模块中使用解释器模式，否则维护会是一个大问题。在项目中可以使用 shell、JRuby、Groovy 等脚本语言来代替解释器模式，弥补 java 编译型语言的不足。比如在银行分析型项目中采用 JRuby 进行运算处理，避免使用解释器模式的四则匀速，保证效率和性能。 解释器模式在实际的系统开发中使用较少，一般在大中型的框架型项目能够找到它的身影，如一些数据分析工具、报表设计工具、科学计算工具等。若确实遇到 “一种特定类型的问题发生的频率足够高” 的情况，准备使用解释器模式时，可以考虑 Expression4J、MESP(Math Expression String Parser)、Jep 等开源的解析工具包，尽量避免自己从头编写解释器。 代码演示 通用源码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/** * 环境角色，例如存放 hashmap */class Context &#123;&#125;/** * 抽象表达式是生成语法集合（也叫语法树）的关键，每个语法集合完成指定语法解析任务，通过递归调用，最终由最小的语法单元进行解析完成 */abstract class Expression &#123; public abstract Object interpreter(Context ctx);&#125;/** * 终结符表达式主要处理场景元素和数据的转换。终结符表达式不能再参与比自己更小的文法运算。 */class TerminalExpression extends Expression &#123; // 通常终结符表达式只有一个，但是有多个对象 @Override public Object interpreter(Context ctx) &#123; return null; &#125;&#125;/** * 每个非终结符表达式都代表了一个文法规则，并且每个文法规则都只关心自己周边的文法规则的结果， * 因此产生了每个非终结表达式调用自己周边的非终结符表达式，然后最终、最小的文法规则就是终结符表达式。 * */class NonterminalExpression extends Expression &#123; // 每个非终结符表达式都会对其他表达式产生依赖 public NonterminalExpression(Expression... expressions) &#123; &#125; @Override public Object interpreter(Context ctx) &#123; return null; &#125;&#125;/** * 封装类，传递进来一个规范语法文件，解析器分析后产生结果并返回，避免了调用者与语法解析器的耦合关系 */class Client &#123; public static void main(String[] args) &#123; Context context = new Context(); // 通常定义一个语法容器，容纳一个具体的表达式，例如 ListArray、LinkedList、Stack 等类型 Stack&lt;Expression&gt; stack = null; for (; ; ) &#123; // 进行语法判断，并产生递归调用 break; &#125; // 产生一个完整的语法树，由多个具体的语法分析进行解析 Expression exp = stack.pop(); exp.interpreter(context); &#125;&#125; 案例 输入一个模型公式（例如加减运算），然后输入模型中的参数，运算出结果。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120// 抽象表达式abstract class AbstractExpression &#123; // 解析公式和数值，其中 key 是公式中的参数，value 是具体的数字 abstract int interpreter(HashMap&lt;String, Integer&gt; var);&#125;// 变量解析器@AllArgsConstructorclass VarExpression extends AbstractExpression &#123; private String key; @Override int interpreter(HashMap&lt;String, Integer&gt; var) &#123; return var.get(this.key); &#125;&#125;// 抽象运算符号解析器@AllArgsConstructorabstract class SymbolExpression extends AbstractExpression &#123; // 所有的解析公式都应只关心自己左右两个表达式的结果 protected AbstractExpression left; protected AbstractExpression right;&#125;// 加法解析器class AddExpression extends SymbolExpression &#123; public AddExpression(AbstractExpression left, AbstractExpression right) &#123; super(left, right); &#125; //把左右两个表达式运算的结果相加 @Override int interpreter(HashMap&lt;String, Integer&gt; var) &#123; return super.left.interpreter(var) + super.right.interpreter(var); &#125;&#125;// 减法解析器class SubExpression extends SymbolExpression &#123; public SubExpression(AbstractExpression left, AbstractExpression right) &#123; super(left, right); &#125; @Override int interpreter(HashMap&lt;String, Integer&gt; var) &#123; return super.left.interpreter(var) - super.right.interpreter(var); &#125;&#125;// 解析器封装类class Calculator &#123; // 定义表达式 private AbstractExpression expression; // 构造函数传参，并解析 public Calculator(String expStr) &#123; // 定义一个栈，安排运算的先后顺序 Stack&lt;AbstractExpression&gt; stack = new Stack&lt;&gt;(); // 表达式拆分为字符数组 char[] charArray = expStr.toCharArray(); // 运算 AbstractExpression left = null; AbstractExpression right = null; for (int i = 0; i &lt; charArray.length; i++) &#123; switch (charArray[i]) &#123; case '+': left = stack.pop(); right = new VarExpression(String.valueOf(charArray[++i])); stack.push(new AddExpression(left, right)); break; case '-': left = stack.pop(); right = new VarExpression(String.valueOf(charArray[++i])); stack.push(new SubExpression(left, right)); break; default: stack.push(new VarExpression(String.valueOf(charArray[i]))); &#125; &#125; this.expression = stack.pop(); &#125; // 开始运算 public int run(HashMap&lt;String, Integer&gt; var) &#123; return this.expression.interpreter(var); &#125;&#125;// 客户模拟类class ClientCase &#123; public static void main(String[] args) throws IOException &#123; // 输入表达式 String expStr = getExpStr(); // 获得值映射 HashMap&lt;String, Integer&gt; var = getValue(expStr); Calculator calculator = new Calculator(expStr); int result = calculator.run(var); System.out.println(\"执行结果是：\" + result); &#125; private static String getExpStr() throws IOException &#123; System.out.println(\"请输入表达式：\"); InputStream in = System.in; InputStreamReader inputStreamReader = new InputStreamReader(in); BufferedReader bufferedReader = new BufferedReader(inputStreamReader); return bufferedReader.readLine(); &#125; private static HashMap&lt;String, Integer&gt; getValue(String expStr) throws IOException &#123; HashMap&lt;String, Integer&gt; map = new HashMap&lt;&gt;(); // 解析有几个参数要传递 for (char c : expStr.toCharArray()) &#123; if (c != '+' &amp;&amp; c != '-') &#123; // 解决重复参数的问题 if (!map.containsKey(String.valueOf(c))) &#123; System.out.println(\"请输入\" + c + \"的值：\"); String in = (new BufferedReader(new InputStreamReader(System.in))).readLine(); map.put(String.valueOf(c), Integer.valueOf(in)); &#125; &#125; &#125; return map; &#125;&#125;","categories":[],"tags":[{"name":"book","slug":"book","permalink":"https://melodyplayer.github.io/blog/tags/book/"}]},{"title":"《设计模式之禅》——行为型（上）","slug":"《设计模式之禅》——行为型（上）","date":"2019-12-15T07:23:43.000Z","updated":"2020-02-29T17:21:10.914Z","comments":true,"path":"blog/2019/1215:《设计模式之禅》——行为型（上）/","link":"","permalink":"https://melodyplayer.github.io/blog/2019/1215:《设计模式之禅》——行为型（上）/","excerpt":"11种行为型模式（上）：模板、中介、命令、责任链、策略、迭代器","text":"11种行为型模式（上）：模板、中介、命令、责任链、策略、迭代器 模板方法模式 Template在模板方法中按照一定规则和顺序调用基本方法，将一些基本方法延迟到子类实现，抽象模板类中方法分为两种： 基本方法：由子类实现，在模板方法被调用。 模板方法：一个框架，实现对基本方法的调用，完成固定逻辑。为防止恶意操作，一般给模板方法加上 final 关键字，避免被覆写。 类图 使用场景 多个子类有公有的方法，并且逻辑基本相同。 重要、复杂的算法，可以把核心算法设计为模板方法，周边的相关细节功能则由各个子类实现。 重构时，模板方法模式经常使用，把相同代码抽取到父类，然后通过钩子函数（见扩展）约束其行为。 优点 封装不变部分，扩展可变部分。可通过继承来进行扩展。 提取公共部分代码，便于维护。 行为由父类控制，子类实现。符合开闭原则。 缺点 一般的设计习惯，抽象类负责声明最抽象、最一般的事物属性和方法，实现类完成具体的事物属性和方法。但是模板方法模式却颠倒了，抽象类定义的部分抽象方法由子类实现，导致子类执行的结果影响了父类的结果，也就是子类对父类产生了影响，在复杂项目中会带来代码阅读难度。 注意事项 父类调用子类的其他三种方式，但不建议父类调用子类！此时考虑使用模板方法模式。 子类传递到父类的有参构造中，然后调用。 使用反射的方式调用。 父类调用子类的静态方法。 为防止恶意操作，一般给模板方法加上 final 关键字，避免被覆写。 扩展 外界通过钩子方法影响模板执行结果 代码演示1234567891011121314151617181920212223242526272829303132333435363738394041424344abstract class Car &#123; // 基本方法 protected void start() &#123; System.out.println(\"打火启动\"); &#125; protected abstract void drive(); protected void alarm() &#123; System.out.println(\"鸣笛~~~\"); &#125; protected void stop() &#123; System.out.println(\"刹车停车\"); &#125; // 模板方法 public final void run() &#123; System.out.println(this.getClass().getSimpleName() + \"开动！------------\"); start(); drive(); if (isAlarm()) &#123; alarm(); &#125; stop(); &#125; // 钩子函数 protected boolean isAlarm() &#123; return true; &#125;&#125;class Model1 extends Car &#123; @Override protected void drive() &#123; System.out.println(\"前轮驱动\"); &#125;&#125;class Model2 extends Car &#123; private boolean isAlarm; public Model2(boolean isAlarm) &#123; this.isAlarm = isAlarm; &#125; @Override protected void drive() &#123; System.out.println(\"后轮驱动\"); &#125; @Override protected boolean isAlarm() &#123; return isAlarm; &#125;&#125;class Client &#123; public static void main(String[] args) &#123; Car m1 = new Model1(); m1.run(); Car m2 = new Model2(false); m2.run(); &#125;&#125; 中介者模式 Mediator也叫调停者模式。每个类只负责处理自己的行为，与自己无关的交给中介者处理，包含以下几个部分： Mediator 抽象中介者 抽象中介者角色定义统一的接口，用于各同事角色之间的通信。 Concrete Mediator 具体中介者 具体中介者角色通过协调各同事角色实现协作行为，因此它必须依赖各个同事角色。 Colleague 同事类 每个同事角色都知道中介者，而且与其他同事角色通信的时候，一定要通过中介者角色协作。每个同事类行为分为两种：一种是同事本身的行为，比如改变对象本身的状态，处理自己的行为等，这叫自发行为（Self-Method），与其他同事类或中介者没有任何联系；第二种是必须依赖中介者才能完成的行为，叫做依赖方法（Dep-Method）。 类图 使用场景 N个对象之间紧密耦合的情况，这时一定要考虑使用中介者模式，把蛛网梳理为星型结构。（N &gt; 2） 紧密耦合的标准：在类图中出现了蜘蛛网状结构。 多个对象有依赖关系，但是依赖的行为尚不确定或者有发生改变的可能，此时建议使用中介者模式，降低变更引起的风险扩散。 产品开发。一个明显的例子就是 MVC 框架，把中介者模式应用到产品中，可以提升产品性能和扩展性。但是对于项目开发未必，因为项目是以交付投产为目标，而产品则是以稳定、高效、扩展为宗旨。 实际案例 机场调度中心。调度各个飞机以及其他部门工作人员。 MVC 框架。其中的 controller 前端控制器就是中介者，作用是把 model 业务逻辑 和 view 视图隔离开。 媒体网关。MSN 作为中介者接收张三发的消息，查找李四并发送消息，同时通知张三消息已发送。与此相反的是 IPMsg 飞鸽，直接使用 UDP 广播的方式，每个客户端同时也是服务端。 中介服务。租房中介、出国中介。 优点 减少类间依赖，把原有的一对多依赖变成了一对一。同事类只依赖中介者，减少了依赖，同时也降低了类间的耦合。 缺点 中介者会膨胀较大，逻辑复杂，原本N个对象直接的相互依赖关系转换为中介者和同事类的依赖，同事类越多，中介者逻辑越复杂。 注意事项 中介者模式简单，但很容易被误用，类之间的依赖关系是必然存在的，不能只要看到有多个依赖关系就使用中介者模式，简单的几个对象依赖，如果为了使用模式而加入中介者，必然导致中介者逻辑复杂化而产生膨胀问题。关键点是以多个对象之间紧密耦合作为标准进行判断。 中介者模式很少用到接口或者抽象类，这与依赖倒置原则有冲突。原因在于同事类不是兄弟类，协作完成不同的任务，处理不同的业务，所以不能在抽象类或者接口中严格定义同事类必须具有的方法（这点可以看出继承是高侵入性的）。如果两个对象不能提炼出共性，那就不要刻意去追求两者的抽象，抽象只要定义出模式需要的角色即可。当然如果严格遵守面向接口编程，则需要抽象，这要在实际开发中灵活掌握。 一个中介者抽象类一般只有一个实现者，除非中介者逻辑非常复杂，代码量非常大。 代码演示以进销存系统为例。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138public class mediatorPattern extends AbstractMediator &#123; @Override public void execute(String str, Object... objects) &#123; if (str.equalsIgnoreCase(\"purchase.buy\")) &#123; this.buyComputer((Integer) objects[0]); &#125; else if (str.equalsIgnoreCase(\"sale.sell\")) &#123; this.sellComputer((Integer) objects[0]); &#125; else if (str.equalsIgnoreCase(\"sale.offsell\")) &#123; this.offSell(); &#125; else if (str.equalsIgnoreCase(\"stock.clear\")) &#123; this.clearStock(); &#125; &#125; private void buyComputer(int num) &#123; int saleStatus = super.sale.getSaleStatus(); if (saleStatus &gt; 80) &#123; System.out.println(\"销量不错，采购电脑\" + num + \"台\"); super.stock.increase(num); &#125; else &#123; int buyNum = num / 2; System.out.println(\"销量一般，折半采购电脑\" + buyNum + \"台\"); &#125; &#125; private void sellComputer(int num) &#123; try &#123; super.stock.decrease(num); &#125; catch (Exception e) &#123; System.out.println(\"库存数量不足，需要进货\" + num + \"台\"); super.purchase.buyComputer(num); &#125; &#125; // 打折售卖 private void offSell() &#123; System.out.println(\"折价销售电脑\" + stock.getStockNum() + \"台\"); &#125; // 清仓 private void clearStock() &#123; super.sale.offSale(); super.purchase.refuseBuyComputer(); &#125;&#125;// 抽象中介者abstract class AbstractMediator &#123; protected Purchase purchase = new Purchase(this); protected Sale sale = new Sale(this); protected Stock stock = new Stock(this); // 中介者最重要的事件方法，处理多个对象之间的关系 public abstract void execute(String str, Object... objects);&#125;// 抽象同事类abstract class AbstractColleague &#123; protected AbstractMediator mediator; public AbstractColleague(AbstractMediator mediator) &#123; this.mediator = mediator; &#125;&#125;// 进class Purchase extends AbstractColleague &#123; public Purchase(AbstractMediator mediator) &#123; super(mediator); &#125; public void buyComputer(int num) &#123; super.mediator.execute(\"purchase.buy\", num); &#125; public void refuseBuyComputer() &#123; System.out.println(\"不再采购电脑\"); &#125;&#125;// 销class Sale extends AbstractColleague &#123; public Sale(AbstractMediator mediator) &#123; super(mediator); &#125; // 销售电脑 public void sellComputer(int num) &#123; super.mediator.execute(\"sale.sell\", num); System.out.println(\"销售电脑\" + num + \"台\"); &#125; // 反馈销售情况，0~100变化 public int getSaleStatus() &#123; Random random = new Random(System.currentTimeMillis()); int saleStatus = random.nextInt(100); System.out.println(\"电脑销售状况：\" + saleStatus); return saleStatus; &#125; // 折扣处理 public void offSale() &#123; super.mediator.execute(\"sale.offsell\"); &#125;&#125;// 存class Stock extends AbstractColleague &#123; private static int computerNum = 100; public Stock(AbstractMediator mediator) &#123; super(mediator); &#125; // 增加库存 public void increase(int num) &#123; computerNum += num; System.out.println(\"增加\" + num + \"台电脑后，库存：\" + computerNum); &#125; // 减少库存 public void decrease(int num) throws Exception &#123; if (computerNum &gt;= num) &#123; computerNum -= num; System.out.println(\"减少\" + num + \"台电脑后，库存：\" + computerNum); &#125; else &#123; throw new Exception(\"库存量不足\"); &#125; &#125; // 获取库存数量 public int getStockNum() &#123; return computerNum; &#125; // 清库存 public void clearStock() &#123; System.out.println(\"要清理的库存量：\" + computerNum); super.mediator.execute(\"stock.clear\"); &#125;&#125;class Client &#123; public static void main(String[] args) &#123; AbstractMediator mediator = new mediatorPattern(); System.out.println(\"------------采购员采购电脑------------\"); Purchase purchase = new Purchase(mediator); purchase.buyComputer(10); System.out.println(\"------------销售员销售电脑------------\"); Sale sale = new Sale(mediator); sale.sellComputer(200); System.out.println(\"------------仓库管理员清库处理------------\"); Stock stock = new Stock(mediator); stock.clearStock(); &#125;&#125; 命令模式 Command高内聚模式。把请求方 Invoker 和 执行方 Receiver 分开了，主要角色有： Receiver 接受者：实现类执行具体命令。 Command 命令角色：声明要执行的命令。 Invoker 调用者：接收命令，执行命令。 类图 使用场景 在认为是命令的地方就可以采用。例如 GUI 开发中的一个按钮点击；模拟DOS命令；出发-反馈机制的处理。 优点 类间解耦。调用者与接收者之间没有任何依赖关系，调用者实现功能时只需调用 Command 抽象类的 execute()，不需要了解到底是哪个接收者执行。 可扩展性。Command 的子类非常容易扩展，而调用者 Invoker 和高层次的模块 Client 不产生严重代码耦合。 与其他模式结合。 结合责任链模式。实现命令族解析任务。 结合模板方法模式。减少 Command 子类膨胀问题。 缺点 如果有N个命令，Command 子类就是N个，类膨胀较大。 注意事项 命令模式的 Receiver 在实际应用中一般都会被封装掉（除非非常必要，如撤销处理）。原因是在项目中：约定的优先级最高，每一个命令是对一个或多个 Receiver 的封装，可通过有意义的类名或命令名处理 Command 和 Receiver 的耦合关系（约定），减少高层模块 Client 对低层模块的 Receiver 的依赖关系，提升系统整体稳定性。 扩展 协调多个对象。Command 可封装多个 Reciever 对象，共同完成一项命令。 反悔问题。有两种方式解决： 结合备忘录模式还原最后状态，该方法适合接收者为状态的变更情况，不适合事件处理。 增加新命令，实现事件回滚。例如增加撤销命令。 代码演示以处理文档、图片为例 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879// 定义 receiverabstract class Operator &#123; abstract void add(); abstract void update(); abstract void delete(); public void rollback() &#123; System.out.println(\"默认回滚操作，需要时覆盖\"); &#125;&#125;class TextOperator extends Operator &#123; @Override void add() &#123; System.out.println(\"添加文字\"); &#125; @Override void update() &#123; System.out.println(\"更新文字\"); &#125; @Override void delete() &#123; System.out.println(\"删除文字\"); &#125; @Override public void rollback() &#123; System.out.println(\"撤销文字编辑操作\"); &#125;&#125;class PictureOperator extends Operator &#123; @Override void add() &#123; System.out.println(\"添加图片\"); &#125; @Override void update() &#123; System.out.println(\"修改图片\"); &#125; @Override void delete() &#123; System.out.println(\"删除图片\"); &#125;&#125;// 定义命令abstract class Command &#123; protected TextOperator text = new TextOperator(); protected PictureOperator picture = new PictureOperator(); // 只有一个方法那就是执行，至于怎么执行交给命令实现类 abstract void execute();&#125;class CreateFileCommand extends Command&#123; @Override void execute() &#123; super.text.add(); super.picture.add(); &#125;&#125;class DeleteFileCommand extends Command &#123; @Override void execute() &#123; super.text.delete(); super.picture.delete(); &#125;&#125;class CancelCreateFileCommand extends Command &#123; @Override void execute() &#123; super.text.rollback(); super.picture.rollback(); &#125;&#125;// 需要一个负责人来接收客户发送的命令class Invoker &#123; private Command command; public void setCommand(Command command) &#123; this.command = command; &#125; public void action() &#123; this.command.execute(); &#125;&#125;// 高层模块class Client &#123; public static void main(String[] args) &#123; Invoker invoker = new Invoker(); System.out.println(\"------客户发来新建图文的命令------\"); invoker.setCommand(new CreateFileCommand()); invoker.action(); System.out.println(\"------客户说需要撤销刚才的创建命令------\"); invoker.setCommand(new CancelCreateFileCommand()); invoker.action(); &#125;&#125; 责任链模式 Chain Of Responsibility将处理对象串成一条链，请求沿着链传递，直到有对象处理返回结果为止。 类图 使用场景 需要依次遍历处理对象的情况，请求不关心处理对象都有哪些。 作为补救模式。例如刚开始的项目需求是一个请求一个处理者，但是随着业务的发展，处理者数量和类型有所增加，这时就可以在第一个处理者后面建立一个链来处理请求。 优点 将请求和处理分开，解耦。请求者无需知道请求交给谁去处理，处理者也不用知道请求的全貌。 缺点 可能产生性能问题。链比较长，大量请求从链头遍历到链尾产生性能问题。 调试不便。长链类似递归的方式对调试产生影响。 注意事项 链中节点数量要控制，避免出现超长链。一般做法是在 handler 中设置一个最大节点数量，在 setNext 中判断是否已经超过阈值，超过则不允许该链建立，避免无意识地破坏系统性能。 代码演示1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798// 级别enum Level &#123; EMERGENCY, SPECIAL, NORMAL, MISS; public static List&lt;Level&gt; getLevelList() &#123; return Arrays.asList(Level.values()); &#125;&#125;// 请求类class Request &#123; private Level level; public Request(Level level) &#123; this.level = level; &#125; public Level getLevel() &#123; return level; &#125;&#125;// 结果类class Response &#123;&#125;// handlerabstract class AbstractHandler &#123; // 下一个处理者 private AbstractHandler next; public void setNext(AbstractHandler next) &#123; this.next = next; &#125; // 某个处理者拥有一个级别 protected abstract Level getHandlerLevel(); // 处理方法 protected abstract Response exec(Request request); // 总的处理逻辑 public final Response handleMessage(Request request) &#123; Response response = null; if (isExec(request.getLevel())) &#123; System.out.println(this.getClass().getSimpleName() + \"处理请求！\"); response = this.exec(request); &#125; else &#123; if (this.next != null) &#123; System.out.println(\"交给下个 handler 处理：\" + this.next.getClass().getSimpleName()); response = this.next.handleMessage(request); &#125; else &#123; System.out.println(\"没有 handler 处理该请求：\" + request.getLevel()); &#125; &#125; return response; &#125; // 增加一个是否执行的判断，只有当请求的级别高于 handler 的处理级别时再执行 public final boolean isExec(Level level) &#123; if (level == null) &#123; return false; &#125; List&lt;Level&gt; levels = Level.getLevelList(); return levels.indexOf(level) &lt;= levels.indexOf(getHandlerLevel()); &#125;&#125;class ConcreteHandler1 extends AbstractHandler &#123; @Override protected Level getHandlerLevel() &#123; return Level.EMERGENCY; &#125; @Override protected Response exec(Request request) &#123; return new Response(); &#125;&#125;class ConcreteHandler2 extends AbstractHandler &#123; @Override protected Level getHandlerLevel() &#123; return Level.NORMAL; &#125; @Override protected Response exec(Request request) &#123; return new Response(); &#125;&#125;class ConcreteHandler3 extends AbstractHandler &#123; @Override protected Level getHandlerLevel() &#123; return Level.SPECIAL; &#125; @Override protected Response exec(Request request) &#123; return new Response(); &#125;&#125;// 通常需要定一个处理器，来组装各个 handler，并指定一个入口class Processor &#123; private final static AbstractHandler HANDLER1 = new ConcreteHandler1(); private final static AbstractHandler HANDLER2 = new ConcreteHandler2(); private final static AbstractHandler HANDLER3 = new ConcreteHandler3(); static &#123; HANDLER1.setNext(HANDLER2); HANDLER2.setNext(HANDLER3); &#125; public Response process(Request request) &#123; return HANDLER1.handleMessage(request); &#125;&#125;class Client &#123; public static void main(String[] args) &#123; Processor processor = new Processor(); System.out.println(\"-------紧急请求-------\"); processor.process(new Request(Level.EMERGENCY)); System.out.println(\"-------普通请求-------\"); processor.process(new Request(Level.NORMAL)); System.out.println(\"-------忽视请求-------\"); processor.process(new Request(Level.MISS)); &#125;&#125; 策略模式 Strategy也叫政策模式 Policy Pattern。使用面向对象的继承和多态机制，实现相同接口的算法使之可以互相转化，包含三个角色： Context 封装角色：也叫上下文角色，起承上启下的作用，屏蔽高层模块对策略、算法的直接访问，封装可能存在的变化。 Strategy 抽象策略角色：策略、算法家族的抽象，通常为接口，定义每个策略或算法必须具有的方法和属性。 ConcreteStrategy 具体策略角色：实现抽象策略中的操作，该类含有具有的算法。 类图 使用场景 多个类只有在算法或行为上稍有不同的场景。 算法需要自由切换的场景。例如，算法由使用者决定或者始终在进化。 需要屏蔽算法规则的场景。对于大量的算法，传递算法的名称或者数字进来，反馈一个运算结果。 优点 算法可以自由切换。只要实现抽象策略，就称为策略家族的一个成员，通过封装角色对其进行封装，保证对外提供 “可自由切换” 的策略。 避免使用多重条件判断。如果一个策略家族有5个策略算法，使用多重条件语句不易维护，出错概率增大。 扩展性良好。增加策略只需要实现接口，其他都不用修改，类似一个可反复拆卸的插件，符合 OCP 原则。 缺点 策略类数量增多。每个策略都是一个类，复用的可能性很小，类数量增多。 所有的策略类都需要对外暴露。上层模块必须知道有哪些策略，才能决定使用哪一个策略，这与迪米特法则相违背。但是可以使用其他模式来修正这个缺陷，如工厂方法模式、代理模式或享元模式。 注意事项 系统中一个策略家族的具体策略数量超过4个，则需要考虑使用混合模式，解决策略类膨胀和对外暴露的问题。 扩展 策略枚举 代码演示 普通策略模式 123456789101112131415161718192021222324252627282930313233343536373839interface Calculator &#123; public int exec(int a, int b);&#125;class Add implements Calculator &#123; @Override public int exec(int a, int b) &#123; return a + b; &#125;&#125;class Sub implements Calculator &#123; @Override public int exec(int a, int b) &#123; return a - b; &#125;&#125;class Context &#123; private Calculator cal = null; public Context(Calculator cal) &#123; this.cal = cal; &#125; public int exec(int a, int b, String symbol) &#123; return this.cal.exec(a, b); &#125;&#125;class Client &#123; private static final String ADD_SYMBOL = \"+\"; private static final String SUB_SYMBOL = \"-\"; public static void main(String[] args) &#123; // 输入的两个参数是数字 int a = 444; String symbol = \"+\"; int b = 555; Context context = null; if (symbol.equals(ADD_SYMBOL)) &#123; context = new Context(new Add()); &#125; else if (symbol.equals(SUB_SYMBOL)) &#123; context = new Context(new Sub()); &#125; System.out.println(\"运行结果为：\" + a + symbol + b + \"=\" + context.exec(a, b, symbol)); &#125;&#125; 策略枚举 1234567891011121314151617181920212223enum CalculatorEnum &#123; ADD(\"+\") &#123; @Override public int exec(int a, int b) &#123; return a + b; &#125; &#125;, SUB(\"-\") &#123; @Override public int exec(int a, int b) &#123; return a - b; &#125; &#125;; private String symbol; CalculatorEnum(String symbol) &#123; this.symbol = symbol; &#125; public abstract int exec(int a, int b);&#125;class Client2 &#123; public static void main(String[] args) &#123; int a = 444; String symbol = \"+\"; int b = 555; System.out.println(\"运行结果为：\" + a + symbol + b + \"=\" + CalculatorEnum.ADD.exec(a, b)); &#125;&#125; 迭代器模式 Iterator能容纳对象的所有类型都可称为容器，如 Collection 集合类型、Set 类型等，迭代器模式就是为解决遍历这些容器中的元素而诞生的。迭代器类似于数据库中的游标，可以在一个容器内上下翻滚，遍历需要查看的元素。包含以下角色： Iterator 抽象迭代器：负责定义访问和遍历元素的接口，基本上有3个固定方法，first()、next()、hasNext() 是否已经访问到底部。 ConcreteIterator 具体迭代器：实现 迭代器接口，完成容器元素的遍历。 Aggregate 抽象容器：提供创建具体迭代器角色的接口，必然提供一个类似 createIterator() 这样的方法，如 java 中的 iterator() 方法。 Concrete Aggregate 具体容器：实现容器接口定义的方法，创建出容纳迭代器的对象。 类图 优点 迭代器模式提供了遍历容器的方便性，容器只要管理增减元素即可，需要遍历时交由迭代器进行。 注意事项 迭代器使用广发，JDK 1.2 版本开始增加 java.util.Iterator 这个接口，并逐步应用到各个聚集类 Collection 中，迭代器模式现已融入到基本 API 中。 Java 中尽量不要自己写迭代器模式，使用 Iterator 一般能够满足要求。 实际开发中，迭代器的删除方法应该完成2个逻辑，一是删除当前元素，二是当前游标指向下一个元素。 代码演示123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class IteratorPattern implements Iterator &#123; private Vector vector; public int cursor = 0; public IteratorPattern(Vector vector) &#123; this.vector = vector; &#125; @Override public boolean hasNext() &#123; return this.cursor != this.vector.size(); &#125; @Override public Object next() &#123; Object result = null; if (this.hasNext()) &#123; result = this.vector.get(cursor++); &#125; return result; &#125; @Override public void remove() &#123; // 实际开发中，迭代器的删除方法应该完成2个逻辑，一是删除当前元素，二是当前游标指向下一个元素。 this.vector.remove(this.cursor); &#125;&#125;interface Aggregate &#123; void add(Object o); void remove(Object o); Iterator iterator();&#125;class ConcreteAggregate implements Aggregate &#123; private Vector vector = new Vector(); @Override public void add(Object o) &#123; this.vector.add(o); &#125; @Override public void remove(Object o) &#123; this.vector.remove(o); &#125; @Override public Iterator iterator() &#123; return new IteratorPattern(this.vector); &#125;&#125;class Client &#123; public static void main(String[] args) &#123; Aggregate agg = new ConcreteAggregate(); agg.add(\"aaa\"); agg.add(\"cccc\"); agg.add(234324); Iterator iter = agg.iterator(); while (iter.hasNext()) &#123; System.out.println(iter.next()); &#125; &#125;&#125;","categories":[],"tags":[{"name":"book","slug":"book","permalink":"https://melodyplayer.github.io/blog/tags/book/"}]},{"title":"《设计模式之禅》——结构型","slug":"《设计模式之禅》——结构型","date":"2019-12-08T07:23:43.000Z","updated":"2020-02-29T17:18:28.116Z","comments":true,"path":"blog/2019/1208:《设计模式之禅》——结构型/","link":"","permalink":"https://melodyplayer.github.io/blog/2019/1208:《设计模式之禅》——结构型/","excerpt":"7种结构型模式：代理、装饰、适配器、组合、外观、享元、桥接。","text":"7种结构型模式：代理、装饰、适配器、组合、外观、享元、桥接。 代理模式 Proxy也叫委托模式。许多其他模式如状态模式、策略模式、访问者模式本质上是在特殊场合采用了委托模式。 类图 使用场景 典型动态代理：Spring AOP 应用广泛：系统框架、企业平台、事务处理 优点 职责清晰：真实角色只需实现实际的业务逻辑，由代理完成事务。 高扩展性：具体的主题角色不管怎么变化，只要实现了接口，代理类就可以在不做任何修改的情况下使用。 智能化：动态代理。 扩展 普通代理 调用者需要知道代理类的存在才能访问，不用知道真实角色。 适合扩展性要求较高的场合。实际项目中通常约定禁止new一个真实角色。 强制代理 代理管理由真实角色完成，不能随便new。高层模块只需调用 getProxy 就可以访问真实角色所有方法。必须通过真实角色查找到代理角色才能访问，不允许直接访问真实角色。 代理是有个性的 代理可实现其他接口完成不同的任务。 代理的目的是在目标对象方法的基础上作增强，进行拦截和过滤。 动态代理 实现阶段不关心代理谁，而在运行阶段才指定代理哪个对象。 相对来说，自己写代理类的方式是静态代理。 AOP：Aspect Oriented Programming 实现思路：实现 InvocationHandler 动态代理接口，重写 invoke() 方法，完成对真实方法的调用。在运行时动态产生代理对象。 代码演示 普通代理 123456789101112131415161718interface Subject1 &#123; void doSomething(String str);&#125;class Subject1Impl implements Subject1 &#123; @Override public void doSomething(String str) &#123;System.out.println(\"Subject1 做\" + str);&#125;&#125;// 代理要实现相同接口，高层模块调用时要先构造代理对象class NormalProxy implements Subject1 &#123; private Subject1 subject1; public NormalProxy(Subject1 subject1) &#123;this.subject1 = subject1;&#125; @Override public void doSomething(String str) &#123;subject1.doSomething(str);&#125;&#125; 强制代理 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354interface Subject2 &#123; void doSomething(String str); // 获取自身特定的代理类 Subject2 getProxy();&#125;class Subject2Impl implements Subject2 &#123; private ForceProxy forceProxy; @Override public void doSomething(String str) &#123; if (isProxy()) &#123; System.out.println(\"Subject2 在做\" + str); &#125; else &#123; System.out.println(\"请使用自身代理执行 做\" + str); &#125; &#125; // 判断是否拥有代理 private boolean isProxy() &#123;return this.forceProxy != null;&#125; @Override public Subject2 getProxy() &#123; if (this.forceProxy == null) &#123; synchronized (this) &#123; if (this.forceProxy == null) &#123; this.forceProxy = new ForceProxy(this); &#125; &#125; &#125; return this.forceProxy; &#125;&#125;class ForceProxy implements Subject2 &#123; private Subject2 subject2; public ForceProxy(Subject2 subject2) &#123;this.subject2 = subject2;&#125; @Override public void doSomething(String str) &#123;subject2.doSomething(str);&#125; @Override public Subject2 getProxy() &#123;return this;&#125;&#125;class Client2 &#123; public static void main(String[] args) &#123; Subject2 subject2 = new Subject2Impl(); subject2.doSomething(\"家务\"); ForceProxy forceProxy = new ForceProxy(subject2); forceProxy.doSomething(\"饭\"); subject2.getProxy().doSomething(\"运动\"); &#125;&#125; 个性化的代理类 12345678910111213141516171819202122232425262728293031interface Player &#123;void doSport();&#125;interface Boss &#123;void invest(String str);&#125;class PlayerImpl implements Player &#123; @Override public void doSport() &#123;System.out.println(\"运动员做XXX运动太出名了\");&#125;&#125;class MultiImplementProxy implements Player, Boss &#123; private Player player; public MultiImplementProxy(Player player) &#123;this.player = player;&#125; @Override public void doSport() &#123; player.doSport(); this.invest(\"拍电影\"); &#125; @Override public void invest(String str) &#123;System.out.println(\"代理人有钱，给运动员投资\" + str);&#125;&#125;class Client3 &#123; public static void main(String[] args) &#123; Player player = new PlayerImpl(); MultiImplementProxy proxy = new MultiImplementProxy(player); proxy.doSport(); &#125;&#125; 动态代理 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859// 动态代理的 handler 类class MyInvocationHandler implements InvocationHandler &#123; // 被代理对象 private Object obj; public MyInvocationHandler(Object obj) &#123;this.obj = obj;&#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; return method.invoke(obj, args); &#125;&#125;// 切面接口interface IAdvice &#123;void exec();&#125;class BeforeAdvice implements IAdvice&#123; @Override public void exec() &#123;System.out.println(\"前置通知被执行！\");&#125;&#125;// 通用动态代理类，只做切面增强class DynamicProxy &#123; public static &lt;T&gt; T newInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h) &#123; // 寻找 JoinPoint 连接点，AOP框架使用元数据定义 if (true) &#123; // 执行一个前置通知 new BeforeAdvice().exec(); &#125; return (T) Proxy.newProxyInstance(loader, interfaces, h); &#125;&#125;// 具有业务意义的动态代理类class SubjectDynamicProxy extends DynamicProxy &#123; private SubjectDynamicProxy() &#123;&#125; public static &lt;T&gt; T newProxyInstance(Subject4 subject4) &#123; ClassLoader loader = subject4.getClass().getClassLoader(); Class&lt;?&gt;[] interfaces = subject4.getClass().getInterfaces(); MyInvocationHandler handler = new MyInvocationHandler(subject4); return newInstance(loader, interfaces, handler); &#125;&#125;// 业务接口interface Subject4 &#123;void doSomething();&#125;class Subject4Impl implements Subject4 &#123; @Override public void doSomething() &#123;System.out.println(\"Subject4 做某事\");&#125;&#125;// 高层调用模块——客户端class client4 &#123; public static void main(String[] args) &#123; Subject4 proxy = SubjectDynamicProxy.newProxyInstance(new Subject4Impl()); proxy.doSomething(); &#125;&#125; 装饰模式 Decorator类图 使用场景 需要扩展一个类的功能，或给一个类增加附加功能。 需要动态地给一个对象增加功能，这些功能可以再动态地撤销。 需要为一批的兄弟类进行改造或加装功能，首选装饰模式。 优点 装饰类和被装饰类可以独立发展，不会相互耦合。换句话说，Component类无须知道Decorator类，Decorator类是从外部来扩展Component类的功能，而Decorator也不用知道具体的构件。 对于 Father、Son、GrandSon三个类，如果要在 son 上增强功能，在 Son 上直接修改可能会影响到 GrandSon，但采用 SonDecorator 类来修饰 Son 相当于创建新类，对原来的程序无影响。 装饰模式是继承关系的替代方案。对于装饰类 Decorator，不管装饰多少层，返回的对象还是 Component，实现的还是 is-a 的关系。 继承会增加很多子类，装饰模式可以有效解决类膨胀的问题。 装饰模式可以动态地扩展一个实现类的功能。 想去掉某个封装只需要在高层模块去掉即可，如果用继承就必须要修改子模块。 缺点 多层的装饰比较复杂。定位问题时不容易发现是那一层装饰出了问题。 因此尽量减少装饰类的数量，以便降低系统的复杂度。 注意事项 与代理模式的比较：类图、代码实现非常相似，区别在于 代理负责接口限定：是否可以调用真实角色，以及是否对发送到真实角色的消息进行变形处理，不对被代理类的功能做任何处理。应用广范。 装饰保证接口不变做类的加强，保证被修饰对象功能比原始对象丰富或减弱，但不做准入条件判断和准入参数过滤。例如 JDK 的 java.io.* 包中的 1OutputStream out = new DataOutPutStream(new FileOutputStream(\"test.txt\")); 代码演示1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162abstract class SchoolReport &#123; // 成绩单报告 abstract void report(); // 家长签名 abstract void sign(String name);&#125;// 期末考试成绩报告，如果直接报告分数这么低肯定少不了“竹笋炒肉”class FinalExamSchoolReport extends SchoolReport &#123; @Override void report() &#123; System.out.println(\"尊敬的XXX家长：\"); System.out.println(\"XXX这次考试成绩如下：语文62，数学65，自然63\"); System.out.println(\"家长签名：\"); &#125; @Override void sign(String name) &#123;System.out.println(\"家长签名为：\" + name);&#125;&#125;abstract class Decorator extends SchoolReport &#123; private SchoolReport sr; public Decorator(SchoolReport sr) &#123;this.sr = sr;&#125; @Override void report() &#123;sr.report();&#125; @Override void sign(String name) &#123;sr.sign(name);&#125;&#125;// 如果只汇报自己的成绩，太低容易挨揍，把班里的最高分作为背景铺垫一下，相对来说分就没那么低了class HighScoreDecorator extends Decorator &#123; public HighScoreDecorator(SchoolReport sr) &#123;super(sr);&#125; @Override void report() &#123; reportHighScore(); super.report(); &#125; private void reportHighScore() &#123; System.out.println(\"这次考试全班最高分，语文75，数学78，自然82\"); &#125;&#125;// 再来个排名的装饰，虽然分低但是排名不靠后，相对也还是不错class SortDecorator extends Decorator &#123; public SortDecorator(SchoolReport sr) &#123;super(sr);&#125; @Override void report() &#123; super.report(); reportSort(); &#125; private void reportSort() &#123;System.out.println(\"全班60人，我的排名32\");&#125;&#125;class Father &#123; public static void main(String[] args) &#123; SchoolReport sr = new FinalExamSchoolReport(); sr = new HighScoreDecorator(sr); sr = new SortDecorator(sr); sr.report(); // 报告完之后老爸一看还行，免了一顿打把字签了 sr.sign(\"XXX的爸爸\"); &#125;&#125; 适配器模式 Adapter也叫变压器模式、包装模式（包装模式包括装饰模式）。 类图 使用场景 有动机修改一个已经投产中的接口时，比如系统扩展需要使用一个已有或新建的类，但这个类又不符合系统的接口，采用适配器模式。 作为补偿模式，用来解决接口不相容的问题。 优点 让两个没有关联的类一起运行。 增加类的透明性，高层模块不需要关注源角色怎么执行。 提高类的复用度，源角色在原有系统中可以正常使用，而在目标角色中也可以发挥新作用。 灵活性好，不需要适配器时删除掉即可。 注意事项 在详细设计阶段不要考虑使用适配器模式，它是为了解决正在服役的项目问题，减少代码修改带来的风险。 项目一定要遵守依赖倒置原则和里氏替换原则，否则即使使用适配器模式改动也很大。 扩展 类适配器 通过继承进行适配。智能通过覆写源角色的方法进行扩展。 对象适配器 通过关联、聚合进行适配。适用于多接口适配。可以灵活修补源角色的隐形缺陷、关联其他对象等。实际项目中对象适配器使用场景较多。 代码演示 类适配器 123456789101112131415161718192021222324252627282930313233// 接口interface Target &#123;void request();&#125;// 实现类class TargetImpl implements Target &#123; @Override public void request() &#123;System.out.println(\"目标实现类执行request\");&#125;&#125;// 源角色class Adaptee &#123; void doSomething() &#123;System.out.println(\"源角色要做的事情\");&#125;&#125;// 适配器角色class Adapter extends Adaptee implements Target &#123; @Override public void request() &#123; System.out.println(\"适配器要做的事\"); super.doSomething(); &#125;&#125;class Client &#123; public static void main(String[] args) &#123; // 原逻辑 Target target = new TargetImpl(); target.request(); // 使用适配器后，也拥有了request方法，扩展了新功能 Target adapter = new Adapter(); adapter.request(); &#125;&#125; 对象适配器 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758// 用户信息interface IUserInfo &#123;Map getUserInfo();&#125;class UserInfo implements IUserInfo &#123; @Override public Map getUserInfo() &#123;return new HashMap();&#125;&#125;interface IUserHomeInfo &#123;Map getHomeInfo();&#125;interface IUserOfficeInfo &#123;Map getOfficeInfo();&#125;class UserHomeInfo implements IUserHomeInfo &#123; @Override public Map getHomeInfo() &#123; Map map = new HashMap(); map.put(\"homeAddress\", \"北京市海淀区奥林匹克公园\"); map.put(\"homePhone\", \"家庭电话：123456\"); return map; &#125;&#125;class UserOfficeInfo implements IUserOfficeInfo &#123; @Override public Map getOfficeInfo() &#123; Map map = new HashMap(); map.put(\"officeAddress\", \"办公地址：鸟巢\"); map.put(\"officePhone\", \"办公电话：222333\"); return map; &#125;&#125;// 用户基本信息，适配home和office两个接口class UserBaseInfo implements IUserInfo &#123; private IUserHomeInfo userHomeInfo; private IUserOfficeInfo userOfficeInfo; private Map map = new HashMap(); public UserBaseInfo(IUserHomeInfo userHomeInfo, IUserOfficeInfo userOfficeInfo) &#123; this.userHomeInfo = userHomeInfo; this.userOfficeInfo = userOfficeInfo; map.putAll(userHomeInfo.getHomeInfo()); map.putAll(userOfficeInfo.getOfficeInfo()); &#125; @Override public Map getUserInfo() &#123;return map;&#125;&#125;class AdapterClient2 &#123; public static void main(String[] args) &#123; IUserHomeInfo homeInfo = new UserHomeInfo(); IUserOfficeInfo officeInfo = new UserOfficeInfo(); IUserInfo userInfo = new UserBaseInfo(homeInfo, officeInfo); Map info = userInfo.getUserInfo(); System.out.println(info.toString()); &#125;&#125; 组合模式 Composite也叫合成模式、部分—整体模式，将对象组合成树形结构用来表示部分与整体的关系。 类图 使用场景 维护和展示部分—整体关系的场景，如树形菜单、文件盒文件夹管理。 从一个整体中能够独立出部分模块或功能的场景。 优点 高层模块调用简单 一棵树形结构中的所有节点都是Component，局部和整体对调用者来说没有任何区别。高层模块不用关心处理的是单个对象还是整个组合结构。 节点自由增加 增加树枝节点、树叶节点非常容易，符合开闭原则，有利于维护。 缺点 不符合依赖倒置原则 场景类中树叶和树枝直接使用了实现类，限制了接口的影响范围。 注意事项 只要是树形结构，就要考虑使用组合模式。 体现局部和整体的关系，当关系比较深时，考虑组合模式。 扩展 真实的组合模式 实际使用中仍需组装这棵树，使用关系型数据库或者其他方式存储树形结构。 安全模式 树枝节点和树叶节点彻底分开，树枝节点单独拥有用来组合的方法，这种方法比较安全。 透明模式 把用来组合使用的方法放到抽象类中，不管叶子对象还是数值对象都有相同的结构。通过判断 getChildren 的返回值确认是叶子节点还是树枝节点，如果处理不当，会在运行期出问题。 组合模式的遍历 从上往下遍历没有问题，如果从下往上遍历，则需要设置 parent 属性。从而实现后序、中序等遍历方式。 树叶、树枝节点排列顺序 不用list，改用treeSet存储对象即可，可以加上实现 Comparable 接口，覆盖 compareTo 方法。 代码演示 安全模式 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950abstract class Staff &#123; private String name; private String position; public Staff(String name, String position) &#123; this.name = name; this.position = position; &#125; public String getInfo() &#123;return this.toString();&#125;&#125;class Leaf extends Staff &#123; public Leaf(String name, String position) &#123;super(name, position);&#125;&#125;class Branch extends Staff &#123; List&lt;Staff&gt; subordinate = new ArrayList&lt;&gt;(); public Branch(String name, String position) &#123;super(name, position);&#125; public void addStaff(Staff staff) &#123;this.subordinate.add(staff);&#125; public List&lt;Staff&gt; getSubordinate() &#123;return this.subordinate;&#125;&#125;class CompositeClient1 &#123; static String getTreeInfo(Branch root) &#123; String info = \"\"; List&lt;Staff&gt; staff = root.getSubordinate(); for (Staff s : staff) &#123; if (s instanceof Leaf) &#123; info = info + s.getInfo(); &#125; else &#123; info = info + s.getInfo() + \"\\t\" + getTreeInfo((Branch) s); &#125; &#125; return info; &#125; public static void main(String[] args) &#123; // 组装 Staff staff = new Branch(\"张三\", \"局长\"); Staff staff2 = new Branch(\"李四\", \"科长\"); Staff leaf2 = new Leaf(\"王五\", \"组员\"); Branch branch = ((Branch) staff).addStaff(staff2); Branch branch2 = ((Branch) staff2).addStaff(leaf2); // 打印树枝节点 System.out.println(getTreeInfo(branch)); // 打印树枝节点2 System.out.println(getTreeInfo(branch2)); &#125;&#125; 透明模式 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667// add、remove等方法放在抽象类中abstract class Component &#123; private String name; public Component(String name) &#123; this.name = name; &#125; public String getInfo() &#123; return name; &#125; abstract void add(Component component); abstract void remove(Component component); abstract List&lt;Component&gt; getChildren();&#125;class Leaf2 extends Component &#123; public Leaf2(String name) &#123; super(name); &#125; @Deprecated @Override void add(Component component) &#123; throw new UnsupportedOperationException(\"叶子没有 add\"); &#125; @Deprecated @Override void remove(Component component) &#123; throw new UnsupportedOperationException(\"叶子没有 remove\"); &#125; @Deprecated @Override List&lt;Component&gt; getChildren() &#123; throw new UnsupportedOperationException(\"叶子没有子节点\"); &#125;&#125;class Branch2 extends Component &#123; List&lt;Component&gt; subordinate = new ArrayList&lt;&gt;(); public Branch2(String name) &#123; super(name); &#125; @Override void add(Component component) &#123; subordinate.add(component); &#125; @Override void remove(Component component) &#123; subordinate.remove(component); &#125; @Override List&lt;Component&gt; getChildren() &#123; return this.subordinate; &#125;&#125;class CompositeClient2 &#123; public static String display(Component root) &#123; String s = \"\"; if (root instanceof Leaf2) &#123; s += root.getInfo(); &#125; else &#123; s += root.getInfo(); for (Component child : root.getChildren()) &#123; s += \"\\t\" + display(child); &#125; &#125; return s; &#125; public static void main(String[] args) &#123; Branch2 b1 = new Branch2(\"分支1\"); Branch2 b2 = new Branch2(\"分支1-1\"); Leaf2 l = new Leaf2(\"叶子1\"); b1.add(b2); b2.add(l); System.out.println(display(b1)); System.out.println(\"------\"); System.out.println(display(b2)); System.out.println(\"------\"); System.out.println(display(l)); &#125;&#125; 外观模式 Facade也叫 门面模式。子系统外部与内部通信必须通过统一的对象进行，也就是提供一个访问子系统的接口，除了这个接口不允许有任何访问子系统的行为发生。 门面对象是外界访问子系统内部的唯一通道，不管子系统内部多么杂乱，只要有门面对象，就可做到“金玉其外败絮其中”。 类图 使用场景 为一个复杂的模块或子系统提供一个供外界访问的接口。 子系统相对独立——外界对子系统的访问只要黑箱操作即可。例如利息计算子系统，对于使用者来说只要输入金额以及存期返回结果利息就可以，不用关心其他问题。 预防低水平人员带来的风险扩散。“画地为牢”，只在指定的子系统中开发，再提供门面接口进行访问操作。 优点 减少系统间的互相依赖。避免外界访问直接深入到子系统内部形成强耦合关系。 提高灵活性。子系统内部变化不影响门面对象，则随意使用。 提高安全性。门面上未开通的方法无法访问。 缺点 不符合开闭原则，对修改关闭，对扩展开放。如果系统投产后发现有问题，只能通过修改门面角色的代码解决。 注意事项 一个子系统可以有多个门面 门面已经庞大到不能忍受的程度。比如一个纯洁的门面对象已经超过了200行代码，虽然都是非常简单的委托操作，也建议拆分成多个门面，否则不利于以后的维护和扩展。拆分原则可按照功能拆分，例如数据库操作门面可以拆分为查询门面、删除门面、更新门面等。 子系统需要提供不同访问路径。例如模块一的门面已经封装了3个类ABC，模块二可以委托模块一的门面对象完成调用ABC中某一个类的操作，当外界调用模块二门面对象时，就减少了访问权限。 12345678910class Facade &#123; private ClassA a = new ClassA(); private ClassB b = new ClassB(); public void methodA() &#123;this.a.doSomethingA();&#125; public void methodB() &#123;this.b.doSomethingB();&#125;&#125;class Facade2() &#123; private Facade facade = new Facade(); public void methodB() &#123;this.facade.methodB();&#125;&#125; 门面不参与子系统内的业务逻辑 当需要修改B方法时，不能这样改！ 1234public void methodB() &#123; this.a.doSomethingA(); this.b.doSomethingB();&#125; 而是建立一个封装类，封装完毕后提供给门面对象！ 123456789101112131415161718// 建立封装类class Context &#123; private ClassA a = new ClassA(); private ClassB b = new ClassB(); public void complexMethod()&#123; this.a.doSomethingA(); this.b.doSomethingB(); &#125;&#125;// 门面上添加相应的方法class Facade &#123; private ClassA a = new ClassA(); private ClassB b = new ClassB(); private Context context = new Context(); public void methodA() &#123;this.a.doSomethingA();&#125; public void methodB() &#123;this.b.doSomethingB();&#125; public void methodC() &#123;this.context.conplexMethod();&#125;&#125; 代码演示以写信为例。 1234567891011121314151617181920212223242526272829303132333435363738394041/** * 信件处理接口，包含 写内容、写信封、封信封、投递 */interface LetterProcess &#123; void writeContext(String context); void fillEnvelope(String address); void letterIntoEnvelope(); void sendLetter();&#125;class LetterProcessImpl implements LetterProcess &#123; @Override public void writeContext(String context) &#123;System.out.println(\"信的内容：\" + context);&#125; @Override public void fillEnvelope(String address) &#123;System.out.println(\"收件人地址及姓名：\" + address);&#125; @Override public void letterIntoEnvelope() &#123;System.out.println(\"把信放入信封中\");&#125; @Override public void sendLetter() &#123;System.out.println(\"邮递信件\");&#125;&#125;/** * 邮局——外观类 */class PostOffice &#123; private LetterProcess letterProcess = new LetterProcessImpl(); public void sendLetter(String context, String address) &#123; letterProcess.writeContext(context); letterProcess.fillEnvelope(address); letterProcess.letterIntoEnvelope(); letterProcess.sendLetter(); &#125;&#125;class Client &#123; public static void main(String[] args) &#123; PostOffice postOffice = new PostOffice(); postOffice.sendLetter(\"一封测试邮件\", \"长安大街1号 慈禧\"); &#125;&#125; 享元模式 Flyweightflyweight是拳击比赛中的特用名词，意思是“特轻量级”，指51公斤级比赛。在设计模式中指类要轻量级、粒度要小。粒度小带来的问题就是对象太多，就可以用共享技术来解决。 享元模式是池技术的重要实现方式。要求：细粒度的对象和共享对象。抽象后包括： 内部状态：对象可共享出来的信息，存储在享元对象内部并且不会随环境改变而改变。 外部状态：对象得以依赖的一个标记，随环境改变而改变、不可共享的状态。 Flyweight——抽象享元角色：抽象类，同时定义出对象的外部状态和内部状态的接口或实现。 ConcreteFlyweight——具体享元角色：实现类。 unsharedConcreteFlyweight——不可共享的享元角色：不存在外部状态或者安全要求（如线程安全）无法使用共享技术的对象，该对象一般不会出现在享元工厂中。 FlyweightFactory——享元工厂：构造池容器，同时提供从池中获得对象的方法。 类图 使用场景 系统中存在大量的相似对象。 细粒度的对象都具备较接近的外部状态，而且内部状态与环境无关，也就是说对象没有特定身份。 需要缓冲池的场景。 优点 大大减少应用创建的对象数量，降低程序内存的占用，增强程序性能。 缺点 提高了系统复杂性，需要分离出外部状态和内部状态。而且内部状态具有固化特性，不应该随外部状态改变而改变，否则会导致系统逻辑混乱。 注意事项 享元模式和对象池 可以使用享元模式实现对象池，但两者差异较大。 对象池是构造型模式，着重在对象的复用上，池中每个对象可替换，从同一个池中获得A对象和B对象对客户端来说是完全相同的。即对象池中的对象都是等价的，任意两个个对象在任何使用场景中都可以被池中的其他对象代替。例如数据库连接池、线程池等。 享元模式是结构型模式，主要解决对象的访问问题，如何建立多个可共享的细粒度对象才是关注的重点。享元工厂所维护的所有对象都是不同的，任何两个对象不能互相代替。侧重对象之间的衔接，把动态的、会变化的状态剥离、外部化，共享不变的东西。但是这部分外部化的东西和享元模式内部共享的不会变的东西之间存在关联。所以享元对外提供的接口常常会包含一个 String 类型的参数，表示 key、名称之类。 扩展 线程安全问题 多个线程从对象池中获得对象然后修改其属性，会出现线程安全问题。 性能平衡 尽量使用java基本类型作为外部状态。使用自定义类作为外部条件，需要覆写 equals 和 hashCode 方法，执行效率还低。使用 java 基本类型又简洁效率又高。 代码演示12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455abstract class Flyweight &#123; // 内部状态 @Getter @Setter private String intrinsic; // 外部状态 protected final String extrinsic; // 要求享元角色必须接受外部状态 public Flyweight(String extrinsic) &#123;this.extrinsic = extrinsic;&#125; public abstract void operate();&#125;class ConcreteFlyweight extends Flyweight &#123; public ConcreteFlyweight(String extrinsic) &#123;super(extrinsic);&#125; @Override public void operate() &#123;System.out.println(\"共享的具体的extrisic: \" + extrinsic);&#125;&#125;class UnsharedConcreteFlyweight extends Flyweight &#123; public UnsharedConcreteFlyweight(String extrinsic) &#123;super(extrinsic);&#125; @Override public void operate() &#123;System.out.println(\"不共享的具体extrinsic： \" + extrinsic);&#125;&#125;class FlyweightFactory &#123; private static HashMap&lt;String, Flyweight&gt; pool = new HashMap&lt;&gt;(); public static Flyweight getFlyweight(String extrinsic) &#123; Flyweight flyweight; if (pool.containsKey(extrinsic)) &#123; flyweight = pool.get(extrinsic); System.out.println(\"已有 \" + extrinsic + \" 直接从池中获取\"); &#125; else &#123; flyweight = new ConcreteFlyweight(extrinsic); pool.put(extrinsic, flyweight); System.out.println(\"创建 \" + extrinsic + \" 并从池中取出\"); &#125; return flyweight; &#125;&#125;class FlyweightClient &#123; public static void main(String[] args) &#123; Flyweight x = FlyweightFactory.getFlyweight(\"X\"); x.operate(); Flyweight y = FlyweightFactory.getFlyweight(\"Y\"); y.operate(); Flyweight z = FlyweightFactory.getFlyweight(\"Z\"); z.operate(); Flyweight xx = FlyweightFactory.getFlyweight(\"X\"); xx.operate(); &#125;&#125; 桥接模式 Bridge也叫桥梁模式，将抽象和实现解耦，使得两者可以独立变化。包含4个角色： 抽象化角色 Abstraction：定义该角色的行为，同时保存一个队实现化角色的引用，该角色一般是抽象类。 实现化角色 Implementor：接口或抽象类，定义角色必须的行为和属性。 修正抽象化角色 RefinedAbstraction：引用实现化角色对抽象化角色进行修正。 具体实现化角色 ConcreteImplementor：实现接口或抽象类定义的方法和属性。 抽象角色引用实现角色，或者说抽象角色的部分实现是由实现角色完成的。 类图 使用场景 不希望或者不适合使用继承的场景。例如继承层次过多、无法更细化设计颗粒等场景。 接口或抽象类不稳定的场景。明知道接口不稳定还想通过实现或继承来实现业务需求，得不偿失。 重用性要求较高的场景。设计的颗粒度越细，则被重用的可能性就越大，而采用继承则受父类的限制，不可能出现太细的颗粒度。 优点 抽象和实现分离 完全是为了解决继承的缺点而提出的设计模式。在该模式下，实现可以不受抽象的约束，不用再绑定在一个固定的抽象层次上。 优秀的扩充能力 增加实现、抽象非常容易，只要堆外暴露的接口层允许这样的变化，已经把变化的可能性减到最小。 实现细节对客户透明 客户不用关心细节的实现，已经由抽象层通过聚合关系完成了封装。 注意事项 使用时主要考虑如何拆分抽象和实现，并不是一涉及继承就要使用。桥接模式的意图主要是对变化的封装，尽量把可能变化的因素封装到最细、最小的逻辑单元中，避免风险扩散。因此在系统设计时，发现类的继承有N层时，可以考虑使用该模式。例如 Father 类有一个方法 A，Son 继承了这个方法，GrandSon 也继承了这个方法，那么 Son 则不能再随便修改这个方法了。 代码演示1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465// 实现化角色abstract class Product &#123; @Getter @Setter protected String name; abstract void beProduced(); abstract void beSelled();&#125;class House extends Product &#123; @Override void beProduced() &#123;System.out.println(\"房子被生产出来了。。\");&#125; @Override void beSelled() &#123;System.out.println(\"生产的房子被卖掉了。。\");&#125;&#125;class Car extends Product &#123; @Override void beProduced() &#123;System.out.println(\"汽车被生产出来了。。\");&#125; @Override void beSelled() &#123;System.out.println(\"生产的汽车被卖掉了。。\");&#125;&#125;// 抽象化角色abstract class Corp &#123; protected Product product; public Corp(Product product) &#123;this.product = product;&#125; void makeMoney() &#123; this.product.beProduced(); this.product.beSelled(); &#125;&#125;class HouseCorp extends Corp &#123; public HouseCorp(Product product) &#123;super(product);&#125; @Override void makeMoney() &#123; super.makeMoney(); System.out.println(\"房地产公司赚大钱了！\"); &#125;&#125;class ManufactureCorp extends Corp &#123; public ManufactureCorp(Product product) &#123;super(product);&#125; @Override void makeMoney() &#123; super.makeMoney(); System.out.println(\"制造公司生产\" + super.product.getName() + \"，也赚钱了！\"); &#125;&#125;// 客户端class BridgeClient &#123; public static void main(String[] args) &#123; Product house = new House(); house.setName(\"【房子】\"); System.out.println(\"房地产公司运行。。。。\"); Corp houseCorp = new HouseCorp(house); houseCorp.makeMoney(); System.out.println(\"\\n制造公司运行。。。\"); Product car = new Car(); car.setName(\"【汽车】\"); Corp manufactureCorp = new ManufactureCorp(car); manufactureCorp.makeMoney(); &#125;&#125;","categories":[],"tags":[{"name":"book","slug":"book","permalink":"https://melodyplayer.github.io/blog/tags/book/"}]},{"title":"《设计模式之禅》——创建型","slug":"《设计模式之禅》——创建型","date":"2019-12-01T07:23:43.000Z","updated":"2020-02-21T08:14:39.913Z","comments":true,"path":"blog/2019/1201:《设计模式之禅》——创建型/","link":"","permalink":"https://melodyplayer.github.io/blog/2019/1201:《设计模式之禅》——创建型/","excerpt":"5种创建型模式：单例、工厂、抽象工厂、建造者、原型。","text":"5种创建型模式：单例、工厂、抽象工厂、建造者、原型。 单例模式 Singleton类图 使用场景 要求生成唯一序列号的环境。 整个项目需要一个共享访问点或共享数据。例如web页面上的计数器，使用单例保持计数器的值。 创建对象需要消耗过多资源。例如访问IO和数据库等。 需要定义大量静态常量和静态方法（如工具类）的环境（也可直接声明为 static 的方式）。 优点 内存中只有一个实例，减少了内存开销。避免对象频繁的创建、销毁。 减少系统性能开销。可在应用启动时之间产生单例对象去读取配置，产生其他依赖对象等。 避免对资源的多重占用。例如写文件只由单例去完成。 设置全局访问点，优化和共享资源访问。例如由单例类负责所有数据表的映射处理。 缺点 一般没有接口，扩展困难。提供单一实例、接口或抽象类。 对测试不利。单例没有完成没法测试，业不能 mock 一个虚拟对象。 与单一职责原则由冲突。一个雷实现一个逻辑，不关心是否单例。是不是单例取决于环境，单例模式把要单例 和 业务逻辑 融合在一个类中。 注意事项 线程同步问题 高并发时，可能会出现该问题。解决办法：饿汉、懒汉、二次检查等。 对象的复制情况 如果实现了 Cloneable 接口，即使私有构造函数对象仍然可以被复制。因为克隆不需要调用类的构造函数。对于单例类最好不要实现 Cloneable 接口。 扩展 有上限的单例模式** 决定内存中有多少个实例，修正单例可能存在的性能问题，提供系统的响应速度，例如读取文件在系统启动时完成初始化工作，在内存中启动固定数量的 reader 实例，然后在需要读取文件时就可以快速响应。 代码演示1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283/** * 懒汉模式 * 线程不安全，延迟初始化，严格意义上不是不是单例模式 */public class Singleton1 &#123; private static Singleton1 instance; private Singleton1() &#123;&#125; public static Singleton1 getInstance() &#123; if (instance == null) &#123; return new Singleton1(); &#125; return instance; &#125;&#125;/** * 饿汉模式 * 线程安全，比较常用，但容易产生垃圾，因为一开始就初始化 */class Singleton2 &#123; private static Singleton2 instance = new Singleton2(); private Singleton2() &#123;&#125; public static Singleton2 getInstance() &#123; return instance; &#125;&#125;/** * 双重锁模式 * 线程安全，延迟初始化。采用双锁机制，安全且在多线程情况下能保持高性能 */class Singleton3 &#123; // 避免对象创建时可能在JVM中重排序 private volatile static Singleton3 instance; private Singleton3() &#123;&#125; public static Singleton3 getInstance() &#123; if (instance == null) &#123; synchronized (Singleton3.class) &#123; if (instance == null) &#123; instance = new Singleton3(); &#125; &#125; &#125; return instance; &#125;&#125;/** * 静态内部类单例模式 * 只有第一次调用 getInstance() 时，虚拟机才加载内部类并初始化 instance * 只有一个线程可以获得对象的初始化锁，其他线程无法进行初始化，保证对象的唯一性 * 目前此方式是所有单例模式中最推荐的模式，但具体还是根据项目选择。 */class Singleton4 &#123; private Singleton4() &#123;&#125; public static Singleton4 getInstance() &#123; return InnerClass.INSTANCE; &#125; private static class InnerClass &#123; private static final Singleton4 INSTANCE = new Singleton4(); &#125;&#125;/** * 枚举单例模式 * 默认枚举实例的创建时线程安全的，并且在任何情况下都是单例 * 实际上：枚举类隐藏了私有的构造器；枚举类的域是相应类型的一个实例对象 */enum Singleton5 &#123; INSTANCE; public static Singleton5 getInstance() &#123; return Singleton5.INSTANCE; &#125;&#125; 工厂方法模式 Factory类图 使用场景 需要灵活可扩展的框架时。比如需要设计一个链接邮件服务器的框架，有3种网络协议可选：POP3、IMAP、HTTP，作为产品类，定义接口IConnectMail，然后定义对邮件的操作方法，用不同的方法实现三个具体的产品类（连接方式），再定义一个工厂方法，按照不同的传入条件，选择不同的连接方式。 用在异构项目中。例如通过webservice与非java项目交互，虽然webservice号称可以做到异构系统的同构化，但实际会遇到类型问题、WSDL文件的支持问题等。从WSDL中产生的对象都认为是一个产品，然后由一个具体的工厂类进行管理，减少与外围系统的耦合。 使用在测试驱动开发的框架下。例如测试类A，把与A有关联的B虚拟出来，避免A与B的耦合。该功能由于 JMock 和 EasyMock 的诞生使用场景已经弱化了。 优点 封装良好，代码结构清晰。只需知道产品类名或约束字符串，屏蔽创建过程，降低模块间的耦合。 优秀的扩展性。只需增加扩展类，无需修改工厂类。 屏蔽产品类。接口不变系统中的上层模块就不要发生变化。例如 JDBC 连接数据库，切换数据库需要改动的只是驱动名称。 解耦框架。高层模块只需要指导产品的抽象类，符合迪米特法则（只关心需要关心的）、依赖倒置原则（只依赖产品类的抽象）、里氏替换原则（使用产品子类替换父类）。 扩展 缩小为简单工厂模式 升级为多个工厂类 代替单例模式 延迟初始化 通过map缓存需要重用的对象 代码演示 简单工厂模式 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public class SimpleFactory &#123; public Car getCar(String name) &#123; if (\"bmw\".equalsIgnoreCase(name)) &#123; return new Bmw(); &#125; else if (\"benz\".equalsIgnoreCase(name)) &#123; return new Benz(); &#125; else &#123; System.out.println(\"暂时不生产这个品牌的汽车\"); return null; &#125; &#125; /** * 静态方法通过反射创建产品类 */ public static &lt;T extends Car&gt; T getCar(Class&lt;T&gt; c) &#123; Car car = null; try &#123; car = (Car) Class.forName(c.getName()).newInstance(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return (T) car; &#125; public static void main(String[] args) &#123; SimpleFactory simpleFactory = new SimpleFactory(); Car car = simpleFactory.getCar(\"bmw\"); System.out.println(car.getName()); &#125;&#125;/** * 产品类 */interface Car &#123; String getName();&#125;class Benz implements Car &#123; @Override public String getName() &#123; return \"奔驰\"; &#125;&#125;class Bmw implements Car &#123; @Override public String getName() &#123; return \"宝马\"; &#125;&#125; 工厂模式 不能存在一个工厂生产所有产品的情况，所以需要多个工厂进行不同产品的生产。 12345678910111213141516171819202122232425262728293031/** * 工厂类 * 多个工厂，封装不同的产品生产流程 */public interface Factory &#123; Car getCar();&#125;class BenzFactory implements Factory &#123; @Override public Car getCar() &#123; return new Benz(); &#125;&#125;class BmwFactory implements Factory &#123; @Override public Car getCar() &#123; return new Bmw(); &#125;&#125;class FactoryTest &#123; public static void main(String[] args) &#123; BenzFactory benzFactory = new BenzFactory(); System.out.println(benzFactory.getCar().getName()); BmwFactory bmwFactory = new BmwFactory(); System.out.println(bmwFactory.getCar().getName()); &#125;&#125; 替代单例模式 123456789101112131415161718public class SingletonFactory &#123; private static Singleton instance; static &#123; try &#123; Class c = Class.forName(Singleton.class.getName()); Constructor constructor = c.getDeclaredConstructor(); constructor.setAccessible(true); instance = (Singleton) constructor.newInstance(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; public static Singleton getInstance() &#123; return instance; &#125;&#125;class Singleton &#123;&#125; 延迟初始化 123456789101112131415161718public class MapFactory &#123; private static final Map&lt;String, Product&gt; PRODUCT_MAP = new HashMap&lt;&gt;(); public static synchronized &lt;T extends Product&gt; T getProduct(Class&lt;T&gt; c) throws Exception &#123; T product = null; if (PRODUCT_MAP.containsKey(c.getName())) &#123; product = (T) PRODUCT_MAP.get(c.getName()); &#125; else &#123; T t = c.newInstance(); PRODUCT_MAP.put(c.getName(), t); &#125; return product; &#125;&#125;class Product &#123;&#125;class Product1 extends Product &#123;&#125; 抽象工厂模式 Abstract Factory类图 使用场景 一个对象族（或是一组没有任何关系的对象）都有相同的约束，就可以使用抽象工厂模式。比如文本编辑器和图片处理器都是软件，但是 linux 和 windows 下文本编辑器虽然界面相同，但是代码不同，也就有了共同的约束条件——操作系统。 优点 封装性好。高层模块不关心每个产品的实现类，值关心接口。对象的创建由工厂类负责。高层模块只需要知道工厂类有哪些就行。 产品族内的约束为非公开状态。例如下面代码中约定每生产1个发动机，需要设计出3种外形与之匹配。 缺点 产品族扩展非常困难。如果新增一个产品，需要修改抽象工厂类、几个实现类，严重违反开闭原则。 注意事项 与工厂模式的区别 工厂模式用来创建同一个产品的不同类型，如汽车里的奔驰、宝马，抽象工厂模式用来创建不同类的产品，汽车工厂设计汽车造型，生产发动机等。一般来说产品种类单一适合用工厂模式，如果有多个种类各种类型，更适合用抽象工厂模式。 产品族扩展困难，产品等级扩展容易 也就是横向扩展容易，纵向扩展困难。例如下面代码新增车型奥迪，只需要新增奥迪工厂类即可。从这一点上，抽象工厂符合开闭原则。 代码演示1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465// 抽象工厂public abstract class CarFactory &#123; abstract DesignFactory designAppearance(); abstract EngineFactory produceEngine();&#125;// 产品类型abstract class DesignFactory &#123; abstract void design();&#125;abstract class EngineFactory &#123; abstract void produce();&#125;class BmwDesignFactory extends DesignFactory &#123; @Override public void design() &#123; System.out.println(\"设计宝马造型\"); &#125;&#125;class BenzDesignFactory extends DesignFactory &#123; @Override public void design() &#123; System.out.println(\"设计奔驰造型\"); &#125;&#125;class BmwEngineFactory extends EngineFactory &#123; @Override public void produce() &#123; System.out.println(\"生产宝马发动机\"); &#125;&#125;class BenzEngineFactory extends EngineFactory &#123; @Override public void produce() &#123; System.out.println(\"生产奔驰发动机\"); &#125;&#125;// 产品工厂class BmwFactory extends CarFactory &#123; @Override public DesignFactory designAppearance() &#123; return new BmwDesignFactory(); &#125; @Override public EngineFactory produceEngine() &#123; return new BmwEngineFactory(); &#125;&#125;// 测试类class Test &#123; public static void main(String[] args) &#123; BmwFactory bmwFactory = new BmwFactory(); bmwFactory.designAppearance().design(); bmwFactory.produceEngine().produce(); &#125;&#125; 建造者模式 Builder类图 使用场景 相同的方法，不同的执行顺序，产生不同的事件结果。 多个部件或零件都可以装配到一个对象中，但是产生的运行结果又不相同。 产品类非常复杂，或者产品类中的调用顺序不同产生了不同的效能。 对象创建过程中会使用到系统中的一些其他对象，这些对象在产品创建过程中不易得到时，可采用建造者模式封装该对象的创建过程。这种场景只能是一个补偿方法，因为一个对象不容易获得，在设计阶段竟然没发觉，而要通过创建者模式柔化创建过程，本身已经违反设计的最初目标。 当一个类构造器需要传入很多参数时，如果创建这个类的实例，代码可读性差，可用 builder 模式重构。如 lombok 的 @Builder 注解。 优点 封装性好。使客户端不必知道产品内部组成的细节，只关注产生的对象和要素。 建造者独立，更容易扩展。多个 builder 相互独立，对系统的扩展非常有利。 便于控制细节风险。具体建造者独立，因此可以对建造过程逐步细化，而不对其他模块产生任何影响。 注意事项 与工厂模式的区别 建造者模式最主要的功能是方法的调用顺序安排，通俗讲就是零件的装配，顺序不同对象也不同。即关注的是零件类型和装配工艺（顺序）。 工厂方法主要职责是创建零件，而不关心组装顺序。 扩展 与模板方法模式进行结合 代码演示12345678910111213141516171819202122232425262728293031323334353637public abstract class Builder &#123; public abstract void setPart(); public abstract Product build();&#125;@Dataclass Product &#123; private String name; public void doSomeThing() &#123; System.out.println(\"产品做某事\"); &#125;&#125;class ConcreteProduct extends Builder &#123; private Product product = new Product(); @Override public void setPart() &#123; product.setName(\"默认名字\"); &#125; @Override public Product build() &#123; return product; &#125;&#125;class Director &#123; private Builder builder; public Director(Builder builder) &#123; this.builder = builder; &#125; public Product getBuilder() &#123; builder.setPart(); return builder.build(); &#125;&#125;class Client &#123; public static void main(String[] args) &#123; Director director = new Director(new ConcreteProduct()); Product product = director.getBuilder(); product.doSomeThing(); &#125;&#125; 原型模式 Prototype使用场景 资源优化场景。类初始化消耗较多资源，包括数据、硬件等。 性能和安全要求的场景。避免通过 new 产生一个对象需要非常繁琐的数据准备或访问权限。 一个对象多个修改者的场景。拷贝多个对象供各个调用者使用。 原型模式一般与工厂方法模式一起使用，通过 clone 方法创建一个对象，然后由工厂方法提供给调用者。 优点 性能优良。内存二进制流的拷贝，比直接 new 一个对象性能好很多，特别是在循环体内产生大量对象。 逃避构造函数的约束。直接内存拷贝，不会执行构造函数，即使是 private 也可以克隆。双刃剑。 注意事项 构造函数不会被执行 深拷贝和浅拷贝 使用原型模式时，引用的成员变量必须满足两个条件才不会被拷贝：一是类的成员变量，而不是方法内变量；二必须时一个可变得引用对象，而不是原始类型或不可变对象。 深拷贝和浅拷贝建议不要混合使用，特别是涉及类的继承时，父类有多个引用的情况就非常复杂，建议深拷贝和浅拷贝分开实现。 clone 与 final 有冲突。要使用 clone，类成员变量上就不能加 final 修饰。 代码演示 构造函数不执行 12345678910111213141516public class Prototype implements Cloneable &#123; public Prototype() &#123; System.out.println(\"构造函数被执行。。\"); &#125; @Override protected Prototype clone() throws CloneNotSupportedException &#123; return (Prototype) super.clone(); &#125;&#125;class Client &#123; public static void main(String[] args) throws CloneNotSupportedException &#123; Prototype prototype = new Prototype(); Prototype clone = prototype.clone(); &#125;&#125; 深拷贝与浅拷贝 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// 浅拷贝class LightClone implements Cloneable &#123; private List&lt;String&gt; list = new ArrayList&lt;&gt;(); @Override protected LightClone clone() throws CloneNotSupportedException &#123; return (LightClone) super.clone(); &#125; public void addValue(String value) &#123; list.add(value); &#125; public List&lt;String&gt; getValueList() &#123; return this.list; &#125;&#125;class Client1 &#123; public static void main(String[] args) throws CloneNotSupportedException &#123; LightClone origin = new LightClone(); origin.addValue(\"111\"); LightClone clone = origin.clone(); clone.addValue(\"222\"); System.out.println(origin.getValueList()); System.out.println(clone.getValueList()); System.out.println(origin.getValueList() == clone.getValueList()); &#125;&#125;// 深拷贝class DeepClone implements Cloneable &#123; private ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); @Override protected DeepClone clone() throws CloneNotSupportedException &#123; DeepClone clone = (DeepClone) super.clone(); clone.list = (ArrayList&lt;String&gt;) clone.list.clone(); return clone; &#125; public void addValue(String value) &#123; list.add(value); &#125; public List&lt;String&gt; getValueList() &#123; return this.list; &#125;&#125;class Client2 &#123; public static void main(String[] args) throws CloneNotSupportedException &#123; DeepClone origin = new DeepClone(); origin.addValue(\"111\"); DeepClone clone = origin.clone(); clone.addValue(\"222\"); System.out.println(origin.getValueList()); System.out.println(clone.getValueList()); System.out.println(origin.getValueList() == clone.getValueList()); &#125;&#125; 增加 final 的拷贝 1234567891011public class FinalClone implements Cloneable &#123; private final ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); @Override protected FinalClone clone() throws CloneNotSupportedException &#123; FinalClone clone = (FinalClone) super.clone(); // 下面这行代码报错 // clone.list = (ArrayList&lt;String&gt;) this.list.clone(); return clone; &#125;&#125;","categories":[],"tags":[{"name":"book","slug":"book","permalink":"https://melodyplayer.github.io/blog/tags/book/"}]},{"title":"大型网站技术架构","slug":"大型网站技术架构","date":"2019-11-17T13:32:29.000Z","updated":"2019-12-16T12:54:44.016Z","comments":true,"path":"blog/2019/1117:大型网站技术架构/","link":"","permalink":"https://melodyplayer.github.io/blog/2019/1117:大型网站技术架构/","excerpt":"不逼自己一把，可能连本书都没时间看。。 终于把李智慧大佬的《大型网站技术架构——核心原理与案例分析》看完了，顺便梳理了全书脉络。本书出版于2013年，正是web系统登峰造极之时，尽管移动互联网相关内容缺席，但是系统架构的主题思想仍然是沿用的，即便是5G时代为可能出现的物联网信息大爆炸而设计的服务器系统。因此放眼现在，该书也是系统架构设计入门不可多得的“武功秘籍”。 文末会列出一些对该书的思考，欢迎大家在评论区一起探讨优秀的系统架构设计。","text":"不逼自己一把，可能连本书都没时间看。。 终于把李智慧大佬的《大型网站技术架构——核心原理与案例分析》看完了，顺便梳理了全书脉络。本书出版于2013年，正是web系统登峰造极之时，尽管移动互联网相关内容缺席，但是系统架构的主题思想仍然是沿用的，即便是5G时代为可能出现的物联网信息大爆炸而设计的服务器系统。因此放眼现在，该书也是系统架构设计入门不可多得的“武功秘籍”。 文末会列出一些对该书的思考，欢迎大家在评论区一起探讨优秀的系统架构设计。 大型网站架构演化发展历程 大型网站架构模式 大型网站核心架构要素 思考 大型网站发展历程 补充后期淘宝系统架构发展历史：分布式系统之后，应用自研的OceanBase数据库，使用云计算、混合云，服务容器化等技术。 虽然文中没有提及微服务这个名词，事实上思想已经存在。 分布式中间件的应用 在该书出版后的短短6年，各项技术如雨后春笋出现在大众视野，其中很多分布式中间件已经发展到非常成熟的地步，应用十分广泛。 分布式缓存：现阶段主流应用层缓存为redis，尤其是redis-cluster模式，在memcached的互不通信的基础上，增加了主从功能，从而实现数据分片和备份。 分布式消息中间件：ActiveMQ没落，RocketMQ和Kafka盛行，RabbitMQ仍有一席之地。 前端缓存 补充一下移动互联网时代的前端缓存，举个典型的优化案例，网易云音乐的评论系统，用户在评论后点击确定立即看到了自己的评论，其实是缓存在手机app上的信息，而真正的信息此时可能刚刚进入消息队列，并没有持久化到数据库中。 线程池参数定义 此处需要更正，现阶段的线程池个数设置遵循以下规则： 计算密集型任务，N=CPU数量+1 IO密集型任务，N=CPU数量 * CPU利用率 * （1 + 线程等待时间/线程CPU时间）","categories":[],"tags":[{"name":"book","slug":"book","permalink":"https://melodyplayer.github.io/blog/tags/book/"}]},{"title":"正则表达式进阶用法与真实调优案例","slug":"正则表达式进阶用法与真实调优案例","date":"2019-10-17T09:55:38.000Z","updated":"2019-11-02T18:00:42.482Z","comments":true,"path":"blog/2019/1017:正则表达式进阶用法与真实调优案例/","link":"","permalink":"https://melodyplayer.github.io/blog/2019/1017:正则表达式进阶用法与真实调优案例/","excerpt":"正则表达式并不陌生，但当面对复杂的正则表达式：长度长，特殊符号多，多分组的情况下，解析速度会怎样？","text":"正则表达式并不陌生，但当面对复杂的正则表达式：长度长，特殊符号多，多分组的情况下，解析速度会怎样？ 正则表达式基础为节省版面直击要害，基础内容本文不作赘述，请点击以下链接查看： 表达式全集 史上最全常用正则表达式大全 真实案例：超级慢的正则表达式常用的正则表达式一般几秒内解析完毕，那么见过3分钟都没解析出来的正则表达式吗？请往下看： 解析目标过滤请求中不合法的 uri（不包含参数），如包含特殊符号- = + % ?、多个斜杠//、中文等。 代码实现正则表达式：&quot;^(/?[A-Za-z0-9\\\\-]+/?[A-Za-z0-9\\\\-]+)+/?&quot; 编写 java 代码： 12345678910111213// 所有方法设置成静态的，方便 main 调用private static final Pattern URI_PATTERN = Pattern.compile(\"^(/?[A-Za-z0-9\\\\-]+/?[A-Za-z0-9\\\\-]+)+/?)\";public static boolean validateUri(String uri) &#123; Matcher m = URI_PATTERN.matcher(uri); return m.matches();&#125;public static void validate() &#123; System.out.println(\"开始。。。。。。\"); System.out.println(validateUri(\"/hotel/getUseraaaaaaaasdfasdfasdfasdfasdf+\")); System.out.println(\"结束。。。。。。\");&#125; 执行 validate 方法。 测试结果6C32G mac pro 跑了3分钟没跑完。。没耐心继续等待，直接中断。 最简单的解决方案简化正则表达式为：^/?([-A-Za-z0-9]/?)+$ 但是我们需要知道为什么？如果就想在原来的基础上做修改，该怎么办？ 原因探索：回溯匹配猜测：考虑字符太长，以及特殊符号的问题测试1：把 uri 中间的 aaaaaasdfsdf 等去掉后，只保留简单的 /hotel/getUser+，很明显速度提上来了。 测试2：把 uri 中的 + 号提前，变成 /hotel/getUser+aaaaaaaasdfasdfasdfasdfasdf，速度也很快。 初步结论：非匹配字符的位置会影响正则表达式的执行效率为此需要知道正则表达式的执行规则：回溯。 比如要匹配的字符串是 helloworld,hihaojava 正则表达式是 h(ello|ihao)java 匹配过程： 从字符串第一个字符 h 开始匹配，可以命中。 接下来的匹配正则有2个分支 ello 和 ihao 。在 e 处打标记，先从左边的 ello 开始匹配，可以匹配字符串，但是到了 world 的 w 时，与正则中的 j 不一致，该分支匹配结束。接着回溯到刚刚的标记处，开始第二个分支 ihao，无法匹配，接下来正则会从 h 开始匹配字符串。 从字符串的第二个字符 e 继续匹配，直到正则的第一个字符 h 匹配到字符串的 , 之后匹配成功。 接着正则的2个分支执行匹配，最终只有 ihao匹配成功，最终匹配到的字符串是 hihaojava。 看完了正则的匹配过程，就知道为什么前面代码中的正则匹配效率会那么低下了。每个字母都要匹配到最后的+才发现匹配失败，回溯后继续查找，如果忽略其他，只考虑字符串 getUseraaaaaaaasdfasdfasdfasdfasdf+ 和正则 [-A-Za-z0-9] 的影响，时间复杂度就已经为 n^2，类似于以下模拟代码： 12345678910111213141516171819// 模拟代码，真实情况远比这个复杂，这里仅为了方便理解public static boolean execute(String s) &#123; String reg = \"-ABCDEFGHIJKMLNOPQRSTUVWSYZabcdefghijkmlnopqrstuvwsyz0123456789\"; int i = 0, count = 0; int length = s.length(); for (; i &lt; length; i++) &#123; for (int j = 0; j &lt; length; j++) &#123; count ++; String idx = s.substring(j, j + 1); if (!reg.contains(idx)) &#123; System.out.println(\"匹配失败！特殊字符：\" + idx); break; &#125; System.out.println(\"匹配字符：\" + idx); &#125; &#125; System.out.println(\"一共匹配了 \" + count + \"次！字符串长度为 \" + length); return i != length;&#125; 解决方法：采用进阶匹配模式正则模式：贪婪、勉强、侵占假定字符串为：aahelloworldhello 贪婪模式（.*he）：将正则分为两个模式 p1 .* 以及 p2 wo 。 第一轮匹配：p1读入所有字符串，那么p2就没什么都没匹配到。 第二轮匹配：字符串被分割为 aahelloworldhell 和 o，p1匹配子串1成功，p2匹配子串2失败。 直到字符串分割为 aahelloworld 和 hello时，两个正则模式都匹配成功。匹配到的子串为aahelloworldhe，停止匹配，返回结果。 勉强模式（.*?he）：最小匹配方式。此时的正则模式为 .*? 和 wo。 第一次匹配：p1由于是0或任意次，被忽略，用字符串整体去匹配 p2，当然失败。 第二次匹配：p1读入第一个字符 a，匹配成功，剩余的 ahelloworldhello 由 p2匹配，失败。 直到字符串分割为 aa 和 helloworldhello，两个正则模式都匹配成功。匹配子串 aahe，返回结果。 继续匹配，直到字符串分隔为 lloworld 和 hello，匹配子串 lloworldhe，返回结果。 侵占模式（.*+he）：也叫占用模式。匹配开始时读入所有字符串和 p1匹配成功，但没有剩余字符串去和 p2匹配，因此返回匹配失败。 说明：贪婪模式和占有模式相比，贪婪模式会在只有部分匹配成功的条件下，依次从多到少减少匹配成功部分模式的匹配数量，将字符留给模式其他部分去匹配。而占用模式则是占有所有能匹配成功部分，绝不留给其他部分使用。 代码演示1234567891011121314151617181920212223public static final Pattern PATTERN_GREEDY = Pattern.compile(\".*he\");public static final Pattern PATTERN_FORCED = Pattern.compile(\".*?he\");public static final Pattern PATTERN_OCCUPIED = Pattern.compile(\".*+he\");public static void execute() &#123; String s = \"aahelloworldhello\"; Matcher greedy = PATTERN_GREEDY.matcher(s); while (greedy.find()) &#123; System.out.println(\"贪婪模式：匹配到子串 \" + greedy.group()); System.out.println(\"贪婪模式：查找匹配到的子串在原始串中的索引位置 \" + greedy.start()); System.out.println(\"贪婪模式：查找匹配到的子串最后一个字符串在原串中的位置 \" + greedy.end()); &#125; Matcher forced = PATTERN_FORCED.matcher(s); while (forced.find()) &#123; System.out.println(\"勉强模式：匹配到子串 \" + forced.group()); System.out.println(\"勉强模式：查找匹配到的子串在原始串中的索引位置 \" + forced.start()); System.out.println(\"勉强模式：查找匹配到的子串最后一个字符串在原串中的位置 \" + forced.end()); &#125; Matcher occupied = PATTERN_OCCUPIED.matcher(s); System.out.println(\"侵占模式：匹配原串任意位置返回的结果： \" + occupied.find());&#125; 返回的结果： 123456789101112贪婪模式：匹配到子串 aahelloworldhe贪婪模式：查找匹配到的子串在原始串中的索引位置 0贪婪模式：查找匹配到的子串最后一个字符串在原串中的位置 14 勉强模式：匹配到子串 aahe勉强模式：查找匹配到的子串在原始串中的索引位置 0勉强模式：查找匹配到的子串最后一个字符串在原串中的位置 4勉强模式：匹配到子串 lloworldhe勉强模式：查找匹配到的子串在原始串中的索引位置 4勉强模式：查找匹配到的子串最后一个字符串在原串中的位置 14 侵占模式：匹配原串任意位置返回的结果： false 在这个基础上，之前的难题迎刃而解。对于判断 uri 是否合法的问题，不需要正则做回溯操作，整体不合法则返回匹配失败即可，因此选用侵占模式，需要将之前的正则表达式改进一下。 原始正则表达式：&quot;^(/?[A-Za-z0-9\\\\-]+/?[A-Za-z0-9\\\\-]+)+/?&quot; 改进后的正则表达式：&quot;^(/?[A-Za-z0-9\\\\-]++/?[A-Za-z0-9\\\\-]++)+/?&quot; 测试后发现速度变为了 ms 级，只增加 + 号，效果显而易见。 正则高级用法补充除了贪婪勉强侵占模式以外，补充一些其他的高级用法。 获取匹配 Capturing系统在幕后将所有的子模式匹配结果保存起来，供我们查找或替换。 后向引用：使用 \\数字 代表前面某个子模式的匹配内容，使用 $数字 代表变量。 例如：匹配合法的 html 标记。 正则：&lt;h([1-6])&gt;.*?&lt;/h\\1&gt; 文本：&lt;h1&gt; text1&lt;/h1&gt; &lt;h2&gt;text23&lt;/h3&gt; 其中 &lt;h1&gt;text1&lt;/h1&gt; 被成功匹配。\\1代表前面的子模式([1-6])的匹配结果1。 常见应用：匹配重复单词 (\\w+) \\1，匹配合法的 html 标记。 非获取匹配 Non-Capturing在子模式内部前面添加 ?:。表示这个子模式的匹配内容不会被保存，不能用于后向引用中。 例如：Windows 95 and Windows 98 are the successor. Then Windows 2000 and Windows Xp appeared. Windows Vista is the Latest version of the family. 正则：Windows (?:[\\w]+\\b) 匹配：Windows 95 and Windows 98 are the successor. Then Windows 2000 and Windows Xp appeared. Windows Vista is the Latest version of the family. 结果：只匹配内容，但并未保存子匹配的结果 正向肯定预查：在子模式内部前面加 ?=，子模式仅仅作为条件限制，并不作为匹配结果输出，匹配子模式前面的内容。 正则：Windows (?=[\\d]+\\b) 匹配：Windows 95 and Windows 98 are the successor. Then Windows 2000 and Windows Xp appeared. Windows Vista is the Latest version of the family. 正向否定预查：在子模式内部前面加 ?!。 正则：Windows (?![\\d]+\\b) 匹配：Windows 95 and Windows 98 are the successor. Then Windows 2000 and Windows Xp appeared. Windows Vista is the Latest version of the family. 反向肯定预查：在子模式内部前面加 ?&lt;=，匹配子模式后面的结果作为匹配结果。 例如：CNY:100.2 USD:222.1 USD:301.3 HKD:122.1 CNY:114.4 正则：(?&lt;=CNY:)\\d+\\.\\d 匹配：CNY:100.2 USD:222.1 USD:301.3 HKD:122.1 CNY:114.4 反向否定预查：在子模式内部前面加 ?&lt;! 正则：(?&lt;!CNY:)\\b\\d+\\.\\d 匹配：CNY:100.2 USD:222.1 USD:301.3 HKD:122.1 CNY:114.4 代码演示 获取匹配 12String s = \"abc def aaa bbb\".replaceAll(\"(\\\\w+)\\\\s(\\\\w+)\", \"$2 $1\");// 结果是 def abc bbb aaa 非获取匹配 12345678910111213141516171819202122232425262728293031323334353637383940public static final Pattern PATTERN = Pattern.compile(\"Windows (?:[\\\\w]+\\\\b)\");public static final Pattern PATTERN_POSITIVE_YES = Pattern.compile(\"Windows (?=[\\\\d]+\\\\b)\");public static final Pattern PATTERN_POSITIVE_NO = Pattern.compile(\"Windows (?![\\\\d]+\\\\b)\");public static final Pattern PATTERN_NEGATIVE_YES = Pattern.compile(\"(?&lt;=CNY:)\\\\d+\\\\.\\\\d+\");public static final Pattern PATTERN_NEGATIVE_NO = Pattern.compile(\"(?&lt;!CNY:)\\\\b\\\\d+\\\\.\\\\d+\");public static final String STR1 = \"Windows 95 and Windows 98 are the successor. Then Windows 2000 and Windows Xp appeared. Windows Vista is the Latest version of the family.\";public static final String STR2 = \"CNY:100.25 USD:222.16 USD:301.3 HKD:122.1 CNY:114.4\";public static void execute() &#123; Matcher noCapturing = PATTERN.matcher(STR1); System.out.println(\"\\n非获取匹配结果：---------\"); while (noCapturing.find()) &#123; System.out.print(noCapturing.group() + \"\\t\"); &#125; Matcher positiveYes = PATTERN_POSITIVE_YES.matcher(STR1); System.out.println(\"\\n正向肯定预查结果：---------\"); while (positiveYes.find()) &#123; System.out.print(positiveYes.group() + \"\\t\"); &#125; Matcher positiveNo = PATTERN_POSITIVE_NO.matcher(STR1); System.out.println(\"\\n正向否定预查结果：---------\"); while (positiveNo.find()) &#123; System.out.print(positiveNo.group() + \"\\t\"); &#125; Matcher negativeYes = PATTERN_NEGATIVE_YES.matcher(STR2); System.out.println(\"\\n负向肯定预查结果：---------\"); while (negativeYes.find()) &#123; System.out.print(negativeYes.group() + \"\\t\"); &#125; Matcher negativeNo = PATTERN_NEGATIVE_NO.matcher(STR2); System.out.println(\"\\n负向否定预查结果：---------\"); while (negativeNo.find()) &#123; System.out.print(negativeNo.group() + \"\\t\"); &#125;&#125; 运行结果： 12345678910非获取匹配结果：---------Windows 95 Windows 98 Windows 2000 Windows Xp Windows Vista正向肯定预查结果：---------Windows Windows Windows正向否定预查结果：---------Windows Windows负向肯定预查结果：---------100.25 114.4负向否定预查结果：---------222.16 301.3 122.1","categories":[],"tags":[{"name":"general","slug":"general","permalink":"https://melodyplayer.github.io/blog/tags/general/"}]},{"title":"mac单机部署mysql多实例","slug":"mac单机部署mysql多实例","date":"2019-10-03T19:04:45.000Z","updated":"2019-11-02T11:34:43.907Z","comments":true,"path":"blog/2019/1004:mac单机部署mysql多实例/","link":"","permalink":"https://melodyplayer.github.io/blog/2019/1004:mac单机部署mysql多实例/","excerpt":"单机部署mysql多实例，需要用到 mysql 自带的 mysqld_multi 命令，在目录 support_files 下有 mysqld_multi.server 命令封装。","text":"单机部署mysql多实例，需要用到 mysql 自带的 mysqld_multi 命令，在目录 support_files 下有 mysqld_multi.server 命令封装。 mysql 版本：5.7.27单机多实例配置手动创建 my.cnf 文件mac 使用 dmg 文件直接安装，不会自动生成 my.cnf 文件，需要手动创建。 12345678910111213[mysqld_multi]mysqld = /usr/local/mysql/bin/mysqld_safemysqladmin = /usr/local/mysql/bin/mysqladminuser = rootpassword = root[mysqld1]socket = /tmp/mysql.sock1port = 3311pid-file = /usr/local/var/mysql/data/data1/hostname.pid1datadir = /usr/local/var/mysql/data/data1language = /usr/local/mysql/share/englishuser = root 执行 mysqld_multi.server start这时会在控制台显示出生成的密码，记住待会儿会进行修改。 修改密码1mysqladmin -u root -P 3312 -p -S /tmp/mysql.sock2 password 连接 mysql1mysql -u root -p -P 3312 -S /tmp/mysql.sock2 关闭mysql123./mysqld_multi.server stop #关闭所有./mysqld_multi.server stop 1 #关闭单个./mysqld_multi.server stop 1-2 #关闭某个范围的实例 单机多实例主从配置必读：MySQL的主从复制介绍及配置 具体执行顺序按照链接中的顺序操作即可。这里只谈在操作中采的坑以及核心要点。 不要在命令行直接输入密码，例如：mysql -u root -p &#39;root&#39; -P 3312 -S /tmp/mysql.sock2 解决方法：去掉-p后的 ‘root’。mysql -u root -p -P 3312 -S /tmp/mysql.sock2 从库Slave_IO_Running: Connecting 问题 12Slave_IO_Running: ConnectingSlave_SQL_Running: Yes 解决方法：这个问题多半是未连接到主库专门用来复制的用户，检查用户名，用户权限等。 主库备份问题 关键在于了解参数的意义，可以指定某个数据库进行备份，也可以-A全部备份。 1mysqldump -u root -p -S /tmp/mysql/mysql.sock1 -A &gt; mysql_bak.2019-10-06.sql","categories":[],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://melodyplayer.github.io/blog/tags/mysql/"}]},{"title":"线程池invokeAll方法详解","slug":"线程池invokeAll方法详解","date":"2019-08-10T13:23:50.000Z","updated":"2019-08-10T16:56:08.594Z","comments":true,"path":"blog/2019/0810:线程池invokeAll方法详解/","link":"","permalink":"https://melodyplayer.github.io/blog/2019/0810:线程池invokeAll方法详解/","excerpt":"线上真实案例，多次调用线程池 ThreadPoolExecutor 的 invokeAll() 方法进行数据统计时任务被拒绝，故事从此开始。 本文重在讲述问题的产生、抽象、寻找解决方法的过程，并结合源码对原因进行抽丝剥茧般的分析。bug 千千万万，唯有合理的逻辑推理思维才能让这些 bug 显露原形。","text":"线上真实案例，多次调用线程池 ThreadPoolExecutor 的 invokeAll() 方法进行数据统计时任务被拒绝，故事从此开始。 本文重在讲述问题的产生、抽象、寻找解决方法的过程，并结合源码对原因进行抽丝剥茧般的分析。bug 千千万万，唯有合理的逻辑推理思维才能让这些 bug 显露原形。 问题起源与抽象先来看一段简单的代码，定义一个核心线程数5、有界队列5的线程池，然后创建10个任务丢进去执行2次。 按照以前对线程池执行逻辑的理解，创建的10个线程，会先交给核心线程去执行，5个核心线程满了之后，存放到队列中，刚好存储剩下的5个，按理说10个任务都会正常执行完毕。本次只测试固定大小的线程池。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class InvokeAllTest &#123; private static ThreadPoolExecutor executor = new ThreadPoolExecutor(5, 5, 60 * 1000, TimeUnit.SECONDS, new ArrayBlockingQueue&lt;&gt;(5), new MyThreadFactory()); public static void main(String[] args) &#123; List&lt;Callable&lt;Void&gt;&gt; tasks = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 10; i++) &#123; tasks.add(new InvokeAllThread()); &#125; System.out.println(\"第一次任务执行前的executor： \" + executor); try &#123; executor.invokeAll(tasks); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(\"第一次任务执行完毕后的executor： \" + executor); System.out.println(\"==============第一次任务执行完毕，开始第二次任务============\"); try &#123; Thread.sleep(1000); executor.invokeAll(tasks); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(\"第二次任务执行完毕后的executor：\" + executor); &#125; // 任务执行线程。通过打印线程名称，观察提交的任务被哪个线程执行 static class InvokeAllThread implements Callable&lt;Void&gt; &#123; @Override public Void call() throws Exception &#123; System.out.println(Thread.currentThread().getName()); return null; &#125; &#125; // 给工作线程自定义名字，方便观察提交的任务被哪个线程执行 static class MyThreadFactory implements ThreadFactory &#123; private AtomicInteger threadNum = new AtomicInteger(1); @Override public Thread newThread(Runnable r) &#123; Thread thread = new Thread(r, String.valueOf(threadNum.getAndIncrement())); if (thread.getPriority() != Thread.NORM_PRIORITY) &#123; thread.setPriority(Thread.NORM_PRIORITY); &#125; return thread; &#125; &#125; 运行程序后发现，第一次调用 invokeAll 正常执行，第二次调用报错。多次执行结果相同。 123456789101112131415161718192021222324第一次任务执行前的executorjava.util.concurrent.ThreadPoolExecutor@30f39991[Running, pool size = 0, active threads = 0, queued tasks = 0, completed tasks = 0]1234453233第一次任务执行完毕后的executorjava.util.concurrent.ThreadPoolExecutor@30f39991[Running, pool size = 5, active threads = 0, queued tasks = 0, completed tasks = 10]==============第一次任务执行完毕，开始第二次任务============24521Exception in thread \"main\" java.util.concurrent.RejectedExecutionException: Task java.util.concurrent.FutureTask@3a71f4dd rejected from java.util.concurrent.ThreadPoolExecutor@30f39991[Running, pool size = 5, active threads = 2, queued tasks = 0, completed tasks = 13] at java.util.concurrent.ThreadPoolExecutor$AbortPolicy.rejectedExecution(ThreadPoolExecutor.java:2063) at java.util.concurrent.ThreadPoolExecutor.reject(ThreadPoolExecutor.java:830) at java.util.concurrent.ThreadPoolExecutor.execute(ThreadPoolExecutor.java:1379) at java.util.concurrent.AbstractExecutorService.invokeAll(AbstractExecutorService.java:238) at com.aaron.hp.thread.pool.InvokeAllTest.main(InvokeAllTest.java:36) 问题排查与猜测既然程序出现异常，就该调用 debug 模式进行排查，并遵循”大胆猜测，小心求证”的态度，去解决这个问题。 猜测一：invokeAll 在异步执行后会不会同步等待线程执行完毕获取最终结果由于 invokeAll 封装的太好，之前只知道最后会同步等待才能获取返回值。那么现在就需要去证实这个概念。 进入 invokeAll 方法后，发现调用了f.get()，那么毫无疑问，这个猜测可以排除掉了。 其实从执行过程的输出内容也可以看出，两次调用 invokeAll 的执行顺序和界限(打印语句) 非常明显。 1234567891011121314151617181920212223242526272829303132public &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks) throws InterruptedException &#123; if (tasks == null) throw new NullPointerException(); ArrayList&lt;Future&lt;T&gt;&gt; futures = new ArrayList&lt;Future&lt;T&gt;&gt;(tasks.size()); boolean done = false; try &#123; for (Callable&lt;T&gt; t : tasks) &#123; RunnableFuture&lt;T&gt; f = newTaskFor(t); futures.add(f); // 任务被添加后的具体执行 execute(f); &#125; for (int i = 0, size = futures.size(); i &lt; size; i++) &#123; Future&lt;T&gt; f = futures.get(i); if (!f.isDone()) &#123; try &#123; // 此处同步等待 f.get(); &#125; catch (CancellationException ignore) &#123; &#125; catch (ExecutionException ignore) &#123; &#125; &#125; &#125; done = true; return futures; &#125; finally &#123; if (!done) for (int i = 0, size = futures.size(); i &lt; size; i++) futures.get(i).cancel(true); &#125;&#125; 猜测二：队列里面可能存在第一次调用 invokeAll 执行了但没有删掉的任务，所以才会导致第二次放入队列失败由于未阅读源码，猜测只有当创建的任务执行完毕并且销毁之后，才会从队列中真正移除。 那么就需要查看入队列和出队列的时机。查看 invokeAll 方法中的 execute(f) 方法。 查看 ThreadPoolExecutor 类下的 execute 方法源码： 12345678910111213141516171819202122public void execute(Runnable command) &#123; if (command == null) throw new NullPointerException(); int c = ctl.get(); // 判断工作线程数是否小于核心线程数，如果是则创建 Worker 工作线并返回 if (workerCountOf(c) &lt; corePoolSize) &#123; if (addWorker(command, true)) return; c = ctl.get(); &#125; // 判断主线程是否在运行，并判断是否入队列成功 if (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123; int recheck = ctl.get(); if (! isRunning(recheck) &amp;&amp; remove(command)) reject(command); else if (workerCountOf(recheck) == 0) addWorker(null, false); &#125; // 否则重新创建 Worker 线程，创建失败则抛出拒绝策略 else if (!addWorker(command, false)) reject(command);&#125; 此时就会发现入队列的操作在workQueue.offer(command)处完成，而我们提交的任务是由一个叫 Worker 类的实例来执行，addWorker(command, true)创建 Worker 实例。 那么我们就分别进去这两个方法来看下源码： 矮油黑人问号脸。。没想到这个 ThreadPoolExecutor 类的 addWorker 这么长，给核心代码写个注释重点关注，扫一眼然后去看 offer 方法(英文注释是源码中自带的)。前面都是校验，创建核心线程处为new Worker(firstTask)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869private boolean addWorker(Runnable firstTask, boolean core) &#123; retry: for (;;) &#123; int c = ctl.get(); int rs = runStateOf(c); // Check if queue empty only if necessary. if (rs &gt;= SHUTDOWN &amp;&amp; ! (rs == SHUTDOWN &amp;&amp; firstTask == null &amp;&amp; ! workQueue.isEmpty())) return false; for (;;) &#123; int wc = workerCountOf(c); if (wc &gt;= CAPACITY || wc &gt;= (core ? corePoolSize : maximumPoolSize)) return false; if (compareAndIncrementWorkerCount(c)) break retry; c = ctl.get(); // Re-read ctl if (runStateOf(c) != rs) continue retry; // else CAS failed due to workerCount change; retry inner loop &#125; &#125; boolean workerStarted = false; boolean workerAdded = false; Worker w = null; try &#123; // 上面一堆都是校验，此处才是 Worker 被创建的地方，注意被传入的 firstTask w = new Worker(firstTask); // 此处发现 Worker 里面居然还有个 therad 线程，不过想想也是，没有线程怎么异步执行呢。点进 Worker 的构造方法看一眼就会发现，这个线程就是由我们自定义的 threadFactory 来创建的，所以核心线程名称就是我们之前设定好的名字。this.thread = getThreadFactory().newThread(this); final Thread t = w.thread; if (t != null) &#123; final ReentrantLock mainLock = this.mainLock; mainLock.lock(); try &#123; // Recheck while holding lock. // Back out on ThreadFactory failure or if // shut down before lock acquired. int rs = runStateOf(ctl.get()); if (rs &lt; SHUTDOWN || (rs == SHUTDOWN &amp;&amp; firstTask == null)) &#123; if (t.isAlive()) // precheck that t is startable throw new IllegalThreadStateException(); workers.add(w); int s = workers.size(); if (s &gt; largestPoolSize) largestPoolSize = s; workerAdded = true; &#125; &#125; finally &#123; mainLock.unlock(); &#125; if (workerAdded) &#123; // worker 实例成功创建后，让它启动起来 t.start(); workerStarted = true; &#125; &#125; &#125; finally &#123; if (! workerStarted) addWorkerFailed(w); &#125; return workerStarted;&#125; 接着是 ArrayBlockingQueue 类的 offer 方法，在 enqueue(e)处进入队列： 12345678910111213141516public boolean offer(E e) &#123; checkNotNull(e); final ReentrantLock lock = this.lock; lock.lock(); try &#123; if (count == items.length) return false; else &#123; // 进入队列 enqueue(e); return true; &#125; &#125; finally &#123; lock.unlock(); &#125;&#125; 此时我们先来调试一波，看看入队列时这些方法的执行情况，在三个 if 处分别设置断点，在 addWorker 和 offer 方法靠前的未知打断点，确定是否会进入。 第一次调用 invokeAll：addWorker 进入5次，offer 方法进入5次。 第二次调用 invokeAll：addWorker 进入0次，offer 方法进入10次（可能是5-10次）。 那么发现了新的问题：程序居然没报错！正常执行完成！这不科学！ 带着疑惑，重新 debug，居然还没报错！难道之前的异常是偶然吗？ 以最快速度连按 F9 debug了几次，有时候报错。。 重新运行 run 了几次，次次报错。。 怀疑人生了。。 此时墨菲定律在我头脑中回响，”偶然事件存在必然的因素”。那么大胆猜测，这个原因极有可能是队列消费速度较慢导致的，去查看消费部分的源码。由于 worker 也是一个线程，那么肯定有类似的 run 方法： 查看 ThreadPoolExecutor 类 的 Worker 这个内部类，找到 run() 方法： 123public void run() &#123; runWorker(this);&#125; 而 run 方法调用的是 ThreadPoolExecutor 类里的 runWorker(this)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748final void runWorker(Worker w) &#123; Thread wt = Thread.currentThread(); // 此处注意，将 worker 里存入的 firstTask 取出来，交给下面的 while 去执行 Runnable task = w.firstTask; // 将 worker 里的 firstTask 属性置空 w.firstTask = null; w.unlock(); // allow interrupts boolean completedAbruptly = true; try &#123; // 如果 task 不为空，即取出的 firstTask 不为空，则执行；否则调用 getTask() 方法获取 task 再执行 while (task != null || (task = getTask()) != null) &#123; w.lock(); // If pool is stopping, ensure thread is interrupted; // if not, ensure thread is not interrupted. This // requires a recheck in second case to deal with // shutdownNow race while clearing interrupt if ((runStateAtLeast(ctl.get(), STOP) || (Thread.interrupted() &amp;&amp; runStateAtLeast(ctl.get(), STOP))) &amp;&amp; !wt.isInterrupted()) wt.interrupt(); try &#123; // 此处为空实现，可自定义 beforeExecute(wt, task); Throwable thrown = null; try &#123; // 调用 task 的 run 方法执行任务 task.run(); &#125; catch (RuntimeException x) &#123; thrown = x; throw x; &#125; catch (Error x) &#123; thrown = x; throw x; &#125; catch (Throwable x) &#123; thrown = x; throw new Error(x); &#125; finally &#123; afterExecute(task, thrown); &#125; &#125; finally &#123; task = null; w.completedTasks++; w.unlock(); &#125; &#125; completedAbruptly = false; &#125; finally &#123; processWorkerExit(w, completedAbruptly); &#125;&#125; 查看 ThreadPoolExecutor 类下的 getTask() 方法： 1234567891011121314151617181920212223242526272829303132333435363738private Runnable getTask() &#123; boolean timedOut = false; // Did the last poll() time out? for (;;) &#123; int c = ctl.get(); int rs = runStateOf(c); // Check if queue empty only if necessary. if (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123; decrementWorkerCount(); return null; &#125; int wc = workerCountOf(c); // Are workers subject to culling? boolean timed = allowCoreThreadTimeOut || wc &gt; corePoolSize; if ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut)) &amp;&amp; (wc &gt; 1 || workQueue.isEmpty())) &#123; if (compareAndDecrementWorkerCount(c)) return null; continue; &#125; try &#123; // 此处为出队列操作，poll 和 take 的区别在于，poll 会等待指定时间，而 take 是阻塞的，会一直等待 Runnable r = timed ? workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) : workQueue.take(); if (r != null) return r; timedOut = true; &#125; catch (InterruptedException retry) &#123; timedOut = false; &#125; &#125;&#125; 看到这里，猜测二也就不攻自破，出队列后任务才会被执行，所以某个任务出队列后，执行成功与否与队列再无瓜葛。(注意这个说法只针对默认代码，如果自定义了拒绝策略是可以将被 interrupt 的线程重新塞回队列里的) 两次猜测失败后的总结 队列是异步消费的，但入队是同步进行的，如果队列的容量不足以承载要存入队列的任务数，就会被拒绝。(虽然是 ArrayBlockQueue 的特性，但这是通过 debug 以及 run 后观察到的) 第一次 addWorker 方法执行了5次，offer 执行了5次；第二次则是 0 次，10 次。刚才忽略了这个细节，那么需要重新找到相应的源码阅读。 任务从队列中移除与任务是否执行完毕无关，先移除，后执行。 我们创建的任务，是由 worker 核心线程去调用任务的 run 方法来同步执行的，而不是调用任务实例的 start 去异步执行，这也就是为什么 invokeAll 可以获取到返回值的原因所在。 备注：这里有点绕，任务实例指的是我们最开始在 for 循环中创建的10个tasks new InvokeAllThread()，为什么继承了 Callable 明明改写的是 call()方法，但却有 run()方法可以被调用呢？这是因为在 invokeAll()方法执行execute()方法前，通过RunnableFuture&lt;T&gt; f = newTaskFor(t);进行了包装。 复查源码，真相大白查看 ThreadPoolExecutor 类下的 execute() 方法，创建 worker 前的判断如下： 1if (workerCountOf(c) &lt; corePoolSize) &#123; ...&#125; 第一次调用 invokeAll 时，线程池中的核心线程 worker 数为0，小于 corePoolSize，所以前5次会创建 worker 核心线程并返回，此时随着 worker 的创建，我们创建的10个任务中的5个也会随着 worker 的创建作为 firstTask 属性被传进去。后5个任务则被放入 queue 中。 第二次调用 invokeAll 时，线程池中的核心数已经是5，所以10个任务都会被放入 queue 中异步消费，但是我们的 queue 的容量为5。如果消费速度快于入队速度(debug)，那么10个任务会正常执行。但是入队速度太快的话(run)，前5个肯定可以入队，后面的5个几乎都会被拒绝。 问题解决方案 对于固定大小的线程池，我们要按照实际情况设置 queue 和 worker 的数量。根据任务类型（IO/CPU）以及机器配置（CPU 核数等）设置 worker 核心线程数；而根据我们的任务多少来设定 queue 的大小，而不是 queue + worker 的总数。 重写拒绝策略，将被丢弃的任务重新 put 回队列中去，put 是阻塞的。 参考ThreadPoolExecutor源码分析及阻塞提交任务方法 Thread的中断机制(interrupt)","categories":[],"tags":[{"name":"java","slug":"java","permalink":"https://melodyplayer.github.io/blog/tags/java/"}]},{"title":"搭建博客要点","slug":"搭建博客要点","date":"2019-07-19T07:23:43.000Z","updated":"2019-07-20T06:25:12.055Z","comments":true,"path":"blog/2019/0719:搭建博客要点/","link":"","permalink":"https://melodyplayer.github.io/blog/2019/0719:搭建博客要点/","excerpt":"跟同事一次普通的聊天，谈论到个人博客后，他帮我创建了 github 的博客雏形，从此一发不可收拾。。 一周时间，每天整到半夜2点多，终于搭建完毕。给大家分享下搭建博客核心要点。","text":"跟同事一次普通的聊天，谈论到个人博客后，他帮我创建了 github 的博客雏形，从此一发不可收拾。。 一周时间，每天整到半夜2点多，终于搭建完毕。给大家分享下搭建博客核心要点。 流程参考： https://www.cnblogs.com/liuxianan/p/build-blog-website-by-hexo-github.html https://blog.csdn.net/KNIGH_YUN/article/details/79774344 github 账户创建的仓库名要采用 username.github.io 的形式，才能达到最简洁的 melodyplayer.github.io，不然网站后缀会加斜杠仓库名 “/repoName”，例如：melodyplayer.github.io/melody，增加访问复杂度。 域名绑定 记录类型 A 把域名转发到某个 ipv4 地址上。对于 github 来说可以采用这种方式，ping 一下 github 生成的默认域名拿到 ip 输入到记录值里即可，再在相应的仓库里创建 CNAME 文件。 主机记录填 www 或者不填时， 向github 里的 CNAME文件写入 www.melodyplay.cn 。 主机记录填二级域名例如 blog 时，则向github 里的 CNAME 文件写入 blog.melodyplay.cn 。 记录类型 CNAME 可以把请求转发到另外一个域名上，此时的记录值输入 melodyplayer.github.io 即可。 主题相关主题列表：https://hexo.io/themes/ 我的选择：https://xaoxuu.com/wiki/material-x/ 修改字体：https://www.zhangxinxu.com/wordpress/2017/03/css3-font-face-src-local/ hexo 命令必读：hexo 文档 12345hexo clean #清除public目录，该目录由 hexo g 生成hexo g #生成public目录，如果在source里创建非md文件，会按原样拷贝到public中，例如CNAME的创建hexo s #本地启动hexo服务hexo d #部署到远程仓库hexo new \"x\" #新建文件 hexo 配置本地调试相应的属性时，hexo 会自动编译less、ejd 等文件，可以实时看到结果。 如果要上传到多个平台的仓库下，配置形式： 12345deploy: type: git repository: github: https://github.com/melodyplayer/melodyplayer.github.io.git,master gitee: https://gitee.com/melodyplayer/melodyplayer.git,master gitee 博客使用 gitee 也可以搭建博客，创建方式类似 github 。 仓库名要与用户名一致，才能达到最简洁的 melodyplayer.gitee.io 形式。 gitee 的 ip 好像不是固定的，因此不能在域名解析时直接配置 ip，原来的 CNAME 文件也不会生效。需要通过第三方转发平台如米发做转发，然后再配置域名解析为 CNAME 的方式，但是速度惊人。。的慢。。 具体配置方式参考：https://www.jianshu.com/p/b9466c7e339b 选择图床图床选择也纠结了很久，最终选用了 github 单独仓库做图床，使用 picgo 上传图片。 picgo 可以在上传图片前修改文件名，在文件名前加目录/，变相实现图片归档。 github每个仓库容量1G。 gitee总容量5G，但是不支持图床。 其他图床：img.vim-cn.com、https://sm.ms/ 使用流程：https://xaoxuu.com/projects/vim-cn.sh/ 评论系统评论系统有很多： 参考：https://xaoxuu.com/wiki/material-x/third-party-services/index.html#%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F valine：需要拿身份证实名验证，果断放弃。不在意的朋友可以用下，应该是比较专业的。 gittalk：https://www.voidking.com/2018/07/26/deve-hexo-gitalk-comment-plugin/ gittalk可能无法创建 issue 的问题：https://github.com/viosey/hexo-theme-material/issues/622 对于我采用的主题来说，需要在 scripts 中对 id 进行 md5。 12345678910&lt;% if (enableGitalk) &#123; %&gt; &lt;script src=&quot;https://cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; var gitalk = new Gitalk(&#123; clientID: &quot;&lt;%- config.gitalk.clientID %&gt;&quot;, ...... id: md5(location.pathname), // Ensure uniqueness and length less than 50 ...... &lt;/script&gt;&lt;% &#125; %&gt; 牛人博客推荐的几个美观易读的牛人博客（临时记录在这里，后期维护到移步大佬）： xaouu：我的主题采用的他的，非常感谢。 码酱：java基础 闪烁之狐：java基础，博客排版华丽 匠心零度 程序猿 DD 纯洁的微笑 芋道源码","categories":[],"tags":[{"name":"other","slug":"other","permalink":"https://melodyplayer.github.io/blog/tags/other/"}]},{"title":"旋律演奏猿","slug":"旋律演奏猿","date":"2019-07-16T03:22:26.000Z","updated":"2019-10-17T09:47:48.735Z","comments":true,"path":"blog/2019/0716:旋律演奏猿/","link":"","permalink":"https://melodyplayer.github.io/blog/2019/0716:旋律演奏猿/","excerpt":"开始自己的第一个博客，主要记录和分享在工作和学习中用到的一些技术，也会写一些兴趣爱好的文章，分享一些好听的音乐、精彩的电影等等。集工作学习与休闲一体，秉承简单、开放、匠心的精神，演奏程序猿的生活旋律。","text":"开始自己的第一个博客，主要记录和分享在工作和学习中用到的一些技术，也会写一些兴趣爱好的文章，分享一些好听的音乐、精彩的电影等等。集工作学习与休闲一体，秉承简单、开放、匠心的精神，演奏程序猿的生活旋律。","categories":[],"tags":[{"name":"description","slug":"description","permalink":"https://melodyplayer.github.io/blog/tags/description/"}]}]}