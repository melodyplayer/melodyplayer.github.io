{"meta":{"title":"旋律演奏猿","subtitle":null,"description":"演奏程序猿的生活旋律","author":"Aaron Hu","url":"https://melodyplayer.github.io","root":"/"},"pages":[{"title":"404 Not Found","date":"2019-07-19T13:27:30.956Z","updated":"2019-07-19T11:17:18.382Z","comments":true,"path":"404.html","permalink":"https://melodyplayer.github.io/404.html","excerpt":"","text":"404 Not Found **很抱歉，您访问的页面不存在** 可能是输入地址有误或该地址已被删除"},{"title":"关于","date":"2019-07-19T13:33:52.990Z","updated":"2019-07-19T11:14:35.256Z","comments":true,"path":"about/index.html","permalink":"https://melodyplayer.github.io/about/index.html","excerpt":"","text":""},{"title":"所有分类","date":"2019-07-19T13:38:22.344Z","updated":"2019-07-19T13:38:22.341Z","comments":true,"path":"blog/categories/index.html","permalink":"https://melodyplayer.github.io/blog/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"大型网站技术架构","slug":"大型网站技术架构","date":"2019-11-17T13:32:29.000Z","updated":"2019-12-16T12:54:44.016Z","comments":true,"path":"blog/2019/1117:大型网站技术架构/","link":"","permalink":"https://melodyplayer.github.io/blog/2019/1117:大型网站技术架构/","excerpt":"不逼自己一把，可能连本书都没时间看。。 终于把李智慧大佬的《大型网站技术架构——核心原理与案例分析》看完了，顺便梳理了全书脉络。本书出版于2013年，正是web系统登峰造极之时，尽管移动互联网相关内容缺席，但是系统架构的主题思想仍然是沿用的，即便是5G时代为可能出现的物联网信息大爆炸而设计的服务器系统。因此放眼现在，该书也是系统架构设计入门不可多得的“武功秘籍”。 文末会列出一些对该书的思考，欢迎大家在评论区一起探讨优秀的系统架构设计。","text":"不逼自己一把，可能连本书都没时间看。。 终于把李智慧大佬的《大型网站技术架构——核心原理与案例分析》看完了，顺便梳理了全书脉络。本书出版于2013年，正是web系统登峰造极之时，尽管移动互联网相关内容缺席，但是系统架构的主题思想仍然是沿用的，即便是5G时代为可能出现的物联网信息大爆炸而设计的服务器系统。因此放眼现在，该书也是系统架构设计入门不可多得的“武功秘籍”。 文末会列出一些对该书的思考，欢迎大家在评论区一起探讨优秀的系统架构设计。 大型网站架构演化发展历程 大型网站架构模式 大型网站核心架构要素 思考 大型网站发展历程 补充后期淘宝系统架构发展历史：分布式系统之后，应用自研的OceanBase数据库，使用云计算、混合云，服务容器化等技术。 虽然文中没有提及微服务这个名词，事实上思想已经存在。 分布式中间件的应用 在该书出版后的短短6年，各项技术如雨后春笋出现在大众视野，其中很多分布式中间件已经发展到非常成熟的地步，应用十分广泛。 分布式缓存：现阶段主流应用层缓存为redis，尤其是redis-cluster模式，在memcached的互不通信的基础上，增加了主从功能，从而实现数据分片和备份。 分布式消息中间件：ActiveMQ没落，RocketMQ和Kafka盛行，RabbitMQ仍有一席之地。 前端缓存 补充一下移动互联网时代的前端缓存，举个典型的优化案例，网易云音乐的评论系统，用户在评论后点击确定立即看到了自己的评论，其实是缓存在手机app上的信息，而真正的信息此时可能刚刚进入消息队列，并没有持久化到数据库中。 线程池参数定义 此处需要更正，现阶段的线程池个数设置遵循以下规则： 计算密集型任务，N=CPU数量+1 IO密集型任务，N=CPU数量 * CPU利用率 * （1 + 线程等待时间/线程CPU时间）","categories":[],"tags":[{"name":"book","slug":"book","permalink":"https://melodyplayer.github.io/blog/tags/book/"}]},{"title":"《设计模式之禅》——创建型","slug":"《设计模式之禅》——创建型","date":"2019-11-11T07:23:43.000Z","updated":"2019-12-16T13:01:02.432Z","comments":true,"path":"blog/2019/1111:《设计模式之禅》——创建型/","link":"","permalink":"https://melodyplayer.github.io/blog/2019/1111:《设计模式之禅》——创建型/","excerpt":"5种创建型模式：单例、工厂、抽象工厂、建造者、原型。","text":"5种创建型模式：单例、工厂、抽象工厂、建造者、原型。 单例模式 Singleton类图 使用场景 要求生成唯一序列号的环境。 整个项目需要一个共享访问点或共享数据。例如web页面上的计数器，使用单例保持计数器的值。 创建对象需要消耗过多资源。例如访问IO和数据库等。 需要定义大量静态常量和静态方法（如工具类）的环境（也可直接声明为 static 的方式）。 优点 内存中只有一个实例，减少了内存开销。避免对象频繁的创建、销毁。 减少系统性能开销。可在应用启动时之间产生单例对象去读取配置，产生其他依赖对象等。 避免对资源的多重占用。例如写文件只由单例去完成。 设置全局访问点，优化和共享资源访问。例如由单例类负责所有数据表的映射处理。 缺点 一般没有接口，扩展困难。提供单一实例、接口或抽象类。 对测试不利。单例没有完成没法测试，业不能 mock 一个虚拟对象。 与单一职责原则由冲突。一个雷实现一个逻辑，不关心是否单例。是不是单例取决于环境，单例模式把要单例 和 业务逻辑 融合在一个类中。 注意事项 线程同步问题 高并发时，可能会出现该问题。解决办法：饿汉、懒汉、二次检查等。 对象的复制情况 如果实现了 Cloneable 接口，即使私有构造函数对象仍然可以被复制。因为克隆不需要调用类的构造函数。对于单例类最好不要实现 Cloneable 接口。 扩展 有上限的单例模式** 决定内存中有多少个实例，修正单例可能存在的性能问题，提供系统的响应速度，例如读取文件在系统启动时完成初始化工作，在内存中启动固定数量的 reader 实例，然后在需要读取文件时就可以快速响应。 代码演示1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283/** * 懒汉模式 * 线程不安全，延迟初始化，严格意义上不是不是单例模式 */public class Singleton1 &#123; private static Singleton1 instance; private Singleton1() &#123;&#125; public static Singleton1 getInstance() &#123; if (instance == null) &#123; return new Singleton1(); &#125; return instance; &#125;&#125;/** * 饿汉模式 * 线程安全，比较常用，但容易产生垃圾，因为一开始就初始化 */class Singleton2 &#123; private static Singleton2 instance = new Singleton2(); private Singleton2() &#123;&#125; public static Singleton2 getInstance() &#123; return instance; &#125;&#125;/** * 双重锁模式 * 线程安全，延迟初始化。采用双锁机制，安全且在多线程情况下能保持高性能 */class Singleton3 &#123; // 避免对象创建时可能在JVM中重排序 private volatile static Singleton3 instance; private Singleton3() &#123;&#125; public static Singleton3 getInstance() &#123; if (instance == null) &#123; synchronized (Singleton3.class) &#123; if (instance == null) &#123; instance = new Singleton3(); &#125; &#125; &#125; return instance; &#125;&#125;/** * 静态内部类单例模式 * 只有第一次调用 getInstance() 时，虚拟机才加载内部类并初始化 instance * 只有一个线程可以获得对象的初始化锁，其他线程无法进行初始化，保证对象的唯一性 * 目前此方式是所有单例模式中最推荐的模式，但具体还是根据项目选择。 */class Singleton4 &#123; private Singleton4() &#123;&#125; public static Singleton4 getInstance() &#123; return InnerClass.INSTANCE; &#125; private static class InnerClass &#123; private static final Singleton4 INSTANCE = new Singleton4(); &#125;&#125;/** * 枚举单例模式 * 默认枚举实例的创建时线程安全的，并且在任何情况下都是单例 * 实际上：枚举类隐藏了私有的构造器；枚举类的域是相应类型的一个实例对象 */enum Singleton5 &#123; INSTANCE; public static Singleton5 getInstance() &#123; return Singleton5.INSTANCE; &#125;&#125; 工厂方法模式 Factory类图 使用场景 需要灵活可扩展的框架时。比如需要设计一个链接邮件服务器的框架，有3种网络协议可选：POP3、IMAP、HTTP，作为产品类，定义接口IConnectMail，然后定义对邮件的操作方法，用不同的方法实现三个具体的产品类（连接方式），再定义一个工厂方法，按照不同的传入条件，选择不同的连接方式。 用在异构项目中。例如通过webservice与非java项目交互，虽然webservice好撑可以做到异构系统的同构化，但实际会遇到类型问题、WSDL文件的支持问题等。从WSDL中产生的对象都认为是一个产品，然后由一个具体的工厂类进行管理，减少与外围系统的耦合。 使用在测试驱动开发的框架下。例如测试类A，把与A有关联的B虚拟出来，避免A与B的耦合。该功能由于 JMock 和 EasyMock 的诞生使用场景已经弱化了。 优点 封装良好，代码结构清晰。只需知道产品类名或约束字符串，屏蔽创建过程，降低模块间的耦合。 优秀的扩展性。只需增加扩展类，无需修改工厂类。 屏蔽产品类。接口不变系统中的上层模块就不要发生变化。例如 JDBC 连接数据库，切换数据库需要改动的只是驱动名称。 解耦框架。高层模块只需要指导产品的抽象类，符合迪米特法则（只关心需要关心的）、依赖倒置原则（只依赖产品类的抽象）、里氏替换原则（使用产品子类替换父类）。 扩展 缩小为简单工厂模式 升级为多个工厂类 代替单例模式 延迟初始化 通过map缓存需要重用的对象 代码演示 简单工厂模式 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class SimpleFactory &#123; public Car getCar(String name) &#123; if (\"bmw\".equalsIgnoreCase(name)) &#123; return new Bmw(); &#125; else if (\"benz\".equalsIgnoreCase(name)) &#123; return new Benz(); &#125; else &#123; System.out.println(\"暂时不生产这个品牌的汽车\"); return null; &#125; &#125; /** * 静态方法通过反射创建产品类 */ public static &lt;T extends Car&gt; T getCar(Class&lt;T&gt; c) &#123; Car car = null; try &#123; car = (Car) Class.forName(c.getName()).newInstance(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return (T) car; &#125;public static void main(String[] args) &#123; SimpleFactory simpleFactory = new SimpleFactory(); Car car = simpleFactory.getCar(\"bmw\"); System.out.println(car.getName()); &#125;&#125;/**产品类*/interface Car &#123; String getName();&#125;class Benz implements Car &#123; @Override public String getName() &#123; return \"奔驰\"; &#125;&#125;class Bmw implements Car &#123; @Override public String getName() &#123; return \"宝马\"; &#125;&#125; 工厂模式 不能存在一个工厂生产所有产品的情况，所以需要多个工厂进行不同产品的生产。 12345678910111213141516171819202122232425262728293031/** * 工厂类 * 多个工厂，封装不同的产品生产流程 */public interface Factory &#123; Car getCar();&#125;class BenzFactory implements Factory &#123; @Override public Car getCar() &#123; return new Benz(); &#125;&#125;class BmwFactory implements Factory &#123; @Override public Car getCar() &#123; return new Bmw(); &#125;&#125;class FactoryTest &#123; public static void main(String[] args) &#123; BenzFactory benzFactory = new BenzFactory(); System.out.println(benzFactory.getCar().getName()); BmwFactory bmwFactory = new BmwFactory(); System.out.println(bmwFactory.getCar().getName()); &#125;&#125; 替代单例模式 1234567891011121314151617181920public class SingletonFactory &#123; private static Singleton instance; static &#123; try &#123; Class c = Class.forName(Singleton.class.getName()); Constructor constructor = c.getDeclaredConstructor(); constructor.setAccessible(true); instance = (Singleton) constructor.newInstance(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; public static Singleton getInstance() &#123; return instance; &#125;&#125;class Singleton &#123;&#125; 延迟初始化 123456789101112131415161718public class MapFactory &#123; private static final Map&lt;String, Product&gt; PRODUCT_MAP = new HashMap&lt;&gt;(); public static synchronized &lt;T extends Product&gt; T getProduct(Class&lt;T&gt; c) throws Exception &#123; T product = null; if (PRODUCT_MAP.containsKey(c.getName())) &#123; product = (T) PRODUCT_MAP.get(c.getName()); &#125; else &#123; T t = c.newInstance(); PRODUCT_MAP.put(c.getName(), t); &#125; return product; &#125;&#125;class Product &#123;&#125;class Product1 extends Product &#123;&#125; 抽象工厂模式 Abstract Factory类图 使用场景 一个对象族（或是一组没有任何关系的对象）都有相同的约束，就可以使用抽象工厂模式。比如文本编辑器和图片处理器都是软件，但是 linux 和 windows 下文本编辑器虽然界面相同，但是代码不同，也就有了共同的约束条件——操作系统。 优点 封装性好。高层模块不关心每个产品的实现类，值关心接口。对象的创建由工厂类负责。高层模块只需要知道工厂类有哪些就行。 产品族内的约束为非公开状态。例如下面代码中约定每生产1个发动机，需要设计出3种外形与之匹配。 缺点 产品族扩展非常困难。如果新增一个产品，需要修改抽象工厂类、几个实现类，严重违反开闭原则。 注意事项 与工厂模式的区别 工厂模式用来创建同一个产品的不同类型，如汽车里的奔驰、宝马，抽象工厂模式用来创建不同类的产品，汽车工厂设计汽车造型，生产发动机等。一般来说产品种类单一适合用工厂模式，如果有多个种类各种类型，更适合用抽象工厂模式。 产品族扩展困难，产品等级扩展容易 也就是横向扩展容易，纵向扩展困难。例如下面代码新增车型奥迪，只需要新增奥迪工厂类即可。从这一点上，抽象工厂符合开闭原则。 代码演示1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465// 抽象工厂public abstract class CarFactory &#123; abstract DesignFactory designAppearance(); abstract EngineFactory produceEngine();&#125;// 产品类型abstract class DesignFactory &#123; abstract void design();&#125;abstract class EngineFactory &#123; abstract void produce();&#125;class BmwDesignFactory extends DesignFactory &#123; @Override public void design() &#123; System.out.println(\"设计宝马造型\"); &#125;&#125;class BenzDesignFactory extends DesignFactory &#123; @Override public void design() &#123; System.out.println(\"设计奔驰造型\"); &#125;&#125;class BmwEngineFactory extends EngineFactory &#123; @Override public void produce() &#123; System.out.println(\"生产宝马发动机\"); &#125;&#125;class BenzEngineFactory extends EngineFactory &#123; @Override public void produce() &#123; System.out.println(\"生产奔驰发动机\"); &#125;&#125;// 产品工厂class BmwFactory extends CarFactory &#123; @Override public DesignFactory designAppearance() &#123; return new BmwDesignFactory(); &#125; @Override public EngineFactory produceEngine() &#123; return new BmwEngineFactory(); &#125;&#125;// 测试类class Test &#123; public static void main(String[] args) &#123; BmwFactory bmwFactory = new BmwFactory(); bmwFactory.designAppearance().design(); bmwFactory.produceEngine().produce(); &#125;&#125; 建造者模式 Builder类图 使用场景 相同的方法，不同的执行顺序，产生不同的事件结果。 多个部件或零件都可以装配到一个对象中，但是产生的运行结果又不相同。 产品类非常复杂，或者产品类中的调用顺序不同产生了不同的效能。 对象创建过程中会使用到系统中的一些其他对象，这些对象在产品创建过程中不易得到时，可采用建造者模式封装该对象的创建过程。这种场景只能是一个补偿方法，因为一个对象不容易获得，在设计阶段竟然没发觉，而要通过创建者模式柔化创建过程，本身已经违反设计的最初目标。 当一个类构造器需要传入很多参数时，如果创建这个类的实例，代码可读性差，可用 builder 模式重构。如 lombok 的 @Builder 注解。 优点 封装性好。使客户端不必知道产品内部组成的细节，只关注产生的对象和要素。 建造者独立，更容易扩展。多个 builder 相互独立，对系统的扩展非常有利。 便于控制细节风险。具体建造者独立，因此可以对建造过程逐步细化，而不对其他模块产生任何影响。 注意事项 与工厂模式的区别 建造者模式最主要的功能是方法的调用顺序安排，通俗讲就是零件的装配，顺序不同对象也不同。即关注的是零件类型和装配工艺（顺序）。 工厂方法主要职责是创建零件，而不关心组装顺序。 扩展 与模板方法模式进行结合 代码演示1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public abstract class Builder &#123; public abstract void setPart(); public abstract Product build();&#125;@Dataclass Product &#123; private String name; public void doSomeThing() &#123; System.out.println(\"产品做某事\"); &#125;&#125;class ConcreteProduct extends Builder &#123; private Product product = new Product(); @Override public void setPart() &#123; product.setName(\"默认名字\"); &#125; @Override public Product build() &#123; return product; &#125;&#125;class Director &#123; private Builder builder; public Director(Builder builder) &#123; this.builder = builder; &#125; public Product getBuilder() &#123; builder.setPart(); return builder.build(); &#125;&#125;class Client &#123; public static void main(String[] args) &#123; Director director = new Director(new ConcreteProduct()); Product product = director.getBuilder(); product.doSomeThing(); &#125;&#125; 原型模式 Prototype使用场景 资源优化场景。类初始化消耗较多资源，包括数据、硬件等。 性能和安全要求的场景。避免通过 new 产生一个对象需要非常繁琐的数据准备或访问权限。 一个对象多个修改者的场景。拷贝多个对象供各个调用者使用。 原型模式一般与工厂方法模式一起使用，通过 clone 方法创建一个对象，然后由工厂方法提供给调用者。 优点 性能优良。内存二进制流的拷贝，比直接 new 一个对象性能好很多，特别是在循环体内产生大量对象。 逃避构造函数的约束。直接内存拷贝，不会执行构造函数，即使是 private 也可以克隆。双刃剑。 注意事项 构造函数不会被执行 深拷贝和浅拷贝 使用原型模式时，引用的成员变量必须满足两个条件才不会被拷贝：一是类的成员变量，而不是方法内变量；二必须时一个可变得引用对象，而不是原始类型或不可变对象。 深拷贝和浅拷贝建议不要混合使用，特别是涉及类的继承时，父类有多个引用的情况就非常复杂，建议深拷贝和浅拷贝分开实现。 clone 与 final 有冲突。要使用 clone，类成员变量上就不能加 final 修饰。 代码演示 构造函数不执行 12345678910111213141516public class Prototype implements Cloneable &#123; public Prototype() &#123; System.out.println(\"构造函数被执行。。\"); &#125; @Override protected Prototype clone() throws CloneNotSupportedException &#123; return (Prototype) super.clone(); &#125;&#125;class Client &#123; public static void main(String[] args) throws CloneNotSupportedException &#123; Prototype prototype = new Prototype(); Prototype clone = prototype.clone(); &#125;&#125; 深拷贝与浅拷贝 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// 浅拷贝class LightClone implements Cloneable &#123; private List&lt;String&gt; list = new ArrayList&lt;&gt;(); @Override protected LightClone clone() throws CloneNotSupportedException &#123; return (LightClone) super.clone(); &#125; public void addValue(String value) &#123; list.add(value); &#125; public List&lt;String&gt; getValueList() &#123; return this.list; &#125;&#125;class Client1 &#123; public static void main(String[] args) throws CloneNotSupportedException &#123; LightClone origin = new LightClone(); origin.addValue(\"111\"); LightClone clone = origin.clone(); clone.addValue(\"222\"); System.out.println(origin.getValueList()); System.out.println(clone.getValueList()); System.out.println(origin.getValueList() == clone.getValueList()); &#125;&#125;// 深拷贝class DeepClone implements Cloneable &#123; private ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); @Override protected DeepClone clone() throws CloneNotSupportedException &#123; DeepClone clone = (DeepClone) super.clone(); clone.list = (ArrayList&lt;String&gt;) clone.list.clone(); return clone; &#125; public void addValue(String value) &#123; list.add(value); &#125; public List&lt;String&gt; getValueList() &#123; return this.list; &#125;&#125;class Client2 &#123; public static void main(String[] args) throws CloneNotSupportedException &#123; DeepClone origin = new DeepClone(); origin.addValue(\"111\"); DeepClone clone = origin.clone(); clone.addValue(\"222\"); System.out.println(origin.getValueList()); System.out.println(clone.getValueList()); System.out.println(origin.getValueList() == clone.getValueList()); &#125;&#125; 增加 final 的拷贝 1234567891011public class FinalClone implements Cloneable &#123; private final ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); @Override protected FinalClone clone() throws CloneNotSupportedException &#123; FinalClone clone = (FinalClone) super.clone(); // 下面这行代码报错 // clone.list = (ArrayList&lt;String&gt;) this.list.clone(); return clone; &#125;&#125;","categories":[],"tags":[{"name":"book","slug":"book","permalink":"https://melodyplayer.github.io/blog/tags/book/"}]},{"title":"《设计模式之禅》——结构型","slug":"《设计模式之禅》——结构型","date":"2019-11-11T07:23:43.000Z","updated":"2019-12-16T13:01:28.333Z","comments":true,"path":"blog/2019/1111:《设计模式之禅》——结构型/","link":"","permalink":"https://melodyplayer.github.io/blog/2019/1111:《设计模式之禅》——结构型/","excerpt":"7种结构型模式：代理、装饰、适配器、组合、外观、享元、桥接。","text":"7种结构型模式：代理、装饰、适配器、组合、外观、享元、桥接。 代理模式 Proxy也叫委托模式。许多其他模式如状态模式、策略模式、访问者模式本质上是在特殊场合采用了委托模式。 类图 使用场景典型动态代理：Spring AOP 应用广泛：系统框架、企业平台、事务处理 优点 职责清晰：真实角色只需实现实际的业务逻辑，由代理完成事务。 高扩展性：具体的主题角色不管怎么变化，只要实现了接口，代理类就可以在不做任何修改的情况下使用。 智能化：动态代理。 扩展 普通代理 调用者需要知道代理类的存在才能访问，不用知道真实角色。 适合扩展性要求较高的场合。实际项目中通常约定禁止new一个真实角色。 强制代理 代理管理由真实角色完成，不能随便new。高层模块只需调用 getProxy 就可以访问真实角色所有方法。必须通过真实角色查找到代理角色才能访问，不允许直接访问真实角色。 代理是有个性的 代理可实现其他接口完成不同的任务。 代理的目的是在目标对象方法的基础上作增强，进行拦截和过滤。 动态代理 实现阶段不关心代理谁，而在运行阶段才指定代理哪个对象。 相对来说，自己写代理类的方式是静态代理。 AOP：Aspect Oriented Programming 实现思路：实现 InvocationHandler 动态代理接口，重写 invoke() 方法，完成对真实方法的调用。在运行时动态产生代理对象。 代码演示 普通代理 123456789101112131415161718interface Subject1 &#123; void doSomething(String str);&#125;class Subject1Impl implements Subject1 &#123; @Override public void doSomething(String str) &#123;System.out.println(\"Subject1 做\" + str);&#125;&#125;// 代理要实现相同接口，高层模块调用时要先构造代理对象class NormalProxy implements Subject1 &#123; private Subject1 subject1; public NormalProxy(Subject1 subject1) &#123;this.subject1 = subject1;&#125; @Override public void doSomething(String str) &#123;subject1.doSomething(str);&#125;&#125; 强制代理 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354interface Subject2 &#123; void doSomething(String str); // 获取自身特定的代理类 Subject2 getProxy();&#125;class Subject2Impl implements Subject2 &#123; private ForceProxy forceProxy; @Override public void doSomething(String str) &#123; if (isProxy()) &#123; System.out.println(\"Subject2 在做\" + str); &#125; else &#123; System.out.println(\"请使用自身代理执行 做\" + str); &#125; &#125; // 判断是否拥有代理 private boolean isProxy() &#123;return this.forceProxy != null;&#125; @Override public Subject2 getProxy() &#123; if (this.forceProxy == null) &#123; synchronized (this) &#123; if (this.forceProxy == null) &#123; this.forceProxy = new ForceProxy(this); &#125; &#125; &#125; return this.forceProxy; &#125;&#125;class ForceProxy implements Subject2 &#123; private Subject2 subject2; public ForceProxy(Subject2 subject2) &#123;this.subject2 = subject2;&#125; @Override public void doSomething(String str) &#123;subject2.doSomething(str);&#125; @Override public Subject2 getProxy() &#123;return this;&#125;&#125;class Client2 &#123; public static void main(String[] args) &#123; Subject2 subject2 = new Subject2Impl(); subject2.doSomething(\"家务\"); ForceProxy forceProxy = new ForceProxy(subject2); forceProxy.doSomething(\"饭\"); subject2.getProxy().doSomething(\"运动\"); &#125;&#125; 个性化的代理类 12345678910111213141516171819202122232425262728293031interface Player &#123;void doSport();&#125;interface Boss &#123;void invest(String str);&#125;class PlayerImpl implements Player &#123; @Override public void doSport() &#123;System.out.println(\"运动员做XXX运动太出名了\");&#125;&#125;class MultiImplementProxy implements Player, Boss &#123; private Player player; public MultiImplementProxy(Player player) &#123;this.player = player;&#125; @Override public void doSport() &#123; player.doSport(); this.invest(\"拍电影\"); &#125; @Override public void invest(String str) &#123;System.out.println(\"代理人有钱，给运动员投资\" + str);&#125;&#125;class Client3 &#123; public static void main(String[] args) &#123; Player player = new PlayerImpl(); MultiImplementProxy proxy = new MultiImplementProxy(player); proxy.doSport(); &#125;&#125; 动态代理 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859// 动态代理的 handler 类class MyInvocationHandler implements InvocationHandler &#123; // 被代理对象 private Object obj; public MyInvocationHandler(Object obj) &#123;this.obj = obj;&#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; return method.invoke(obj, args); &#125;&#125;// 切面接口interface IAdvice &#123;void exec();&#125;class BeforeAdvice implements IAdvice&#123; @Override public void exec() &#123;System.out.println(\"前置通知被执行！\");&#125;&#125;// 通用动态代理类，只做切面增强class DynamicProxy &#123; public static &lt;T&gt; T newInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h) &#123; // 寻找 JoinPoint 连接点，AOP框架使用元数据定义 if (true) &#123; // 执行一个前置通知 new BeforeAdvice().exec(); &#125; return (T) Proxy.newProxyInstance(loader, interfaces, h); &#125;&#125;// 具有业务意义的动态代理类class SubjectDynamicProxy extends DynamicProxy &#123; private SubjectDynamicProxy() &#123;&#125; public static &lt;T&gt; T newProxyInstance(Subject4 subject4) &#123; ClassLoader loader = subject4.getClass().getClassLoader(); Class&lt;?&gt;[] interfaces = subject4.getClass().getInterfaces(); MyInvocationHandler handler = new MyInvocationHandler(subject4); return newInstance(loader, interfaces, handler); &#125;&#125;// 业务接口interface Subject4 &#123;void doSomething();&#125;class Subject4Impl implements Subject4 &#123; @Override public void doSomething() &#123;System.out.println(\"Subject4 做某事\");&#125;&#125;// 高层调用模块——客户端class client4 &#123; public static void main(String[] args) &#123; Subject4 proxy = SubjectDynamicProxy.newProxyInstance(new Subject4Impl()); proxy.doSomething(); &#125;&#125; 装饰模式 Decorator类图 使用场景 需要扩展一个类的功能，或给一个类增加附加功能。 需要动态地给一个对象增加功能，这些功能可以再动态地撤销。 需要为一批的兄弟类进行改造或加装功能，首选装饰模式。 优点 装饰类和被装饰类可以独立发展，不会相互耦合。换句话说，Component类无须知道Decorator类，Decorator类是从外部来扩展Component类的功能，而Decorator也不用知道具体的构件。 对于 Father、Son、GrandSon三个类，如果要在 son 上增强功能，在 Son 上直接修改可能会影响到 GrandSon，但采用 SonDecorator 类来修饰 Son 相当于创建新类，对原来的程序无影响。 装饰模式是继承关系的替代方案。对于装饰类 Decorator，不管装饰多少层，返回的对象还是 Component，实现的还是 is-a 的关系。 继承会增加很多子类，装饰模式可以有效解决类膨胀的问题。 装饰模式可以动态地扩展一个实现类的功能。 想去掉某个封装只需要在高层模块去掉即可，如果用继承就必须要修改子模块。 缺点 多层的装饰比较复杂。定位问题时不容易发现是那一层装饰出了问题。 因此尽量减少装饰类的数量，以便降低系统的复杂度。 注意事项 与代理模式的比较：类图、代码实现非常相似，区别在于 代理负责接口限定：是否可以调用真实角色，以及是否对发送到真实角色的消息进行变形处理，不对被代理类的功能做任何处理。应用广范。 装饰保证接口不变做类的加强，保证被修饰对象功能比原始对象丰富或减弱，但不做准入条件判断和准入参数过滤。例如 JDK 的 java.io.* 包中的 1OutputStream out = new DataOutPutStream(new FileOutputStream(\"test.txt\")); 代码演示1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162abstract class SchoolReport &#123; // 成绩单报告 abstract void report(); // 家长签名 abstract void sign(String name);&#125;// 期末考试成绩报告，如果直接报告分数这么低肯定少不了“竹笋炒肉”class FinalExamSchoolReport extends SchoolReport &#123; @Override void report() &#123; System.out.println(\"尊敬的XXX家长：\"); System.out.println(\"XXX这次考试成绩如下：语文62，数学65，自然63\"); System.out.println(\"家长签名：\"); &#125; @Override void sign(String name) &#123;System.out.println(\"家长签名为：\" + name);&#125;&#125;abstract class Decorator extends SchoolReport &#123; private SchoolReport sr; public Decorator(SchoolReport sr) &#123;this.sr = sr;&#125; @Override void report() &#123;sr.report();&#125; @Override void sign(String name) &#123;sr.sign(name);&#125;&#125;// 如果只汇报自己的成绩，太低容易挨揍，把班里的最高分作为背景铺垫一下，相对来说分就没那么低了class HighScoreDecorator extends Decorator &#123; public HighScoreDecorator(SchoolReport sr) &#123;super(sr);&#125; @Override void report() &#123; reportHighScore(); super.report(); &#125; private void reportHighScore() &#123; System.out.println(\"这次考试全班最高分，语文75，数学78，自然82\"); &#125;&#125;// 再来个排名的装饰，虽然分低但是排名不靠后，相对也还是不错class SortDecorator extends Decorator &#123; public SortDecorator(SchoolReport sr) &#123;super(sr);&#125; @Override void report() &#123; super.report(); reportSort(); &#125; private void reportSort() &#123;System.out.println(\"全班60人，我的排名32\");&#125;&#125;class Father &#123; public static void main(String[] args) &#123; SchoolReport sr = new FinalExamSchoolReport(); sr = new HighScoreDecorator(sr); sr = new SortDecorator(sr); sr.report(); // 报告完之后老爸一看还行，免了一顿打把字签了 sr.sign(\"XXX的爸爸\"); &#125;&#125; 适配器模式 Adapter也叫变压器模式、包装模式（包装模式包括装饰模式）。 类图 使用场景 有动机修改一个已经投产中的接口时，比如系统扩展需要使用一个已有或新建的类，但这个类又不符合系统的接口，采用适配器模式。 作为补偿模式，用来解决接口不相容的问题。 优点 让两个没有关联的类一起运行。 增加类的透明性，高层模块不需要关注源角色怎么执行。 提高类的复用度，源角色在原有系统中可以正常使用，而在目标角色中也可以发挥新作用。 灵活性好，不需要适配器时删除掉即可。 注意事项 在详细设计阶段不要考虑使用适配器模式，它是为了解决正在服役的项目问题，减少代码修改带来的风险。 项目一定要遵守依赖倒置原则和里氏替换原则，否则即使使用适配器模式改动也很大。 扩展 类适配器 通过继承进行适配。智能通过覆写源角色的方法进行扩展。 对象适配器 通过关联、聚合进行适配。适用于多接口适配。可以灵活修补源角色的隐形缺陷、关联其他对象等。实际项目中对象适配器使用场景较多。 代码演示 类适配器 123456789101112131415161718192021222324252627282930313233// 接口interface Target &#123;void request();&#125;// 实现类class TargetImpl implements Target &#123; @Override public void request() &#123;System.out.println(\"目标实现类执行request\");&#125;&#125;// 源角色class Adaptee &#123; void doSomething() &#123;System.out.println(\"源角色要做的事情\");&#125;&#125;// 适配器角色class Adapter extends Adaptee implements Target &#123; @Override public void request() &#123; System.out.println(\"适配器要做的事\"); super.doSomething(); &#125;&#125;class Client &#123; public static void main(String[] args) &#123; // 原逻辑 Target target = new TargetImpl(); target.request(); // 使用适配器后，也拥有了request方法，扩展了新功能 Target adapter = new Adapter(); adapter.request(); &#125;&#125; 对象适配器 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758// 用户信息interface IUserInfo &#123;Map getUserInfo();&#125;class UserInfo implements IUserInfo &#123; @Override public Map getUserInfo() &#123;return new HashMap();&#125;&#125;interface IUserHomeInfo &#123;Map getHomeInfo();&#125;interface IUserOfficeInfo &#123;Map getOfficeInfo();&#125;class UserHomeInfo implements IUserHomeInfo &#123; @Override public Map getHomeInfo() &#123; Map map = new HashMap(); map.put(\"homeAddress\", \"北京市海淀区奥林匹克公园\"); map.put(\"homePhone\", \"家庭电话：123456\"); return map; &#125;&#125;class UserOfficeInfo implements IUserOfficeInfo &#123; @Override public Map getOfficeInfo() &#123; Map map = new HashMap(); map.put(\"officeAddress\", \"办公地址：鸟巢\"); map.put(\"officePhone\", \"办公电话：222333\"); return map; &#125;&#125;// 用户基本信息，适配home和office两个接口class UserBaseInfo implements IUserInfo &#123; private IUserHomeInfo userHomeInfo; private IUserOfficeInfo userOfficeInfo; private Map map = new HashMap(); public UserBaseInfo(IUserHomeInfo userHomeInfo, IUserOfficeInfo userOfficeInfo) &#123; this.userHomeInfo = userHomeInfo; this.userOfficeInfo = userOfficeInfo; map.putAll(userHomeInfo.getHomeInfo()); map.putAll(userOfficeInfo.getOfficeInfo()); &#125; @Override public Map getUserInfo() &#123;return map;&#125;&#125;class AdapterClient2 &#123; public static void main(String[] args) &#123; IUserHomeInfo homeInfo = new UserHomeInfo(); IUserOfficeInfo officeInfo = new UserOfficeInfo(); IUserInfo userInfo = new UserBaseInfo(homeInfo, officeInfo); Map info = userInfo.getUserInfo(); System.out.println(info.toString()); &#125;&#125; 组合模式 Composite也叫合成模式、部分—整体模式，将对象组合成树形结构用来表示部分与整体的关系。 类图 使用场景 维护和展示部分—整体关系的场景，如树形菜单、文件盒文件夹管理。 从一个整体中能够独立出部分模块或功能的场景。 优点 高层模块调用简单 一棵树形结构中的所有节点都是Component，局部和整体对调用者来说没有任何区别。高层模块不用关心处理的是单个对象还是整个组合结构。 节点自由增加 增加树枝节点、树叶节点非常容易，符合开闭原则，有利于维护。 缺点 不符合依赖倒置原则 场景类中树叶和树枝直接使用了实现类，限制了接口的影响范围。 注意事项 只要是树形结构，就要考虑使用组合模式。 体现局部和整体的关系，当关系比较深时，考虑组合模式。 扩展 真实的组合模式 实际使用中仍需组装这棵树，使用关系型数据库或者其他方式存储树形结构。 安全模式 树枝节点和树叶节点彻底分开，树枝节点单独拥有用来组合的方法，这种方法比较安全。 透明模式 把用来组合使用的方法放到抽象类中，不管叶子对象还是数值对象都有相同的结构。通过判断 getChildren 的返回值确认是叶子节点还是树枝节点，如果处理不当，会在运行期出问题。 组合模式的遍历 从上往下遍历没有问题，如果从下往上遍历，则需要设置 parent 属性。从而实现后序、中序等遍历方式。 树叶、树枝节点排列顺序 不用list，改用treeSet存储对象即可，可以加上实现 Comparable 接口，覆盖 compareTo 方法。 代码演示 安全模式 12345678910111213141516171819202122232425262728293031323334353637abstract class Staff &#123; private String name; private String position; public Staff(String name, String position) &#123; this.name = name; this.position = position; &#125; public String getInfo() &#123;return this.toString();&#125;&#125;class Leaf extends Staff &#123; public Leaf(String name, String position) &#123;super(name, position);&#125;&#125;class Branch extends Staff &#123; List&lt;Staff&gt; subordinate = new ArrayList&lt;&gt;(); public Branch(String name, String position) &#123;super(name, position);&#125; public void addStaff(Staff staff) &#123;this.subordinate.add(staff);&#125; public List&lt;Staff&gt; getSubordinate() &#123;return this.subordinate;&#125;&#125;class CompositeClient1 &#123; static String getTreeInfo(Branch root) &#123; String info = \"\"; List&lt;Staff&gt; staff = root.getSubordinate(); for (Staff s : staff) &#123; if (s instanceof Leaf) &#123; info = info + s.getInfo(); &#125; else &#123; info = info + s.getInfo() + \"\\t\" + getTreeInfo(root); &#125; &#125; return info; &#125;&#125; 透明模式 1234567891011121314151617181920212223242526272829303132333435363738394041424344// add、remove等方法放在抽象类中abstract class Component &#123; public void printInfo() &#123;&#125; abstract void add(Component component); abstract void remove(Component component); abstract List&lt;Component&gt; getChildren();&#125;class Leaf2 extends Component &#123; @Deprecated @Override void add(Component c) &#123;throw new UnsupportedOperationException(\"未实现 add\");&#125; @Deprecated @Override void remove(Component c) &#123;throw new UnsupportedOperationException(\"未实现 remove\");&#125; @Deprecated @Override List&lt;Component&gt; getChildren() &#123; throw new UnsupportedOperationException(\"未实现 getChildren\"); &#125;&#125;class Branch2 extends Component &#123; List&lt;Component&gt; subordinate = new ArrayList&lt;&gt;(); public Branch2(List&lt;Component&gt; subordinate) &#123;this.subordinate = subordinate;&#125; @Override void add(Component component) &#123;this.subordinate.add(component);&#125; @Override void remove(Component component) &#123;this.subordinate.remove(component);&#125; @Override List&lt;Component&gt; getChildren() &#123;return this.subordinate;&#125;&#125;class CompositeClient2 &#123; public static void display(Component root) &#123; for (Component c : root.getChildren()) &#123; if (c instanceof Leaf2) &#123; c.printInfo(); &#125; else &#123; display(c); &#125; &#125; &#125;&#125;","categories":[],"tags":[{"name":"book","slug":"book","permalink":"https://melodyplayer.github.io/blog/tags/book/"}]},{"title":"正则表达式进阶用法与真实调优案例","slug":"正则表达式进阶用法与真实调优案例","date":"2019-10-17T09:55:38.000Z","updated":"2019-11-02T18:00:42.482Z","comments":true,"path":"blog/2019/1017:正则表达式进阶用法与真实调优案例/","link":"","permalink":"https://melodyplayer.github.io/blog/2019/1017:正则表达式进阶用法与真实调优案例/","excerpt":"正则表达式并不陌生，但当面对复杂的正则表达式：长度长，特殊符号多，多分组的情况下，解析速度会怎样？","text":"正则表达式并不陌生，但当面对复杂的正则表达式：长度长，特殊符号多，多分组的情况下，解析速度会怎样？ 正则表达式基础为节省版面直击要害，基础内容本文不作赘述，请点击以下链接查看： 表达式全集 史上最全常用正则表达式大全 真实案例：超级慢的正则表达式常用的正则表达式一般几秒内解析完毕，那么见过3分钟都没解析出来的正则表达式吗？请往下看： 解析目标过滤请求中不合法的 uri（不包含参数），如包含特殊符号- = + % ?、多个斜杠//、中文等。 代码实现正则表达式：&quot;^(/?[A-Za-z0-9\\\\-]+/?[A-Za-z0-9\\\\-]+)+/?&quot; 编写 java 代码： 12345678910111213// 所有方法设置成静态的，方便 main 调用private static final Pattern URI_PATTERN = Pattern.compile(\"^(/?[A-Za-z0-9\\\\-]+/?[A-Za-z0-9\\\\-]+)+/?)\";public static boolean validateUri(String uri) &#123; Matcher m = URI_PATTERN.matcher(uri); return m.matches();&#125;public static void validate() &#123; System.out.println(\"开始。。。。。。\"); System.out.println(validateUri(\"/hotel/getUseraaaaaaaasdfasdfasdfasdfasdf+\")); System.out.println(\"结束。。。。。。\");&#125; 执行 validate 方法。 测试结果6C32G mac pro 跑了3分钟没跑完。。没耐心继续等待，直接中断。 最简单的解决方案简化正则表达式为：^/?([-A-Za-z0-9]/?)+$ 但是我们需要知道为什么？如果就想在原来的基础上做修改，该怎么办？ 原因探索：回溯匹配猜测：考虑字符太长，以及特殊符号的问题测试1：把 uri 中间的 aaaaaasdfsdf 等去掉后，只保留简单的 /hotel/getUser+，很明显速度提上来了。 测试2：把 uri 中的 + 号提前，变成 /hotel/getUser+aaaaaaaasdfasdfasdfasdfasdf，速度也很快。 初步结论：非匹配字符的位置会影响正则表达式的执行效率为此需要知道正则表达式的执行规则：回溯。 比如要匹配的字符串是 helloworld,hihaojava 正则表达式是 h(ello|ihao)java 匹配过程： 从字符串第一个字符 h 开始匹配，可以命中。 接下来的匹配正则有2个分支 ello 和 ihao 。在 e 处打标记，先从左边的 ello 开始匹配，可以匹配字符串，但是到了 world 的 w 时，与正则中的 j 不一致，该分支匹配结束。接着回溯到刚刚的标记处，开始第二个分支 ihao，无法匹配，接下来正则会从 h 开始匹配字符串。 从字符串的第二个字符 e 继续匹配，直到正则的第一个字符 h 匹配到字符串的 , 之后匹配成功。 接着正则的2个分支执行匹配，最终只有 ihao匹配成功，最终匹配到的字符串是 hihaojava。 看完了正则的匹配过程，就知道为什么前面代码中的正则匹配效率会那么低下了。每个字母都要匹配到最后的+才发现匹配失败，回溯后继续查找，如果忽略其他，只考虑字符串 getUseraaaaaaaasdfasdfasdfasdfasdf+ 和正则 [-A-Za-z0-9] 的影响，时间复杂度就已经为 n^2，类似于以下模拟代码： 12345678910111213141516171819// 模拟代码，真实情况远比这个复杂，这里仅为了方便理解public static boolean execute(String s) &#123; String reg = \"-ABCDEFGHIJKMLNOPQRSTUVWSYZabcdefghijkmlnopqrstuvwsyz0123456789\"; int i = 0, count = 0; int length = s.length(); for (; i &lt; length; i++) &#123; for (int j = 0; j &lt; length; j++) &#123; count ++; String idx = s.substring(j, j + 1); if (!reg.contains(idx)) &#123; System.out.println(\"匹配失败！特殊字符：\" + idx); break; &#125; System.out.println(\"匹配字符：\" + idx); &#125; &#125; System.out.println(\"一共匹配了 \" + count + \"次！字符串长度为 \" + length); return i != length;&#125; 解决方法：采用进阶匹配模式正则模式：贪婪、勉强、侵占假定字符串为：aahelloworldhello 贪婪模式（.*he）：将正则分为两个模式 p1 .* 以及 p2 wo 。 第一轮匹配：p1读入所有字符串，那么p2就没什么都没匹配到。 第二轮匹配：字符串被分割为 aahelloworldhell 和 o，p1匹配子串1成功，p2匹配子串2失败。 直到字符串分割为 aahelloworld 和 hello时，两个正则模式都匹配成功。匹配到的子串为aahelloworldhe，停止匹配，返回结果。 勉强模式（.*?he）：最小匹配方式。此时的正则模式为 .*? 和 wo。 第一次匹配：p1由于是0或任意次，被忽略，用字符串整体去匹配 p2，当然失败。 第二次匹配：p1读入第一个字符 a，匹配成功，剩余的 ahelloworldhello 由 p2匹配，失败。 直到字符串分割为 aa 和 helloworldhello，两个正则模式都匹配成功。匹配子串 aahe，返回结果。 继续匹配，直到字符串分隔为 lloworld 和 hello，匹配子串 lloworldhe，返回结果。 侵占模式（.*+he）：也叫占用模式。匹配开始时读入所有字符串和 p1匹配成功，但没有剩余字符串去和 p2匹配，因此返回匹配失败。 说明：贪婪模式和占有模式相比，贪婪模式会在只有部分匹配成功的条件下，依次从多到少减少匹配成功部分模式的匹配数量，将字符留给模式其他部分去匹配。而占用模式则是占有所有能匹配成功部分，绝不留给其他部分使用。 代码演示1234567891011121314151617181920212223public static final Pattern PATTERN_GREEDY = Pattern.compile(\".*he\");public static final Pattern PATTERN_FORCED = Pattern.compile(\".*?he\");public static final Pattern PATTERN_OCCUPIED = Pattern.compile(\".*+he\");public static void execute() &#123; String s = \"aahelloworldhello\"; Matcher greedy = PATTERN_GREEDY.matcher(s); while (greedy.find()) &#123; System.out.println(\"贪婪模式：匹配到子串 \" + greedy.group()); System.out.println(\"贪婪模式：查找匹配到的子串在原始串中的索引位置 \" + greedy.start()); System.out.println(\"贪婪模式：查找匹配到的子串最后一个字符串在原串中的位置 \" + greedy.end()); &#125; Matcher forced = PATTERN_FORCED.matcher(s); while (forced.find()) &#123; System.out.println(\"勉强模式：匹配到子串 \" + forced.group()); System.out.println(\"勉强模式：查找匹配到的子串在原始串中的索引位置 \" + forced.start()); System.out.println(\"勉强模式：查找匹配到的子串最后一个字符串在原串中的位置 \" + forced.end()); &#125; Matcher occupied = PATTERN_OCCUPIED.matcher(s); System.out.println(\"侵占模式：匹配原串任意位置返回的结果： \" + occupied.find());&#125; 返回的结果： 123456789101112贪婪模式：匹配到子串 aahelloworldhe贪婪模式：查找匹配到的子串在原始串中的索引位置 0贪婪模式：查找匹配到的子串最后一个字符串在原串中的位置 14 勉强模式：匹配到子串 aahe勉强模式：查找匹配到的子串在原始串中的索引位置 0勉强模式：查找匹配到的子串最后一个字符串在原串中的位置 4勉强模式：匹配到子串 lloworldhe勉强模式：查找匹配到的子串在原始串中的索引位置 4勉强模式：查找匹配到的子串最后一个字符串在原串中的位置 14 侵占模式：匹配原串任意位置返回的结果： false 在这个基础上，之前的难题迎刃而解。对于判断 uri 是否合法的问题，不需要正则做回溯操作，整体不合法则返回匹配失败即可，因此选用侵占模式，需要将之前的正则表达式改进一下。 原始正则表达式：&quot;^(/?[A-Za-z0-9\\\\-]+/?[A-Za-z0-9\\\\-]+)+/?&quot; 改进后的正则表达式：&quot;^(/?[A-Za-z0-9\\\\-]++/?[A-Za-z0-9\\\\-]++)+/?&quot; 测试后发现速度变为了 ms 级，只增加 + 号，效果显而易见。 正则高级用法补充除了贪婪勉强侵占模式以外，补充一些其他的高级用法。 获取匹配 Capturing系统在幕后将所有的子模式匹配结果保存起来，供我们查找或替换。 后向引用：使用 \\数字 代表前面某个子模式的匹配内容，使用 $数字 代表变量。 例如：匹配合法的 html 标记。 正则：&lt;h([1-6])&gt;.*?&lt;/h\\1&gt; 文本：&lt;h1&gt; text1&lt;/h1&gt; &lt;h2&gt;text23&lt;/h3&gt; 其中 &lt;h1&gt;text1&lt;/h1&gt; 被成功匹配。\\1代表前面的子模式([1-6])的匹配结果1。 常见应用：匹配重复单词 (\\w+) \\1，匹配合法的 html 标记。 非获取匹配 Non-Capturing在子模式内部前面添加 ?:。表示这个子模式的匹配内容不会被保存，不能用于后向引用中。 例如：Windows 95 and Windows 98 are the successor. Then Windows 2000 and Windows Xp appeared. Windows Vista is the Latest version of the family. 正则：Windows (?:[\\w]+\\b) 匹配：Windows 95 and Windows 98 are the successor. Then Windows 2000 and Windows Xp appeared. Windows Vista is the Latest version of the family. 结果：只匹配内容，但并未保存子匹配的结果 正向肯定预查：在子模式内部前面加 ?=，子模式仅仅作为条件限制，并不作为匹配结果输出，匹配子模式前面的内容。 正则：Windows (?=[\\d]+\\b) 匹配：Windows 95 and Windows 98 are the successor. Then Windows 2000 and Windows Xp appeared. Windows Vista is the Latest version of the family. 正向否定预查：在子模式内部前面加 ?!。 正则：Windows (?![\\d]+\\b) 匹配：Windows 95 and Windows 98 are the successor. Then Windows 2000 and Windows Xp appeared. Windows Vista is the Latest version of the family. 反向肯定预查：在子模式内部前面加 ?&lt;=，匹配子模式后面的结果作为匹配结果。 例如：CNY:100.2 USD:222.1 USD:301.3 HKD:122.1 CNY:114.4 正则：(?&lt;=CNY:)\\d+\\.\\d 匹配：CNY:100.2 USD:222.1 USD:301.3 HKD:122.1 CNY:114.4 反向否定预查：在子模式内部前面加 ?&lt;! 正则：(?&lt;!CNY:)\\b\\d+\\.\\d 匹配：CNY:100.2 USD:222.1 USD:301.3 HKD:122.1 CNY:114.4 代码演示 获取匹配 12String s = \"abc def aaa bbb\".replaceAll(\"(\\\\w+)\\\\s(\\\\w+)\", \"$2 $1\");// 结果是 def abc bbb aaa 非获取匹配 12345678910111213141516171819202122232425262728293031323334353637383940public static final Pattern PATTERN = Pattern.compile(\"Windows (?:[\\\\w]+\\\\b)\");public static final Pattern PATTERN_POSITIVE_YES = Pattern.compile(\"Windows (?=[\\\\d]+\\\\b)\");public static final Pattern PATTERN_POSITIVE_NO = Pattern.compile(\"Windows (?![\\\\d]+\\\\b)\");public static final Pattern PATTERN_NEGATIVE_YES = Pattern.compile(\"(?&lt;=CNY:)\\\\d+\\\\.\\\\d+\");public static final Pattern PATTERN_NEGATIVE_NO = Pattern.compile(\"(?&lt;!CNY:)\\\\b\\\\d+\\\\.\\\\d+\");public static final String STR1 = \"Windows 95 and Windows 98 are the successor. Then Windows 2000 and Windows Xp appeared. Windows Vista is the Latest version of the family.\";public static final String STR2 = \"CNY:100.25 USD:222.16 USD:301.3 HKD:122.1 CNY:114.4\";public static void execute() &#123; Matcher noCapturing = PATTERN.matcher(STR1); System.out.println(\"\\n非获取匹配结果：---------\"); while (noCapturing.find()) &#123; System.out.print(noCapturing.group() + \"\\t\"); &#125; Matcher positiveYes = PATTERN_POSITIVE_YES.matcher(STR1); System.out.println(\"\\n正向肯定预查结果：---------\"); while (positiveYes.find()) &#123; System.out.print(positiveYes.group() + \"\\t\"); &#125; Matcher positiveNo = PATTERN_POSITIVE_NO.matcher(STR1); System.out.println(\"\\n正向否定预查结果：---------\"); while (positiveNo.find()) &#123; System.out.print(positiveNo.group() + \"\\t\"); &#125; Matcher negativeYes = PATTERN_NEGATIVE_YES.matcher(STR2); System.out.println(\"\\n负向肯定预查结果：---------\"); while (negativeYes.find()) &#123; System.out.print(negativeYes.group() + \"\\t\"); &#125; Matcher negativeNo = PATTERN_NEGATIVE_NO.matcher(STR2); System.out.println(\"\\n负向否定预查结果：---------\"); while (negativeNo.find()) &#123; System.out.print(negativeNo.group() + \"\\t\"); &#125;&#125; 运行结果： 12345678910非获取匹配结果：---------Windows 95 Windows 98 Windows 2000 Windows Xp Windows Vista正向肯定预查结果：---------Windows Windows Windows正向否定预查结果：---------Windows Windows负向肯定预查结果：---------100.25 114.4负向否定预查结果：---------222.16 301.3 122.1","categories":[],"tags":[{"name":"general","slug":"general","permalink":"https://melodyplayer.github.io/blog/tags/general/"}]},{"title":"mac单机部署mysql多实例","slug":"mac单机部署mysql多实例","date":"2019-10-03T19:04:45.000Z","updated":"2019-11-02T11:34:43.907Z","comments":true,"path":"blog/2019/1004:mac单机部署mysql多实例/","link":"","permalink":"https://melodyplayer.github.io/blog/2019/1004:mac单机部署mysql多实例/","excerpt":"单机部署mysql多实例，需要用到 mysql 自带的 mysqld_multi 命令，在目录 support_files 下有 mysqld_multi.server 命令封装。","text":"单机部署mysql多实例，需要用到 mysql 自带的 mysqld_multi 命令，在目录 support_files 下有 mysqld_multi.server 命令封装。 mysql 版本：5.7.27单机多实例配置手动创建 my.cnf 文件mac 使用 dmg 文件直接安装，不会自动生成 my.cnf 文件，需要手动创建。 12345678910111213[mysqld_multi]mysqld = /usr/local/mysql/bin/mysqld_safemysqladmin = /usr/local/mysql/bin/mysqladminuser = rootpassword = root[mysqld1]socket = /tmp/mysql.sock1port = 3311pid-file = /usr/local/var/mysql/data/data1/hostname.pid1datadir = /usr/local/var/mysql/data/data1language = /usr/local/mysql/share/englishuser = root 执行 mysqld_multi.server start这时会在控制台显示出生成的密码，记住待会儿会进行修改。 修改密码1mysqladmin -u root -P 3312 -p -S /tmp/mysql.sock2 password 连接 mysql1mysql -u root -p -P 3312 -S /tmp/mysql.sock2 关闭mysql123./mysqld_multi.server stop #关闭所有./mysqld_multi.server stop 1 #关闭单个./mysqld_multi.server stop 1-2 #关闭某个范围的实例 单机多实例主从配置必读：MySQL的主从复制介绍及配置 具体执行顺序按照链接中的顺序操作即可。这里只谈在操作中采的坑以及核心要点。 不要在命令行直接输入密码，例如：mysql -u root -p &#39;root&#39; -P 3312 -S /tmp/mysql.sock2 解决方法：去掉-p后的 ‘root’。mysql -u root -p -P 3312 -S /tmp/mysql.sock2 从库Slave_IO_Running: Connecting 问题 12Slave_IO_Running: ConnectingSlave_SQL_Running: Yes 解决方法：这个问题多半是未连接到主库专门用来复制的用户，检查用户名，用户权限等。 主库备份问题 关键在于了解参数的意义，可以指定某个数据库进行备份，也可以-A全部备份。 1mysqldump -u root -p -S /tmp/mysql/mysql.sock1 -A &gt; mysql_bak.2019-10-06.sql","categories":[],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://melodyplayer.github.io/blog/tags/mysql/"}]},{"title":"线程池invokeAll方法详解","slug":"线程池invokeAll方法详解","date":"2019-08-10T13:23:50.000Z","updated":"2019-08-10T16:56:08.594Z","comments":true,"path":"blog/2019/0810:线程池invokeAll方法详解/","link":"","permalink":"https://melodyplayer.github.io/blog/2019/0810:线程池invokeAll方法详解/","excerpt":"线上真实案例，多次调用线程池 ThreadPoolExecutor 的 invokeAll() 方法进行数据统计时任务被拒绝，故事从此开始。 本文重在讲述问题的产生、抽象、寻找解决方法的过程，并结合源码对原因进行抽丝剥茧般的分析。bug 千千万万，唯有合理的逻辑推理思维才能让这些 bug 显露原形。","text":"线上真实案例，多次调用线程池 ThreadPoolExecutor 的 invokeAll() 方法进行数据统计时任务被拒绝，故事从此开始。 本文重在讲述问题的产生、抽象、寻找解决方法的过程，并结合源码对原因进行抽丝剥茧般的分析。bug 千千万万，唯有合理的逻辑推理思维才能让这些 bug 显露原形。 问题起源与抽象先来看一段简单的代码，定义一个核心线程数5、有界队列5的线程池，然后创建10个任务丢进去执行2次。 按照以前对线程池执行逻辑的理解，创建的10个线程，会先交给核心线程去执行，5个核心线程满了之后，存放到队列中，刚好存储剩下的5个，按理说10个任务都会正常执行完毕。本次只测试固定大小的线程池。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class InvokeAllTest &#123; private static ThreadPoolExecutor executor = new ThreadPoolExecutor(5, 5, 60 * 1000, TimeUnit.SECONDS, new ArrayBlockingQueue&lt;&gt;(5), new MyThreadFactory()); public static void main(String[] args) &#123; List&lt;Callable&lt;Void&gt;&gt; tasks = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 10; i++) &#123; tasks.add(new InvokeAllThread()); &#125; System.out.println(\"第一次任务执行前的executor： \" + executor); try &#123; executor.invokeAll(tasks); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(\"第一次任务执行完毕后的executor： \" + executor); System.out.println(\"==============第一次任务执行完毕，开始第二次任务============\"); try &#123; Thread.sleep(1000); executor.invokeAll(tasks); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(\"第二次任务执行完毕后的executor：\" + executor); &#125; // 任务执行线程。通过打印线程名称，观察提交的任务被哪个线程执行 static class InvokeAllThread implements Callable&lt;Void&gt; &#123; @Override public Void call() throws Exception &#123; System.out.println(Thread.currentThread().getName()); return null; &#125; &#125; // 给工作线程自定义名字，方便观察提交的任务被哪个线程执行 static class MyThreadFactory implements ThreadFactory &#123; private AtomicInteger threadNum = new AtomicInteger(1); @Override public Thread newThread(Runnable r) &#123; Thread thread = new Thread(r, String.valueOf(threadNum.getAndIncrement())); if (thread.getPriority() != Thread.NORM_PRIORITY) &#123; thread.setPriority(Thread.NORM_PRIORITY); &#125; return thread; &#125; &#125; 运行程序后发现，第一次调用 invokeAll 正常执行，第二次调用报错。多次执行结果相同。 123456789101112131415161718192021222324第一次任务执行前的executorjava.util.concurrent.ThreadPoolExecutor@30f39991[Running, pool size = 0, active threads = 0, queued tasks = 0, completed tasks = 0]1234453233第一次任务执行完毕后的executorjava.util.concurrent.ThreadPoolExecutor@30f39991[Running, pool size = 5, active threads = 0, queued tasks = 0, completed tasks = 10]==============第一次任务执行完毕，开始第二次任务============24521Exception in thread \"main\" java.util.concurrent.RejectedExecutionException: Task java.util.concurrent.FutureTask@3a71f4dd rejected from java.util.concurrent.ThreadPoolExecutor@30f39991[Running, pool size = 5, active threads = 2, queued tasks = 0, completed tasks = 13] at java.util.concurrent.ThreadPoolExecutor$AbortPolicy.rejectedExecution(ThreadPoolExecutor.java:2063) at java.util.concurrent.ThreadPoolExecutor.reject(ThreadPoolExecutor.java:830) at java.util.concurrent.ThreadPoolExecutor.execute(ThreadPoolExecutor.java:1379) at java.util.concurrent.AbstractExecutorService.invokeAll(AbstractExecutorService.java:238) at com.aaron.hp.thread.pool.InvokeAllTest.main(InvokeAllTest.java:36) 问题排查与猜测既然程序出现异常，就该调用 debug 模式进行排查，并遵循”大胆猜测，小心求证”的态度，去解决这个问题。 猜测一：invokeAll 在异步执行后会不会同步等待线程执行完毕获取最终结果由于 invokeAll 封装的太好，之前只知道最后会同步等待才能获取返回值。那么现在就需要去证实这个概念。 进入 invokeAll 方法后，发现调用了f.get()，那么毫无疑问，这个猜测可以排除掉了。 其实从执行过程的输出内容也可以看出，两次调用 invokeAll 的执行顺序和界限(打印语句) 非常明显。 1234567891011121314151617181920212223242526272829303132public &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks) throws InterruptedException &#123; if (tasks == null) throw new NullPointerException(); ArrayList&lt;Future&lt;T&gt;&gt; futures = new ArrayList&lt;Future&lt;T&gt;&gt;(tasks.size()); boolean done = false; try &#123; for (Callable&lt;T&gt; t : tasks) &#123; RunnableFuture&lt;T&gt; f = newTaskFor(t); futures.add(f); // 任务被添加后的具体执行 execute(f); &#125; for (int i = 0, size = futures.size(); i &lt; size; i++) &#123; Future&lt;T&gt; f = futures.get(i); if (!f.isDone()) &#123; try &#123; // 此处同步等待 f.get(); &#125; catch (CancellationException ignore) &#123; &#125; catch (ExecutionException ignore) &#123; &#125; &#125; &#125; done = true; return futures; &#125; finally &#123; if (!done) for (int i = 0, size = futures.size(); i &lt; size; i++) futures.get(i).cancel(true); &#125;&#125; 猜测二：队列里面可能存在第一次调用 invokeAll 执行了但没有删掉的任务，所以才会导致第二次放入队列失败由于未阅读源码，猜测只有当创建的任务执行完毕并且销毁之后，才会从队列中真正移除。 那么就需要查看入队列和出队列的时机。查看 invokeAll 方法中的 execute(f) 方法。 查看 ThreadPoolExecutor 类下的 execute 方法源码： 12345678910111213141516171819202122public void execute(Runnable command) &#123; if (command == null) throw new NullPointerException(); int c = ctl.get(); // 判断工作线程数是否小于核心线程数，如果是则创建 Worker 工作线并返回 if (workerCountOf(c) &lt; corePoolSize) &#123; if (addWorker(command, true)) return; c = ctl.get(); &#125; // 判断主线程是否在运行，并判断是否入队列成功 if (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123; int recheck = ctl.get(); if (! isRunning(recheck) &amp;&amp; remove(command)) reject(command); else if (workerCountOf(recheck) == 0) addWorker(null, false); &#125; // 否则重新创建 Worker 线程，创建失败则抛出拒绝策略 else if (!addWorker(command, false)) reject(command);&#125; 此时就会发现入队列的操作在workQueue.offer(command)处完成，而我们提交的任务是由一个叫 Worker 类的实例来执行，addWorker(command, true)创建 Worker 实例。 那么我们就分别进去这两个方法来看下源码： 矮油黑人问号脸。。没想到这个 ThreadPoolExecutor 类的 addWorker 这么长，给核心代码写个注释重点关注，扫一眼然后去看 offer 方法(英文注释是源码中自带的)。前面都是校验，创建核心线程处为new Worker(firstTask)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869private boolean addWorker(Runnable firstTask, boolean core) &#123; retry: for (;;) &#123; int c = ctl.get(); int rs = runStateOf(c); // Check if queue empty only if necessary. if (rs &gt;= SHUTDOWN &amp;&amp; ! (rs == SHUTDOWN &amp;&amp; firstTask == null &amp;&amp; ! workQueue.isEmpty())) return false; for (;;) &#123; int wc = workerCountOf(c); if (wc &gt;= CAPACITY || wc &gt;= (core ? corePoolSize : maximumPoolSize)) return false; if (compareAndIncrementWorkerCount(c)) break retry; c = ctl.get(); // Re-read ctl if (runStateOf(c) != rs) continue retry; // else CAS failed due to workerCount change; retry inner loop &#125; &#125; boolean workerStarted = false; boolean workerAdded = false; Worker w = null; try &#123; // 上面一堆都是校验，此处才是 Worker 被创建的地方，注意被传入的 firstTask w = new Worker(firstTask); // 此处发现 Worker 里面居然还有个 therad 线程，不过想想也是，没有线程怎么异步执行呢。点进 Worker 的构造方法看一眼就会发现，这个线程就是由我们自定义的 threadFactory 来创建的，所以核心线程名称就是我们之前设定好的名字。this.thread = getThreadFactory().newThread(this); final Thread t = w.thread; if (t != null) &#123; final ReentrantLock mainLock = this.mainLock; mainLock.lock(); try &#123; // Recheck while holding lock. // Back out on ThreadFactory failure or if // shut down before lock acquired. int rs = runStateOf(ctl.get()); if (rs &lt; SHUTDOWN || (rs == SHUTDOWN &amp;&amp; firstTask == null)) &#123; if (t.isAlive()) // precheck that t is startable throw new IllegalThreadStateException(); workers.add(w); int s = workers.size(); if (s &gt; largestPoolSize) largestPoolSize = s; workerAdded = true; &#125; &#125; finally &#123; mainLock.unlock(); &#125; if (workerAdded) &#123; // worker 实例成功创建后，让它启动起来 t.start(); workerStarted = true; &#125; &#125; &#125; finally &#123; if (! workerStarted) addWorkerFailed(w); &#125; return workerStarted;&#125; 接着是 ArrayBlockingQueue 类的 offer 方法，在 enqueue(e)处进入队列： 12345678910111213141516public boolean offer(E e) &#123; checkNotNull(e); final ReentrantLock lock = this.lock; lock.lock(); try &#123; if (count == items.length) return false; else &#123; // 进入队列 enqueue(e); return true; &#125; &#125; finally &#123; lock.unlock(); &#125;&#125; 此时我们先来调试一波，看看入队列时这些方法的执行情况，在三个 if 处分别设置断点，在 addWorker 和 offer 方法靠前的未知打断点，确定是否会进入。 第一次调用 invokeAll：addWorker 进入5次，offer 方法进入5次。 第二次调用 invokeAll：addWorker 进入0次，offer 方法进入10次（可能是5-10次）。 那么发现了新的问题：程序居然没报错！正常执行完成！这不科学！ 带着疑惑，重新 debug，居然还没报错！难道之前的异常是偶然吗？ 以最快速度连按 F9 debug了几次，有时候报错。。 重新运行 run 了几次，次次报错。。 怀疑人生了。。 此时墨菲定律在我头脑中回响，”偶然事件存在必然的因素”。那么大胆猜测，这个原因极有可能是队列消费速度较慢导致的，去查看消费部分的源码。由于 worker 也是一个线程，那么肯定有类似的 run 方法： 查看 ThreadPoolExecutor 类 的 Worker 这个内部类，找到 run() 方法： 123public void run() &#123; runWorker(this);&#125; 而 run 方法调用的是 ThreadPoolExecutor 类里的 runWorker(this)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748final void runWorker(Worker w) &#123; Thread wt = Thread.currentThread(); // 此处注意，将 worker 里存入的 firstTask 取出来，交给下面的 while 去执行 Runnable task = w.firstTask; // 将 worker 里的 firstTask 属性置空 w.firstTask = null; w.unlock(); // allow interrupts boolean completedAbruptly = true; try &#123; // 如果 task 不为空，即取出的 firstTask 不为空，则执行；否则调用 getTask() 方法获取 task 再执行 while (task != null || (task = getTask()) != null) &#123; w.lock(); // If pool is stopping, ensure thread is interrupted; // if not, ensure thread is not interrupted. This // requires a recheck in second case to deal with // shutdownNow race while clearing interrupt if ((runStateAtLeast(ctl.get(), STOP) || (Thread.interrupted() &amp;&amp; runStateAtLeast(ctl.get(), STOP))) &amp;&amp; !wt.isInterrupted()) wt.interrupt(); try &#123; // 此处为空实现，可自定义 beforeExecute(wt, task); Throwable thrown = null; try &#123; // 调用 task 的 run 方法执行任务 task.run(); &#125; catch (RuntimeException x) &#123; thrown = x; throw x; &#125; catch (Error x) &#123; thrown = x; throw x; &#125; catch (Throwable x) &#123; thrown = x; throw new Error(x); &#125; finally &#123; afterExecute(task, thrown); &#125; &#125; finally &#123; task = null; w.completedTasks++; w.unlock(); &#125; &#125; completedAbruptly = false; &#125; finally &#123; processWorkerExit(w, completedAbruptly); &#125;&#125; 查看 ThreadPoolExecutor 类下的 getTask() 方法： 1234567891011121314151617181920212223242526272829303132333435363738private Runnable getTask() &#123; boolean timedOut = false; // Did the last poll() time out? for (;;) &#123; int c = ctl.get(); int rs = runStateOf(c); // Check if queue empty only if necessary. if (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123; decrementWorkerCount(); return null; &#125; int wc = workerCountOf(c); // Are workers subject to culling? boolean timed = allowCoreThreadTimeOut || wc &gt; corePoolSize; if ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut)) &amp;&amp; (wc &gt; 1 || workQueue.isEmpty())) &#123; if (compareAndDecrementWorkerCount(c)) return null; continue; &#125; try &#123; // 此处为出队列操作，poll 和 take 的区别在于，poll 会等待指定时间，而 take 是阻塞的，会一直等待 Runnable r = timed ? workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) : workQueue.take(); if (r != null) return r; timedOut = true; &#125; catch (InterruptedException retry) &#123; timedOut = false; &#125; &#125;&#125; 看到这里，猜测二也就不攻自破，出队列后任务才会被执行，所以某个任务出队列后，执行成功与否与队列再无瓜葛。(注意这个说法只针对默认代码，如果自定义了拒绝策略是可以将被 interrupt 的线程重新塞回队列里的) 两次猜测失败后的总结 队列是异步消费的，但入队是同步进行的，如果队列的容量不足以承载要存入队列的任务数，就会被拒绝。(虽然是 ArrayBlockQueue 的特性，但这是通过 debug 以及 run 后观察到的) 第一次 addWorker 方法执行了5次，offer 执行了5次；第二次则是 0 次，10 次。刚才忽略了这个细节，那么需要重新找到相应的源码阅读。 任务从队列中移除与任务是否执行完毕无关，先移除，后执行。 我们创建的任务，是由 worker 核心线程去调用任务的 run 方法来同步执行的，而不是调用任务实例的 start 去异步执行，这也就是为什么 invokeAll 可以获取到返回值的原因所在。 备注：这里有点绕，任务实例指的是我们最开始在 for 循环中创建的10个tasks new InvokeAllThread()，为什么继承了 Callable 明明改写的是 call()方法，但却有 run()方法可以被调用呢？这是因为在 invokeAll()方法执行execute()方法前，通过RunnableFuture&lt;T&gt; f = newTaskFor(t);进行了包装。 复查源码，真相大白查看 ThreadPoolExecutor 类下的 execute() 方法，创建 worker 前的判断如下： 1if (workerCountOf(c) &lt; corePoolSize) &#123; ...&#125; 第一次调用 invokeAll 时，线程池中的核心线程 worker 数为0，小于 corePoolSize，所以前5次会创建 worker 核心线程并返回，此时随着 worker 的创建，我们创建的10个任务中的5个也会随着 worker 的创建作为 firstTask 属性被传进去。后5个任务则被放入 queue 中。 第二次调用 invokeAll 时，线程池中的核心数已经是5，所以10个任务都会被放入 queue 中异步消费，但是我们的 queue 的容量为5。如果消费速度快于入队速度(debug)，那么10个任务会正常执行。但是入队速度太快的话(run)，前5个肯定可以入队，后面的5个几乎都会被拒绝。 问题解决方案 对于固定大小的线程池，我们要按照实际情况设置 queue 和 worker 的数量。根据任务类型（IO/CPU）以及机器配置（CPU 核数等）设置 worker 核心线程数；而根据我们的任务多少来设定 queue 的大小，而不是 queue + worker 的总数。 重写拒绝策略，将被丢弃的任务重新 put 回队列中去，put 是阻塞的。 参考ThreadPoolExecutor源码分析及阻塞提交任务方法 Thread的中断机制(interrupt)","categories":[],"tags":[{"name":"java","slug":"java","permalink":"https://melodyplayer.github.io/blog/tags/java/"}]},{"title":"搭建博客要点","slug":"搭建博客要点","date":"2019-07-19T07:23:43.000Z","updated":"2019-07-20T06:25:12.055Z","comments":true,"path":"blog/2019/0719:搭建博客要点/","link":"","permalink":"https://melodyplayer.github.io/blog/2019/0719:搭建博客要点/","excerpt":"跟同事一次普通的聊天，谈论到个人博客后，他帮我创建了 github 的博客雏形，从此一发不可收拾。。 一周时间，每天整到半夜2点多，终于搭建完毕。给大家分享下搭建博客核心要点。","text":"跟同事一次普通的聊天，谈论到个人博客后，他帮我创建了 github 的博客雏形，从此一发不可收拾。。 一周时间，每天整到半夜2点多，终于搭建完毕。给大家分享下搭建博客核心要点。 流程参考： https://www.cnblogs.com/liuxianan/p/build-blog-website-by-hexo-github.html https://blog.csdn.net/KNIGH_YUN/article/details/79774344 github 账户创建的仓库名要采用 username.github.io 的形式，才能达到最简洁的 melodyplayer.github.io，不然网站后缀会加斜杠仓库名 “/repoName”，例如：melodyplayer.github.io/melody，增加访问复杂度。 域名绑定 记录类型 A 把域名转发到某个 ipv4 地址上。对于 github 来说可以采用这种方式，ping 一下 github 生成的默认域名拿到 ip 输入到记录值里即可，再在相应的仓库里创建 CNAME 文件。 主机记录填 www 或者不填时， 向github 里的 CNAME文件写入 www.melodyplay.cn 。 主机记录填二级域名例如 blog 时，则向github 里的 CNAME 文件写入 blog.melodyplay.cn 。 记录类型 CNAME 可以把请求转发到另外一个域名上，此时的记录值输入 melodyplayer.github.io 即可。 主题相关主题列表：https://hexo.io/themes/ 我的选择：https://xaoxuu.com/wiki/material-x/ 修改字体：https://www.zhangxinxu.com/wordpress/2017/03/css3-font-face-src-local/ hexo 命令必读：hexo 文档 12345hexo clean #清除public目录，该目录由 hexo g 生成hexo g #生成public目录，如果在source里创建非md文件，会按原样拷贝到public中，例如CNAME的创建hexo s #本地启动hexo服务hexo d #部署到远程仓库hexo new \"x\" #新建文件 hexo 配置本地调试相应的属性时，hexo 会自动编译less、ejd 等文件，可以实时看到结果。 如果要上传到多个平台的仓库下，配置形式： 12345deploy: type: git repository: github: https://github.com/melodyplayer/melodyplayer.github.io.git,master gitee: https://gitee.com/melodyplayer/melodyplayer.git,master gitee 博客使用 gitee 也可以搭建博客，创建方式类似 github 。 仓库名要与用户名一致，才能达到最简洁的 melodyplayer.gitee.io 形式。 gitee 的 ip 好像不是固定的，因此不能在域名解析时直接配置 ip，原来的 CNAME 文件也不会生效。需要通过第三方转发平台如米发做转发，然后再配置域名解析为 CNAME 的方式，但是速度惊人。。的慢。。 具体配置方式参考：https://www.jianshu.com/p/b9466c7e339b 选择图床图床选择也纠结了很久，最终选用了 github 单独仓库做图床，使用 picgo 上传图片。 picgo 可以在上传图片前修改文件名，在文件名前加目录/，变相实现图片归档。 github每个仓库容量1G。 gitee总容量5G，但是不支持图床。 其他图床：img.vim-cn.com、https://sm.ms/ 使用流程：https://xaoxuu.com/projects/vim-cn.sh/ 评论系统评论系统有很多： 参考：https://xaoxuu.com/wiki/material-x/third-party-services/index.html#%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F valine：需要拿身份证实名验证，果断放弃。不在意的朋友可以用下，应该是比较专业的。 gittalk：https://www.voidking.com/2018/07/26/deve-hexo-gitalk-comment-plugin/ gittalk可能无法创建 issue 的问题：https://github.com/viosey/hexo-theme-material/issues/622 对于我采用的主题来说，需要在 scripts 中对 id 进行 md5。 12345678910&lt;% if (enableGitalk) &#123; %&gt; &lt;script src=&quot;https://cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; var gitalk = new Gitalk(&#123; clientID: &quot;&lt;%- config.gitalk.clientID %&gt;&quot;, ...... id: md5(location.pathname), // Ensure uniqueness and length less than 50 ...... &lt;/script&gt;&lt;% &#125; %&gt; 牛人博客推荐的几个美观易读的牛人博客（临时记录在这里，后期维护到移步大佬）： xaouu：我的主题采用的他的，非常感谢。 码酱：java基础 闪烁之狐：java基础，博客排版华丽 匠心零度 程序猿 DD 纯洁的微笑 芋道源码","categories":[],"tags":[{"name":"other","slug":"other","permalink":"https://melodyplayer.github.io/blog/tags/other/"}]},{"title":"旋律演奏猿","slug":"旋律演奏猿","date":"2019-07-16T03:22:26.000Z","updated":"2019-10-17T09:47:48.735Z","comments":true,"path":"blog/2019/0716:旋律演奏猿/","link":"","permalink":"https://melodyplayer.github.io/blog/2019/0716:旋律演奏猿/","excerpt":"开始自己的第一个博客，主要记录和分享在工作和学习中用到的一些技术，也会写一些兴趣爱好的文章，分享一些好听的音乐、精彩的电影等等。集工作学习与休闲一体，秉承简单、开放、匠心的精神，演奏程序猿的生活旋律。","text":"开始自己的第一个博客，主要记录和分享在工作和学习中用到的一些技术，也会写一些兴趣爱好的文章，分享一些好听的音乐、精彩的电影等等。集工作学习与休闲一体，秉承简单、开放、匠心的精神，演奏程序猿的生活旋律。","categories":[],"tags":[{"name":"description","slug":"description","permalink":"https://melodyplayer.github.io/blog/tags/description/"}]}]}