{"meta":{"title":"旋律演奏猿","subtitle":null,"description":"演奏程序猿的生活旋律","author":"Aaron Hu","url":"https://melodyplayer.github.io","root":"/"},"pages":[{"title":"404 Not Found","date":"2019-07-19T13:27:30.956Z","updated":"2019-07-19T11:17:18.382Z","comments":true,"path":"404.html","permalink":"https://melodyplayer.github.io/404.html","excerpt":"","text":"404 Not Found **很抱歉，您访问的页面不存在** 可能是输入地址有误或该地址已被删除"},{"title":"关于","date":"2019-07-19T13:33:52.990Z","updated":"2019-07-19T11:14:35.256Z","comments":true,"path":"about/index.html","permalink":"https://melodyplayer.github.io/about/index.html","excerpt":"","text":""},{"title":"所有分类","date":"2019-07-19T13:38:22.344Z","updated":"2019-07-19T13:38:22.341Z","comments":true,"path":"blog/categories/index.html","permalink":"https://melodyplayer.github.io/blog/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"线程池invokeAll方法详解","slug":"线程池invokeAll方法详解","date":"2019-08-10T13:23:50.000Z","updated":"2019-08-10T16:56:08.594Z","comments":true,"path":"blog/2019/0810:线程池invokeAll方法详解/","link":"","permalink":"https://melodyplayer.github.io/blog/2019/0810:线程池invokeAll方法详解/","excerpt":"线上真实案例，多次调用线程池 ThreadPoolExecutor 的 invokeAll() 方法进行数据统计时任务被拒绝，故事从此开始。 本文重在讲述问题的产生、抽象、寻找解决方法的过程，并结合源码对原因进行抽丝剥茧般的分析。bug 千千万万，唯有合理的逻辑推理思维才能让这些 bug 显露原形。","text":"线上真实案例，多次调用线程池 ThreadPoolExecutor 的 invokeAll() 方法进行数据统计时任务被拒绝，故事从此开始。 本文重在讲述问题的产生、抽象、寻找解决方法的过程，并结合源码对原因进行抽丝剥茧般的分析。bug 千千万万，唯有合理的逻辑推理思维才能让这些 bug 显露原形。 问题起源与抽象先来看一段简单的代码，定义一个核心线程数5、有界队列5的线程池，然后创建10个任务丢进去执行2次。 按照以前对线程池执行逻辑的理解，创建的10个线程，会先交给核心线程去执行，5个核心线程满了之后，存放到队列中，刚好存储剩下的5个，按理说10个任务都会正常执行完毕。本次只测试固定大小的线程池。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class InvokeAllTest &#123; private static ThreadPoolExecutor executor = new ThreadPoolExecutor(5, 5, 60 * 1000, TimeUnit.SECONDS, new ArrayBlockingQueue&lt;&gt;(5), new MyThreadFactory()); public static void main(String[] args) &#123; List&lt;Callable&lt;Void&gt;&gt; tasks = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 10; i++) &#123; tasks.add(new InvokeAllThread()); &#125; System.out.println(\"第一次任务执行前的executor： \" + executor); try &#123; executor.invokeAll(tasks); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(\"第一次任务执行完毕后的executor： \" + executor); System.out.println(\"==============第一次任务执行完毕，开始第二次任务============\"); try &#123; Thread.sleep(1000); executor.invokeAll(tasks); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(\"第二次任务执行完毕后的executor：\" + executor); &#125; // 任务执行线程。通过打印线程名称，观察提交的任务被哪个线程执行 static class InvokeAllThread implements Callable&lt;Void&gt; &#123; @Override public Void call() throws Exception &#123; System.out.println(Thread.currentThread().getName()); return null; &#125; &#125; // 给工作线程自定义名字，方便观察提交的任务被哪个线程执行 static class MyThreadFactory implements ThreadFactory &#123; private AtomicInteger threadNum = new AtomicInteger(1); @Override public Thread newThread(Runnable r) &#123; Thread thread = new Thread(r, String.valueOf(threadNum.getAndIncrement())); if (thread.getPriority() != Thread.NORM_PRIORITY) &#123; thread.setPriority(Thread.NORM_PRIORITY); &#125; return thread; &#125; &#125; 运行程序后发现，第一次调用 invokeAll 正常执行，第二次调用报错。多次执行结果相同。 123456789101112131415161718192021222324第一次任务执行前的executorjava.util.concurrent.ThreadPoolExecutor@30f39991[Running, pool size = 0, active threads = 0, queued tasks = 0, completed tasks = 0]1234453233第一次任务执行完毕后的executorjava.util.concurrent.ThreadPoolExecutor@30f39991[Running, pool size = 5, active threads = 0, queued tasks = 0, completed tasks = 10]==============第一次任务执行完毕，开始第二次任务============24521Exception in thread \"main\" java.util.concurrent.RejectedExecutionException: Task java.util.concurrent.FutureTask@3a71f4dd rejected from java.util.concurrent.ThreadPoolExecutor@30f39991[Running, pool size = 5, active threads = 2, queued tasks = 0, completed tasks = 13] at java.util.concurrent.ThreadPoolExecutor$AbortPolicy.rejectedExecution(ThreadPoolExecutor.java:2063) at java.util.concurrent.ThreadPoolExecutor.reject(ThreadPoolExecutor.java:830) at java.util.concurrent.ThreadPoolExecutor.execute(ThreadPoolExecutor.java:1379) at java.util.concurrent.AbstractExecutorService.invokeAll(AbstractExecutorService.java:238) at com.aaron.hp.thread.pool.InvokeAllTest.main(InvokeAllTest.java:36) 问题排查与猜测既然程序出现异常，就该调用 debug 模式进行排查，并遵循”大胆猜测，小心求证”的态度，去解决这个问题。 猜测一：invokeAll 在异步执行后会不会同步等待线程执行完毕获取最终结果由于 invokeAll 封装的太好，之前只知道最后会同步等待才能获取返回值。那么现在就需要去证实这个概念。 进入 invokeAll 方法后，发现调用了f.get()，那么毫无疑问，这个猜测可以排除掉了。 其实从执行过程的输出内容也可以看出，两次调用 invokeAll 的执行顺序和界限(打印语句) 非常明显。 1234567891011121314151617181920212223242526272829303132public &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks) throws InterruptedException &#123; if (tasks == null) throw new NullPointerException(); ArrayList&lt;Future&lt;T&gt;&gt; futures = new ArrayList&lt;Future&lt;T&gt;&gt;(tasks.size()); boolean done = false; try &#123; for (Callable&lt;T&gt; t : tasks) &#123; RunnableFuture&lt;T&gt; f = newTaskFor(t); futures.add(f); // 任务被添加后的具体执行 execute(f); &#125; for (int i = 0, size = futures.size(); i &lt; size; i++) &#123; Future&lt;T&gt; f = futures.get(i); if (!f.isDone()) &#123; try &#123; // 此处同步等待 f.get(); &#125; catch (CancellationException ignore) &#123; &#125; catch (ExecutionException ignore) &#123; &#125; &#125; &#125; done = true; return futures; &#125; finally &#123; if (!done) for (int i = 0, size = futures.size(); i &lt; size; i++) futures.get(i).cancel(true); &#125;&#125; 猜测二：队列里面可能存在第一次调用 invokeAll 执行了但没有删掉的任务，所以才会导致第二次放入队列失败由于未阅读源码，猜测只有当创建的任务执行完毕并且销毁之后，才会从队列中真正移除。 那么就需要查看入队列和出队列的时机。查看 invokeAll 方法中的 execute(f) 方法。 查看 ThreadPoolExecutor 类下的 execute 方法源码： 12345678910111213141516171819202122public void execute(Runnable command) &#123; if (command == null) throw new NullPointerException(); int c = ctl.get(); // 判断工作线程数是否小于核心线程数，如果是则创建 Worker 工作线并返回 if (workerCountOf(c) &lt; corePoolSize) &#123; if (addWorker(command, true)) return; c = ctl.get(); &#125; // 判断主线程是否在运行，并判断是否入队列成功 if (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123; int recheck = ctl.get(); if (! isRunning(recheck) &amp;&amp; remove(command)) reject(command); else if (workerCountOf(recheck) == 0) addWorker(null, false); &#125; // 否则重新创建 Worker 线程，创建失败则抛出拒绝策略 else if (!addWorker(command, false)) reject(command);&#125; 此时就会发现入队列的操作在workQueue.offer(command)处完成，而我们提交的任务是由一个叫 Worker 类的实例来执行，addWorker(command, true)创建 Worker 实例。 那么我们就分别进去这两个方法来看下源码： 矮油黑人问号脸。。没想到这个 ThreadPoolExecutor 类的 addWorker 这么长，给核心代码写个注释重点关注，扫一眼然后去看 offer 方法(英文注释是源码中自带的)。前面都是校验，创建核心线程处为new Worker(firstTask)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869private boolean addWorker(Runnable firstTask, boolean core) &#123; retry: for (;;) &#123; int c = ctl.get(); int rs = runStateOf(c); // Check if queue empty only if necessary. if (rs &gt;= SHUTDOWN &amp;&amp; ! (rs == SHUTDOWN &amp;&amp; firstTask == null &amp;&amp; ! workQueue.isEmpty())) return false; for (;;) &#123; int wc = workerCountOf(c); if (wc &gt;= CAPACITY || wc &gt;= (core ? corePoolSize : maximumPoolSize)) return false; if (compareAndIncrementWorkerCount(c)) break retry; c = ctl.get(); // Re-read ctl if (runStateOf(c) != rs) continue retry; // else CAS failed due to workerCount change; retry inner loop &#125; &#125; boolean workerStarted = false; boolean workerAdded = false; Worker w = null; try &#123; // 上面一堆都是校验，此处才是 Worker 被创建的地方，注意被传入的 firstTask w = new Worker(firstTask); // 此处发现 Worker 里面居然还有个 therad 线程，不过想想也是，没有线程怎么异步执行呢。点进 Worker 的构造方法看一眼就会发现，这个线程就是由我们自定义的 threadFactory 来创建的，所以核心线程名称就是我们之前设定好的名字。this.thread = getThreadFactory().newThread(this); final Thread t = w.thread; if (t != null) &#123; final ReentrantLock mainLock = this.mainLock; mainLock.lock(); try &#123; // Recheck while holding lock. // Back out on ThreadFactory failure or if // shut down before lock acquired. int rs = runStateOf(ctl.get()); if (rs &lt; SHUTDOWN || (rs == SHUTDOWN &amp;&amp; firstTask == null)) &#123; if (t.isAlive()) // precheck that t is startable throw new IllegalThreadStateException(); workers.add(w); int s = workers.size(); if (s &gt; largestPoolSize) largestPoolSize = s; workerAdded = true; &#125; &#125; finally &#123; mainLock.unlock(); &#125; if (workerAdded) &#123; // worker 实例成功创建后，让它启动起来 t.start(); workerStarted = true; &#125; &#125; &#125; finally &#123; if (! workerStarted) addWorkerFailed(w); &#125; return workerStarted;&#125; 接着是 ArrayBlockingQueue 类的 offer 方法，在 enqueue(e)处进入队列： 12345678910111213141516public boolean offer(E e) &#123; checkNotNull(e); final ReentrantLock lock = this.lock; lock.lock(); try &#123; if (count == items.length) return false; else &#123; // 进入队列 enqueue(e); return true; &#125; &#125; finally &#123; lock.unlock(); &#125;&#125; 此时我们先来调试一波，看看入队列时这些方法的执行情况，在三个 if 处分别设置断点，在 addWorker 和 offer 方法靠前的未知打断点，确定是否会进入。 第一次调用 invokeAll：addWorker 进入5次，offer 方法进入5次。 第二次调用 invokeAll：addWorker 进入0次，offer 方法进入10次（可能是5-10次）。 那么发现了新的问题：程序居然没报错！正常执行完成！这不科学！ 带着疑惑，重新 debug，居然还没报错！难道之前的异常是偶然吗？ 以最快速度连按 F9 debug了几次，有时候报错。。 重新运行 run 了几次，次次报错。。 怀疑人生了。。 此时墨菲定律在我头脑中回响，”偶然事件存在必然的因素”。那么大胆猜测，这个原因极有可能是队列消费速度较慢导致的，去查看消费部分的源码。由于 worker 也是一个线程，那么肯定有类似的 run 方法： 查看 ThreadPoolExecutor 类 的 Worker 这个内部类，找到 run() 方法： 123public void run() &#123; runWorker(this);&#125; 而 run 方法调用的是 ThreadPoolExecutor 类里的 runWorker(this)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748final void runWorker(Worker w) &#123; Thread wt = Thread.currentThread(); // 此处注意，将 worker 里存入的 firstTask 取出来，交给下面的 while 去执行 Runnable task = w.firstTask; // 将 worker 里的 firstTask 属性置空 w.firstTask = null; w.unlock(); // allow interrupts boolean completedAbruptly = true; try &#123; // 如果 task 不为空，即取出的 firstTask 不为空，则执行；否则调用 getTask() 方法获取 task 再执行 while (task != null || (task = getTask()) != null) &#123; w.lock(); // If pool is stopping, ensure thread is interrupted; // if not, ensure thread is not interrupted. This // requires a recheck in second case to deal with // shutdownNow race while clearing interrupt if ((runStateAtLeast(ctl.get(), STOP) || (Thread.interrupted() &amp;&amp; runStateAtLeast(ctl.get(), STOP))) &amp;&amp; !wt.isInterrupted()) wt.interrupt(); try &#123; // 此处为空实现，可自定义 beforeExecute(wt, task); Throwable thrown = null; try &#123; // 调用 task 的 run 方法执行任务 task.run(); &#125; catch (RuntimeException x) &#123; thrown = x; throw x; &#125; catch (Error x) &#123; thrown = x; throw x; &#125; catch (Throwable x) &#123; thrown = x; throw new Error(x); &#125; finally &#123; afterExecute(task, thrown); &#125; &#125; finally &#123; task = null; w.completedTasks++; w.unlock(); &#125; &#125; completedAbruptly = false; &#125; finally &#123; processWorkerExit(w, completedAbruptly); &#125;&#125; 查看 ThreadPoolExecutor 类下的 getTask() 方法： 1234567891011121314151617181920212223242526272829303132333435363738private Runnable getTask() &#123; boolean timedOut = false; // Did the last poll() time out? for (;;) &#123; int c = ctl.get(); int rs = runStateOf(c); // Check if queue empty only if necessary. if (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123; decrementWorkerCount(); return null; &#125; int wc = workerCountOf(c); // Are workers subject to culling? boolean timed = allowCoreThreadTimeOut || wc &gt; corePoolSize; if ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut)) &amp;&amp; (wc &gt; 1 || workQueue.isEmpty())) &#123; if (compareAndDecrementWorkerCount(c)) return null; continue; &#125; try &#123; // 此处为出队列操作，poll 和 take 的区别在于，poll 会等待指定时间，而 take 是阻塞的，会一直等待 Runnable r = timed ? workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) : workQueue.take(); if (r != null) return r; timedOut = true; &#125; catch (InterruptedException retry) &#123; timedOut = false; &#125; &#125;&#125; 看到这里，猜测二也就不攻自破，出队列后任务才会被执行，所以某个任务出队列后，执行成功与否与队列再无瓜葛。(注意这个说法只针对默认代码，如果自定义了拒绝策略是可以将被 interrupt 的线程重新塞回队列里的) 两次猜测失败后的总结 队列是异步消费的，但入队是同步进行的，如果队列的容量不足以承载要存入队列的任务数，就会被拒绝。(虽然是 ArrayBlockQueue 的特性，但这是通过 debug 以及 run 后观察到的) 第一次 addWorker 方法执行了5次，offer 执行了5次；第二次则是 0 次，10 次。刚才忽略了这个细节，那么需要重新找到相应的源码阅读。 任务从队列中移除与任务是否执行完毕无关，先移除，后执行。 我们创建的任务，是由 worker 核心线程去调用任务的 run 方法来同步执行的，而不是调用任务实例的 start 去异步执行，这也就是为什么 invokeAll 可以获取到返回值的原因所在。 备注：这里有点绕，任务实例指的是我们最开始在 for 循环中创建的10个tasks new InvokeAllThread()，为什么继承了 Callable 明明改写的是 call()方法，但却有 run()方法可以被调用呢？这是因为在 invokeAll()方法执行execute()方法前，通过RunnableFuture&lt;T&gt; f = newTaskFor(t);进行了包装。 复查源码，真相大白查看 ThreadPoolExecutor 类下的 execute() 方法，创建 worker 前的判断如下： 1if (workerCountOf(c) &lt; corePoolSize) &#123; ...&#125; 第一次调用 invokeAll 时，线程池中的核心线程 worker 数为0，小于 corePoolSize，所以前5次会创建 worker 核心线程并返回，此时随着 worker 的创建，我们创建的10个任务中的5个也会随着 worker 的创建作为 firstTask 属性被传进去。后5个任务则被放入 queue 中。 第二次调用 invokeAll 时，线程池中的核心数已经是5，所以10个任务都会被放入 queue 中异步消费，但是我们的 queue 的容量为5。如果消费速度快于入队速度(debug)，那么10个任务会正常执行。但是入队速度太快的话(run)，前5个肯定可以入队，后面的5个几乎都会被拒绝。 问题解决方案 对于固定大小的线程池，我们要按照实际情况设置 queue 和 worker 的数量。根据任务类型（IO/CPU）以及机器配置（CPU 核数等）设置 worker 核心线程数；而根据我们的任务多少来设定 queue 的大小，而不是 queue + worker 的总数。 重写拒绝策略，将被丢弃的任务重新 put 回队列中去，put 是阻塞的。 参考ThreadPoolExecutor源码分析及阻塞提交任务方法 Thread的中断机制(interrupt)","categories":[],"tags":[{"name":"java","slug":"java","permalink":"https://melodyplayer.github.io/blog/tags/java/"}]},{"title":"搭建博客要点","slug":"搭建博客要点","date":"2019-07-19T07:23:43.000Z","updated":"2019-07-20T06:25:12.055Z","comments":true,"path":"blog/2019/0719:搭建博客要点/","link":"","permalink":"https://melodyplayer.github.io/blog/2019/0719:搭建博客要点/","excerpt":"跟同事一次普通的聊天，谈论到个人博客后，他帮我创建了 github 的博客雏形，从此一发不可收拾。。 一周时间，每天整到半夜2点多，终于搭建完毕。给大家分享下搭建博客核心要点。","text":"跟同事一次普通的聊天，谈论到个人博客后，他帮我创建了 github 的博客雏形，从此一发不可收拾。。 一周时间，每天整到半夜2点多，终于搭建完毕。给大家分享下搭建博客核心要点。 流程参考： https://www.cnblogs.com/liuxianan/p/build-blog-website-by-hexo-github.html https://blog.csdn.net/KNIGH_YUN/article/details/79774344 github 账户创建的仓库名要采用 username.github.io 的形式，才能达到最简洁的 melodyplayer.github.io，不然网站后缀会加斜杠仓库名 “/repoName”，例如：melodyplayer.github.io/melody，增加访问复杂度。 域名绑定 记录类型 A 把域名转发到某个 ipv4 地址上。对于 github 来说可以采用这种方式，ping 一下 github 生成的默认域名拿到 ip 输入到记录值里即可，再在相应的仓库里创建 CNAME 文件。 主机记录填 www 或者不填时， 向github 里的 CNAME文件写入 www.melodyplay.cn 。 主机记录填二级域名例如 blog 时，则向github 里的 CNAME 文件写入 blog.melodyplay.cn 。 记录类型 CNAME 可以把请求转发到另外一个域名上，此时的记录值输入 melodyplayer.github.io 即可。 主题相关主题列表：https://hexo.io/themes/ 我的选择：https://xaoxuu.com/wiki/material-x/ 修改字体：https://www.zhangxinxu.com/wordpress/2017/03/css3-font-face-src-local/ hexo 命令必读：hexo 文档 12345hexo clean #清除public目录，该目录由 hexo g 生成hexo g #生成public目录，如果在source里创建非md文件，会按原样拷贝到public中，例如CNAME的创建hexo s #本地启动hexo服务hexo d #部署到远程仓库hexo new \"x\" #新建文件 hexo 配置本地调试相应的属性时，hexo 会自动编译less、ejd 等文件，可以实时看到结果。 如果要上传到多个平台的仓库下，配置形式： 12345deploy: type: git repository: github: https://github.com/melodyplayer/melodyplayer.github.io.git,master gitee: https://gitee.com/melodyplayer/melodyplayer.git,master gitee 博客使用 gitee 也可以搭建博客，创建方式类似 github 。 仓库名要与用户名一致，才能达到最简洁的 melodyplayer.gitee.io 形式。 gitee 的 ip 好像不是固定的，因此不能在域名解析时直接配置 ip，原来的 CNAME 文件也不会生效。需要通过第三方转发平台如米发做转发，然后再配置域名解析为 CNAME 的方式，但是速度惊人。。的慢。。 具体配置方式参考：https://www.jianshu.com/p/b9466c7e339b 选择图床图床选择也纠结了很久，最终选用了 github 单独仓库做图床，使用 picgo 上传图片。 picgo 可以在上传图片前修改文件名，在文件名前加目录/，变相实现图片归档。 github每个仓库容量1G。 gitee总容量5G，但是不支持图床。 其他图床：img.vim-cn.com、https://sm.ms/ 使用流程：https://xaoxuu.com/projects/vim-cn.sh/ 评论系统评论系统有很多： 参考：https://xaoxuu.com/wiki/material-x/third-party-services/index.html#%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F valine：需要拿身份证实名验证，果断放弃。不在意的朋友可以用下，应该是比较专业的。 gittalk：https://www.voidking.com/2018/07/26/deve-hexo-gitalk-comment-plugin/ gittalk可能无法创建 issue 的问题：https://github.com/viosey/hexo-theme-material/issues/622 对于我采用的主题来说，需要在 scripts 中对 id 进行 md5。 12345678910&lt;% if (enableGitalk) &#123; %&gt; &lt;script src=&quot;https://cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; var gitalk = new Gitalk(&#123; clientID: &quot;&lt;%- config.gitalk.clientID %&gt;&quot;, ...... id: md5(location.pathname), // Ensure uniqueness and length less than 50 ...... &lt;/script&gt;&lt;% &#125; %&gt; 牛人博客推荐的几个美观易读的牛人博客（临时记录在这里，后期维护到移步大佬）： xaouu：我的主题采用的他的，非常感谢。 码酱：java基础 闪烁之狐：java基础，博客排版华丽 匠心零度 程序猿 DD 纯洁的微笑 芋道源码","categories":[],"tags":[{"name":"other","slug":"other","permalink":"https://melodyplayer.github.io/blog/tags/other/"}]},{"title":"旋律演奏猿","slug":"旋律演奏猿","date":"2019-07-16T03:22:26.000Z","updated":"2019-07-20T04:19:21.328Z","comments":true,"path":"blog/2019/0716:旋律演奏猿/","link":"","permalink":"https://melodyplayer.github.io/blog/2019/0716:旋律演奏猿/","excerpt":"","text":"开始自己的第一个博客，主要记录和分享在工作和学习中用到的一些技术，也会写一些兴趣爱好的文章，分享一些好听的音乐、精彩的电影等等。集工作学习与休闲一体，秉承简单、开放、匠心的精神，演奏程序猿的生活旋律。","categories":[],"tags":[{"name":"description","slug":"description","permalink":"https://melodyplayer.github.io/blog/tags/description/"}]}]}